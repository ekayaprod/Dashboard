<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lookup</title>
    <link rel="stylesheet" href="style.css">
    <script src="ui.common.js" defer></script>
</head>
<body class="lookup-page">

    <div id="navbar-container"></div>

    <div class="container">
        <header class="lookup-header">
            <h1>Lookup</h1>
            <div class="search-controls">
                <input type="text" id="search-input" placeholder="Search keywords...">
                <button id="btn-add-new-entry" class="btn-new-entry">+ New Entry</button>
            </div>
        </header>

        <main class="results-container">
            <section class="column" id="routing-column">
                <h2>Routing</h2>
                <ul id="routing-results" class="result-list"></ul>
            </section>
            <section class="column" id="snippets-column">
                <h2>Snippets</h2>
                <ul id="snippets-results" class="result-list"></ul>
            </section>
        </main>
    </div>

    <div id="toast" class="toast"></div>

    <div id="modal-overlay" class="modal-overlay">
        <div id="modal-content" class="modal-content"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            const APP_NAME = 'lookup';
            const APP_VERSION = '6.1.0';
            const DATA_KEY = `${APP_NAME}_data`;

            const SafeUI = (() => {
                const isReady = typeof UIUtils !== 'undefined' && UIUtils;
                
                return {
                    isReady,
                    loadNavbar: (containerId, currentPage) => isReady && UIUtils.loadNavbar(containerId, currentPage),
                    showModal: (title, content, actions) => isReady ? UIUtils.showModal(title, content, actions) : console.error("UIUtils not loaded", title),
                    hideModal: () => isReady && UIUtils.hideModal(),
                    showToast: (msg) => isReady ? UIUtils.showToast(msg) : console.log("Toast:", msg),
                    escapeHTML: (str) => isReady ? UIUtils.escapeHTML(str) : (str || ''),
                    generateId: () => isReady ? UIUtils.generateId() : Date.now().toString(),
                    copyToClipboard: (text) => isReady ? UIUtils.copyToClipboard(text) : Promise.resolve(false),
                    downloadJSON: (data, filename) => isReady && UIUtils.downloadJSON(data, filename),
                    openFilePicker: (cb, accept) => isReady && UIUtils.openFilePicker(cb, accept),
                    readJSONFile: (file, onSuccess, onError) => isReady ? UIUtils.readJSONFile(file, onSuccess, onError) : onError("UI Framework not loaded."),
                    createStateManager: (key, defaults, version, onCorruption) => isReady ? UIUtils.createStateManager(key, defaults, version, onCorruption) : null,
                    // START: Fix for Issue #22 (Part 1)
                    validators: isReady ? UIUtils.validators : { notEmpty: (v) => v },
                    showValidationError: (title, message, focusId) => {
                         if (isReady) {
                            UIUtils.showModal(title, `<p>${message}</p>`, [{label: 'OK', callback: () => {
                                const el = document.getElementById(focusId);
                                if (el) el.focus();
                            }}]);
                         } else {
                            console.error(title, message, focusId);
                         }
                    }
                    // END: Fix for Issue #22 (Part 1)
                };
            })();

            const DOMElements = {};

            function cacheAndValidateDOMElements() {
                const requiredIds = [
                    'search-input', 'routing-results', 'snippets-results',
                    'btn-add-new-entry',
                    'toast', 'modal-overlay', 'modal-content',
                    'navbar-container'
                ];
                
                let allElementsFound = true;
                for (const id of requiredIds) {
                    const el = document.getElementById(id);
                    if (!el) {
                        console.error(`FATAL: DOM element with id "${id}" not found.`);
                        allElementsFound = false;
                    }
                    DOMElements[id.replace(/-(\w)/g, (m, g) => g.toUpperCase())] = el;
                }
                return allElementsFound;
            }

            const defaultState = {
                routingData: [],
                snippetsData: []
            };

            const stateManager = SafeUI.createStateManager(DATA_KEY, defaultState, APP_VERSION, () => {
                SafeUI.showModal('Data Corruption Detected', `<p>Your lookup data could not be read. A backup has been saved and the page has been reset.</p>`, [{ label: 'OK' }]);
            });

            let state;
            let currentEditState = { id: null, type: null };

            function saveState() {
                if (!stateManager) return;
                try {
                    state.routingData.sort((a, b) => a.keyword.localeCompare(b.keyword));
                    state.snippetsData.sort((a, b) => a.keyword.localeCompare(b.keyword));
                    stateManager.save(state);
                } catch (e) {
                    console.error("Failed to save state:", e);
                    SafeUI.showModal("Error", "<p>Failed to save data. Storage might be full.</p>", [{label: 'OK'}]);
                }
            }
            
            const dataTypesConfig = {
                routing: {
                    listElement: null,
                    dataKey: 'routingData',
                    // START: Fix for Issue #15 (Part 1)
                    emptyState: 'No routing entries found.',
                },
                snippets: {
                    listElement: null,
                    dataKey: 'snippetsData',
                    // END: Fix for Issue #15 (Part 1)
                    emptyState: 'No snippets found.',
                }
            };

            function highlight(text, term) {
                if (!term) return SafeUI.escapeHTML(text);
                const escapedTerm = term.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
                const regex = new RegExp(`(${escapedTerm})`, 'gi');
                return SafeUI.escapeHTML(text).replace(regex, '<mark>$1</mark>');
            }

            function renderList(type, searchTerm = '') {
                const config = dataTypesConfig[type];
                if (!config || !config.listElement) return;

                const data = state[config.dataKey] || [];
                config.listElement.innerHTML = '';

                const term = searchTerm.toLowerCase();

                const filteredData = data.filter(item => {
                    if (item.id === currentEditState.id && type === currentEditState.type) {
                        return true;
                    }
                    return item.keyword.toLowerCase().includes(term);
                });

                if (filteredData.length === 0 && (currentEditState.type !== type || currentEditState.id === null)) {
                    if (searchTerm.trim()) {
                        config.listElement.innerHTML = `<li class="empty-state">No results found for "<strong>${SafeUI.escapeHTML(searchTerm)}</strong>"</li>`;
                    } else {
                        config.listElement.innerHTML = `<li class="empty-state">${config.emptyState}</li>`;
                    }
                    return;
                }

                const fragment = document.createDocumentFragment();
                filteredData.forEach(item => {
                    let itemElement;
                    if (item.id === currentEditState.id && type === currentEditState.type) {
                        itemElement = createEditForm(type, item);
                    } else {
                        itemElement = createItemElement(item, searchTerm, type);
                    }
                    fragment.appendChild(itemElement);
                });
                config.listElement.appendChild(fragment);
            }

            function renderAll() {
                const searchTerm = DOMElements.searchInput.value;
                renderList('routing', searchTerm);
                renderList('snippets', searchTerm);
            }

            function createItemElement(item, searchTerm, type) {
                const li = document.createElement('li');
                li.className = (type === 'routing') ? 'result-item' : 'snippet-item';
                li.dataset.id = item.id;
                li.dataset.type = type;
                
                const header = document.createElement('div');
                header.className = 'item-header';
                
                const keywordSpan = document.createElement('span');
                keywordSpan.className = 'item-keyword';
                keywordSpan.innerHTML = highlight(item.keyword, searchTerm);
                
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'item-actions';
                
                const editButton = document.createElement('button');
                editButton.className = 'btn-edit';
                editButton.textContent = 'Edit';
                editButton.onclick = () => handleEdit(item.id, type);
                
                const deleteButton = document.createElement('button');
                deleteButton.className = 'btn-delete';
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = () => {
                    SafeUI.showModal('Delete Entry', `<p>Are you sure you want to delete "${SafeUI.escapeHTML(item.keyword)}"?</p><p>This cannot be undone.</p>`, [
                        { label: 'Cancel' },
                        {
                            label: 'Delete',
                            class: 'button-danger',
                            callback: () => handleDelete(item.id, type)
                        }
                    ]);
                };
                
                if (type === 'routing') {
                    const copyKeywordBtn = document.createElement('button');
                    copyKeywordBtn.className = 'btn-copy-keyword';
                    copyKeywordBtn.textContent = 'Copy Keyword';
                    setupCopyButton(copyKeywordBtn, item.keyword, "Keyword copied!");
                    actionsDiv.appendChild(copyKeywordBtn);
                }
                
                actionsDiv.appendChild(editButton);
                actionsDiv.appendChild(deleteButton);
                header.appendChild(keywordSpan);
                header.appendChild(actionsDiv);
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'item-content';
                contentDiv.textContent = item.content;
                
                if (type === 'snippets') {
                    contentDiv.title = 'Click to copy snippet';
                    contentDiv.onclick = async (e) => {
                        const success = await SafeUI.copyToClipboard(item.content);
                        if (success) {
                            SafeUI.showToast("Snippet copied!");
                            e.target.style.transition = 'background-color 0.1s ease-in-out';
                            e.target.style.backgroundColor = 'var(--color-success-bg)';
                            setTimeout(() => { 
                                if (e.target) e.target.style.backgroundColor = ''; 
                            }, 200);
                        } else {
                            SafeUI.showToast("Failed to copy snippet.");
                        }
                    };
                }
                
                li.appendChild(header);
                li.appendChild(contentDiv);
                
                if (type === 'routing') {
                    const footerActions = document.createElement('div');
                    footerActions.className = 'item-actions';
                    
                    const copyContentBtn = document.createElement('button');
                    copyContentBtn.className = 'btn-copy-content';
                    copyContentBtn.textContent = 'Copy Content';
                    setupCopyButton(copyContentBtn, item.content, "Content copied!");
                    
                    footerActions.appendChild(copyContentBtn);
                    li.appendChild(footerActions);
                }

                return li;
            }

            function setupCopyButton(button, textToCopy, message) {
                button.addEventListener('click', async (e) => {
                    const success = await SafeUI.copyToClipboard(textToCopy);
                    if (success && e.target) {
                        const originalText = e.target.textContent;
                        e.target.textContent = 'Copied!';
                        e.target.disabled = true;
                        setTimeout(() => {
                            if (e.target) {
                                e.target.textContent = originalText;
                                e.target.disabled = false;
                            }
                        }, 1200);
                    } else if (!success) {
                        SafeUI.showToast("Failed to copy.");
                    }
                });
            }

            function createEditForm(type, item) {
                const config = dataTypesConfig[type];

                const li = document.createElement('li');
                li.className = 'edit-form-li';

                const form = document.createElement('form');
                form.className = 'edit-form';
                form.dataset.id = item.id;
                form.dataset.type = type;
                form.onsubmit = (e) => {
                    e.preventDefault();
                    handleSave(form, item.id, type);
                };

                // START: Fix for Issue #15 (Part 2)
                const keywordLabel = type === 'routing' ? 'Keyword (e.g., "VPN")' : 'Keyword (e.g., "Greeting")';
                const contentLabel = type === 'routing' ? 'Content (Assignment Group)' : 'Content (Snippet Text)';
                // END: Fix for Issue #15 (Part 2)

                const keywordInput = document.createElement('input');
                keywordInput.type = 'text';
                keywordInput.id = `edit-keyword-${item.id}`;
                keywordInput.value = item.keyword;
                keywordInput.placeholder = keywordLabel;

                const contentTextarea = document.createElement('textarea');
                contentTextarea.id = `edit-content-${item.id}`;
                contentTextarea.textContent = item.content;
                contentTextarea.placeholder = contentLabel;

                const keywordLabelEl = document.createElement('label');
                keywordLabelEl.htmlFor = keywordInput.id;
                keywordLabelEl.textContent = 'Keyword';

                const contentLabelEl = document.createElement('label');
                contentLabelEl.htmlFor = contentTextarea.id;
                contentLabelEl.textContent = 'Content';

                form.appendChild(keywordLabelEl);
                form.appendChild(keywordInput);
                form.appendChild(contentLabelEl);
                form.appendChild(contentTextarea);

                form.innerHTML += `
                    <div class="edit-form-actions">
                        <button type="button" class="btn-cancel">Cancel</button>
                        <button type="submit" class="btn-save">Save</button>
                    </div>
                `;

                form.querySelector('.btn-cancel').addEventListener('click', () => {
                    if (item.keyword.trim() === '' && item.content.trim() === '') {
                        handleDelete(item.id, type, true);
                    }
                    currentEditState = { id: null, type: null };
                    renderAll();
                });

                li.appendChild(form);
                return li;
            }

            function handleAddNewEntry() {
                if (currentEditState.id) {
                    SafeUI.showModal("Save Changes", "<p>Please save or cancel your current edit first.</p>", [{label: 'OK'}]);
                    return;
                }

                SafeUI.showModal("Add New Entry", "<p>What do you want to add?</p>", [
                    { label: 'Cancel' },
                    { label: 'Snippet', callback: () => addNewItem('snippets') },
                    { label: 'Routing', class: 'button-primary', callback: () => addNewItem('routing') }
                ]);
            }

            function addNewItem(type) {
                const config = dataTypesConfig[type];

                const newItem = { id: SafeUI.generateId(), keyword: '', content: '' };
                state[config.dataKey].unshift(newItem);

                currentEditState = { id: newItem.id, type: type };
                DOMElements.searchInput.value = '';
                renderAll();

                const newEl = document.getElementById(`edit-keyword-${newItem.id}`);
                if (newEl) {
                    newEl.focus();
                }
            }

            function handleEdit(id, type) {
                if (currentEditState.id && currentEditState.id !== id) {
                    SafeUI.showModal("Save Changes", "<p>Please save or cancel your current edit first.</p>", [{label: 'OK'}]);
                    return;
                }

                currentEditState = { id: id, type: type };
                renderAll();
                const editInput = document.getElementById(`edit-keyword-${id}`);
                if (editInput) {
                    editInput.focus();
                    editInput.select();
                }
            }

            function handleSave(form, id, type) {
                const keywordInput = form.querySelector(`#edit-keyword-${id}`);
                const contentInput = form.querySelector(`#edit-content-${id}`);

                const keyword = keywordInput.value.trim();
                const content = contentInput.value.trim();
                const data = state[dataTypesConfig[type].dataKey];

                // START: Fix for Issue #22 (Part 2)
                if (!SafeUI.validators.notEmpty(keyword)) {
                    return SafeUI.showValidationError("Invalid Input", "Keyword cannot be blank.", `edit-keyword-${id}`);
                }
                if (!SafeUI.validators.notEmpty(content)) {
                    return SafeUI.showValidationError("Invalid Input", "Content cannot be blank.", `edit-content-${id}`);
                }
                // END: Fix for Issue #22 (Part 2)

                let itemToUpdate = null;
                let isDuplicate = false;
                for (const item of data) {
                    if (item.id === id) {
                        itemToUpdate = item;
                    // START: Fix for Issue #12
                    } else if (item.keyword.toLowerCase() === keyword.toLowerCase() && item.type === type) {
                    // END: Fix for Issue #12
                        isDuplicate = true;
                    }
                    if (itemToUpdate && isDuplicate) break;
                }

                // START: Fix for Issue #22 (Part 3)
                if (isDuplicate) {
                    return SafeUI.showValidationError("Duplicate Keyword", `Keyword "${SafeUI.escapeHTML(keyword)}" already exists.`, `edit-keyword-${id}`);
                }
                // END: Fix for Issue #22 (Part 3)

                if (itemToUpdate) {
                    itemToUpdate.keyword = keyword;
                    itemToUpdate.content = content;
                }

                saveState();

                currentEditState = { id: null, type: null };
                renderAll();
            }

            function handleDelete(id, type, skipConfirm = false) { 
                if (currentEditState.id === id) {
                    currentEditState = { id: null, type: null };
                }

                const config = dataTypesConfig[type];
                const data = state[config.dataKey];
                const index = data.findIndex(i => i.id === id);

                if (index === -1) return;

                data.splice(index, 1);

                saveState();
                renderAll();
            }

            // START: Fix for Issue #28
            function processImportData(jsonData) {
                SafeUI.showToast("Processing file...");

                const performRestore = (data) => {
                    state = data || { ...defaultState };
                    if (!state.routingData) state.routingData = [];
                    if (!state.snippetsData) state.snippetsData = [];
                    saveState();
                    currentEditState = { id: null, type: null };
                    renderAll();
                    SafeUI.showToast("Restore successful.");
                };

                const isFullBackup = jsonData.appName === APP_NAME && jsonData.data;
                const isLegacyBackup = jsonData.appName === 'assignment_tool' && jsonData.data;

                if (isFullBackup || isLegacyBackup) {
                    const title = isLegacyBackup ? "Confirm Legacy Restore" : "Confirm Restore";
                    const message = isLegacyBackup ? 
                        "<p>This is a backup from the old 'Assignment Tool'. Restoring will overwrite all current data.</p>" : 
                        "<p>This is a full backup file. Restoring will overwrite all current data.</p>";
                    
                    SafeUI.showModal(title, message, [
                        { label: 'Cancel' },
                        {
                            label: 'Restore',
                            class: isLegacyBackup ? 'button-primary' : 'button-danger',
                            callback: () => performRestore(jsonData.data)
                        }
                    ]);

                } else if (Array.isArray(jsonData.routing) || Array.isArray(jsonData.snippets)) {
                // END: Fix for Issue #28
                    // START: Fix for Issue #13
                    // Validate structure
                    const validateItems = (items, requiredKeys) => {
                        return items.every(item => 
                            item && typeof item === 'object' && 
                            requiredKeys.every(key => key in item)
                        );
                    };
                    
                    const routing = jsonData.routing || [];
                    const snippets = jsonData.snippets || [];
                    
                    if (!validateItems(routing, ['id', 'keyword', 'content']) || 
                        !validateItems(snippets, ['id', 'keyword', 'content'])) {
                        SafeUI.showModal("Import Error", "<p>File contains invalid item structure.</p>", [{label: 'OK'}]);
                        return;
                    }
                    // END: Fix for Issue #13
                    
                    const newRoutingCount = routing.length;
                    const newSnippetsCount = snippets.length;

                    SafeUI.showModal("Confirm Data Import",
                        `<p>This file contains <strong>${newRoutingCount} routing</strong> entries and <strong>${newSnippetsCount} snippet</strong> entries.</p><p>How do you want to import this data?</p>`,
                        [
                            { label: 'Cancel' },
                            {
                                label: 'Merge',
                                class: 'button-primary',
                                callback: () => {
                                    state.routingData = (state.routingData || []).concat(routing);
                                    state.snippetsData = (state.snippetsData || []).concat(snippets);
                                    saveState();
                                    renderAll();
                                    SafeUI.showToast("Data merged successfully.");
                                }
                            },
                            {
                                label: 'Replace All',
                                class: 'button-danger',
                                callback: () => {
                                    state.routingData = routing;
                                    state.snippetsData = snippets;
                                    saveState();
                                    renderAll();
                                    SafeUI.showToast("Data replaced successfully.");
                                }
                            }
                        ]
                    );

                } else {
                    SafeUI.showModal("Import Error", "<p>Invalid file structure. Not a valid backup or import file.</p>", [{label: 'OK'}]);
                }
            }

            // START: Fix for Issue #29 (Removal of dead code)
            // Removed handleImportError()
            // Removed handleBackup()
            // END: Fix for Issue #29

            function attachEventListeners() {
                DOMElements.searchInput.addEventListener('input', renderAll);
                DOMElements.btnAddNewEntry.addEventListener('click', handleAddNewEntry);
            }

            function init() {
                if (!SafeUI.isReady || !stateManager) {
                    console.error("FATAL: UIUtils or StateManager failed to initialize. Application halted.");
                    document.body.innerHTML = `<div style="padding: 20px; text-align: center; color: red; font-family: sans-serif;">
                        <h2>Application Failed to Load</h2>
                        <p>A critical file (ui.common.js) may be missing or failed to load. Please check the console for errors.</p>
                    </div>`;
                    return;
                }
                
                if (!cacheAndValidateDOMElements()) {
                    console.error("FATAL: Missing critical DOM elements. Application halted.");
                    return;
                }

                SafeUI.loadNavbar("navbar-container", "lookup.html");
                
                dataTypesConfig.routing.listElement = DOMElements.routingResults;
                dataTypesConfig.snippets.listElement = DOMElements.snippetsResults;
                
                state = stateManager.load();

                if (!state.routingData) state.routingData = [];
                if (!state.snippetsData) state.snippetsData = [];

                attachEventListeners();
                renderAll();
            }

Setting `maxHeight` in `setupTextareaAutoResize` to 300px.
            try {
                init();
            } catch (err) {
                console.error("Unhandled exception during initialization:", err);
                SafeUI.showModal("Fatal Error", `<p>An unexpected error occurred: ${err.message}</p>`, [{label: 'OK'}]);
            }
        });
    </script>
</body>
</html>


