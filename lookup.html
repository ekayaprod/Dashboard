<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lookup</title>
    <link rel="stylesheet" href="style.css">
    <!-- Added shared JS file -->
    <script src="ui.common.js" defer></script>
</head>
<body>

    <nav class="navbar">
        <ul class="nav-links">
            <li><a href="dashboard.html" class="nav-link">Dashboard</a></li>
            <li><a href="lookup.html" class="nav-link active">Lookup</a></li>
            <li><a href="template.html" class="nav-link">Template</a></li>
        </ul>
        <div class="nav-actions">
            <button id="lookup-state-backup" class="btn-nav">Backup</button>
            <button id="lookup-state-restore" class="btn-nav">Import / Restore</button>
        </div>
    </nav>

    <div class="container">
        <header class="lookup-header">
            <h1>Lookup</h1>
            <div class="search-controls">
                <input type="text" id="search-input" placeholder="Search keywords...">
                <button id="btn-add-new-entry" class="btn-new-entry">+ New Entry</button>
            </div>
        </header>

        <main class="results-container">
            <section class="column" id="routing-column">
                <h2>Routing</h2>
                <ul id="routing-results" class="result-list"></ul>
            </section>
            <section class="column" id="snippets-column">
                <h2>Snippets</h2>
                <ul id="snippets-results" class="result-list"></ul>
            </section>
        </main>
    </div>

    <div id="toast" class="toast"></div>

    <script>
        /**
         * Lookup Tool (v5.9.1)
         * Manages knowledge base routing and text snippets.
         * * v5.9.1 Changelog (Mode E):
         * - Removed "Quick Add" feature from search.
         * - Removed "Backup Reminder" toast.
         */
        document.addEventListener('DOMContentLoaded', () => {

            // === CONSTANTS ===
            const APP_NAME = 'lookup';
            const DATA_KEY = `${APP_NAME}_data`;
            
            // === DOM ELEMENTS ===
            const searchInput = document.getElementById('search-input');
            const routingResults = document.getElementById('routing-results');
            const snippetsResults = document.getElementById('snippets-results');
            const btnAddNewEntry = document.getElementById('btn-add-new-entry');
            const backupBtn = document.getElementById('lookup-state-backup');
            const restoreBtn = document.getElementById('lookup-state-restore'); 

            // === APPLICATION STATE ===
            let state = {
                routingData: [],
                snippetsData: []
            };
            
            let currentEditState = { id: null, type: null }; 

            // === CONFIGURATION HANDLERS ===
            
            const dataTypesConfig = {
                routing: {
                    listElement: routingResults,
                    dataKey: 'routingData',
                    title: 'Routing',
                    emptyState: 'No routing entries found.',
                    createItemElement: (item, searchTerm, type) => createResultItem(item, searchTerm, type)
                },
                snippets: {
                    listElement: snippetsResults,
                    dataKey: 'snippetsData',
                    title: 'Snippets',
                    emptyState: 'No snippets found.',
                    createItemElement: (item, searchTerm, type) => createSnippetItem(item, searchTerm, type)
                }
            };

            // === INITIALIZATION ===

            // (Mode E Fix 5) Removed checkBackupReminder function

            function loadState() {
                const storedData = localStorage.getItem(DATA_KEY);

                if (storedData) {
                    try {
                        state = JSON.parse(storedData);
                    } catch (e) {
                        console.error("Failed to parse state from localStorage:", e);
                        state = { routingData: [], snippetsData: [] };
                    }
                } else {
                    state = { routingData: [], snippetsData: [] };
                }
                
                if (!state.routingData) state.routingData = [];
                if (!state.snippetsData) state.snippetsData = [];

                // (Mode E Fix 5) Removed call to checkBackupReminder
            }

            function saveState() {
                try {
                    state.routingData.sort((a, b) => a.keyword.localeCompare(b.keyword));
                    state.snippetsData.sort((a, b) => a.keyword.localeCompare(b.keyword));
                    localStorage.setItem(DATA_KEY, JSON.stringify(state));
                } catch (e) {
                    console.error("Failed to save state to localStorage:", e);
                    UIUtils.showModal("Error", "<p>Failed to save data. Storage might be full.</p>", [{label: 'OK'}]);
                }
            }
            
            // === UTILITY FUNCTIONS ===

            function escapeHTML(str) {
                return UIUtils.escapeHTML(str);
            }

            function generateId() {
                return UIUtils.generateId();
            }

            async function copyToClipboard(text, buttonEl = null) {
                const success = await UIUtils.copyToClipboard(text);
                if (success && buttonEl) {
                    if (buttonEl.classList.contains('item-content')) {
                        buttonEl.style.transition = 'background-color 0.1s ease-in-out';
                        buttonEl.style.backgroundColor = 'var(--color-success-bg)';
                        setTimeout(() => { buttonEl.style.backgroundColor = ''; }, 200);
                        UIUtils.showToast("Snippet copied!");
                    } else {
                        const originalText = buttonEl.textContent;
                        buttonEl.textContent = 'Copied!';
                        buttonEl.disabled = true;
                        setTimeout(() => {
                            if (buttonEl) {
                                buttonEl.textContent = originalText;
                                buttonEl.disabled = false;
                            }
                        }, 1200);
                    }
                } else if (!success) {
                    console.warn('Failed to copy.');
                }
            }

            function highlight(text, term) {
                if (!term) return escapeHTML(text);
                const escapedTerm = term.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
                const regex = new RegExp(`(${escapedTerm})`, 'gi');
                return escapeHTML(text).replace(regex, '<mark>$1</mark>');
            }

            // === DOM RENDERING ===

            function renderList(type, searchTerm = '') {
                const config = dataTypesConfig[type];
                const data = state[config.dataKey] || [];
                config.listElement.innerHTML = ''; 

                const term = searchTerm.toLowerCase();
                
                const filteredData = data.filter(item => {
                    if (item.id === currentEditState.id && type === currentEditState.type) {
                        return true; 
                    }
                    return item.keyword.toLowerCase().includes(term);
                });
                
                if (filteredData.length === 0 && (currentEditState.type !== type || currentEditState.id === null)) {
                    // (Mode E Fix 4) Removed "Quick Add" logic
                    if (searchTerm.trim()) {
                        config.listElement.innerHTML = `<li class="empty-state">No results found for "<strong>${escapeHTML(searchTerm)}</strong>"</li>`;
                    } else {
                        config.listElement.innerHTML = `<li class="empty-state">${config.emptyState}</li>`;
                    }
                    return;
                }

                const fragment = document.createDocumentFragment();
                filteredData.forEach(item => {
                    let itemElement;
                    if (item.id === currentEditState.id && type === currentEditState.type) {
                        itemElement = createEditForm(type, item);
                    } else {
                        itemElement = config.createItemElement(item, searchTerm, type);
                    }
                    fragment.appendChild(itemElement);
                });
                config.listElement.appendChild(fragment);
            }

            function renderAll() {
                const searchTerm = searchInput.value;
                renderList('routing', searchTerm);
                renderList('snippets', searchTerm);
            }

            function createResultItem(item, searchTerm, type) {
                const li = document.createElement('li');
                li.className = 'result-item';
                li.dataset.id = item.id;
                li.dataset.type = type;

                const contentDiv = document.createElement('div');
                contentDiv.className = 'item-content';
                contentDiv.textContent = item.content; 

                li.innerHTML = `
                    <div class="item-header">
                        <span class="item-keyword">${highlight(item.keyword, searchTerm)}</span>
                        <div class="item-actions">
                            <button class="btn-copy-keyword">Copy Keyword</button>
                            <button class="btn-edit">Edit</button>
                            <button class="btn-delete">Delete</button>
                        </div>
                    </div>
                `;
                li.appendChild(contentDiv);
                li.innerHTML += `
                    <div class="item-actions">
                        <button class="btn-copy-content">Copy Content</button>
                    </div>
                `;

                li.querySelector('.btn-copy-keyword').addEventListener('click', (e) => copyToClipboard(item.keyword, e.target));
                li.querySelector('.btn-copy-content').addEventListener('click', (e) => copyToClipboard(item.content, e.target));
                li.querySelector('.btn-edit').addEventListener('click', () => handleEdit(item.id, type));
                
                li.querySelector('.btn-delete').addEventListener('click', () => {
                    UIUtils.showModal('Delete Entry', `<p>Are you sure you want to delete "${escapeHTML(item.keyword)}"?</p><p>This cannot be undone.</p>`, [
                        { label: 'Cancel' },
                        { 
                            label: 'Delete', 
                            class: 'button-danger', 
                            callback: () => handleDelete(item.id, type)
                        }
                    ]);
                });

                return li;
            }

            function createSnippetItem(item, searchTerm, type) {
                const li = document.createElement('li');
                li.className = 'snippet-item';
                li.dataset.id = item.id;
                li.dataset.type = type;
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'item-content';
                contentDiv.title = 'Click to copy snippet';
                contentDiv.textContent = item.content; 

                li.innerHTML = `
                    <div class="item-header">
                        <span class="item-keyword">${highlight(item.keyword, searchTerm)}</span>
                        <div class="item-actions">
                            <button class="btn-edit">Edit</button>
                            <button class="btn-delete">Delete</button>
                        </div>
                    </div>
                `;
                li.appendChild(contentDiv); 

                li.querySelector('.item-content').addEventListener('click', (e) => {
                    copyToClipboard(item.content, e.target);
                });
                li.querySelector('.btn-edit').addEventListener('click', () => handleEdit(item.id, type));
                
                li.querySelector('.btn-delete').addEventListener('click', () => {
                    UIUtils.showModal('Delete Entry', `<p>Are you sure you want to delete "${escapeHTML(item.keyword)}"?</p><p>This cannot be undone.</p>`, [
                        { label: 'Cancel' },
                        { 
                            label: 'Delete', 
                            class: 'button-danger', 
                            callback: () => handleDelete(item.id, type)
                        }
                    ]);
                });

                return li;
            }
            
            function createEditForm(type, item) {
                const config = dataTypesConfig[type];

                const li = document.createElement('li');
                li.className = 'edit-form-li'; 

                const form = document.createElement('form');
                form.className = 'edit-form';
                form.dataset.id = item.id;
                form.dataset.type = type;

                const keywordLabel = config.title === 'Routing' ? 'Keyword (e.g., "VPN")' : 'Keyword (e.g., "Greeting")';
                const contentLabel = config.title === 'Routing' ? 'Content (Assignment Group)' : 'Content (Snippet Text)';
                
                const keywordInput = document.createElement('input');
                keywordInput.type = 'text';
                keywordInput.id = `edit-keyword-${item.id}`;
                keywordInput.value = item.keyword;
                keywordInput.placeholder = keywordLabel;

                const contentTextarea = document.createElement('textarea');
                contentTextarea.id = `edit-content-${item.id}`;
                contentTextarea.textContent = item.content;
                contentTextarea.placeholder = contentLabel;

                const keywordLabelEl = document.createElement('label');
                keywordLabelEl.htmlFor = keywordInput.id;
                keywordLabelEl.textContent = 'Keyword';
                
                const contentLabelEl = document.createElement('label');
                contentLabelEl.htmlFor = contentTextarea.id;
                contentLabelEl.textContent = 'Content';

                form.appendChild(keywordLabelEl);
                form.appendChild(keywordInput);
                form.appendChild(contentLabelEl);
                form.appendChild(contentTextarea);

                form.innerHTML += `
                    <div class="edit-form-actions">
                        <button type="button" class="btn-cancel">Cancel</button>
                        <button type="submit" class="btn-save">Save</button>
                    </div>
                `;

                form.addEventListener('submit', (e) => {
                    e.preventDefault();
                    handleSave(form, item.id, type);
                });

                form.querySelector('.btn-cancel').addEventListener('click', () => {
                    if (item.keyword.trim() === '' && item.content.trim() === '') {
                        handleDelete(item.id, type, true); // Pass 'true' to skip confirm
                    }
                    currentEditState = { id: null, type: null };
                    renderAll();
                });
                
                li.appendChild(form);
                return li;
            }

            // === CRUD HANDLERS ===

            function handleAddNewEntry() {
                if (currentEditState.id) {
                    UIUtils.showModal("Save Changes", "<p>Please save or cancel your current edit first.</p>", [{label: 'OK'}]);
                    return;
                }

                UIUtils.showModal("Add New Entry", "<p>What do you want to add?</p>", [
                    { label: 'Cancel' },
                    { label: 'Snippet', callback: () => addNewItem('snippets') },
                    { label: 'Routing', class: 'button-primary', callback: () => addNewItem('routing') }
                ]);
            }
            
            // (Mode E Fix 4) Simplified function
            function addNewItem(type) {
                const config = dataTypesConfig[type];
                
                const newItem = { id: generateId(), keyword: '', content: '' };
                state[config.dataKey].unshift(newItem); 
                
                currentEditState = { id: newItem.id, type: type };
                searchInput.value = ''; 
                renderAll();
                
                const newEl = document.getElementById(`edit-keyword-${newItem.id}`);
                if (newEl) {
                    newEl.focus();
                }
            }


            function handleEdit(id, type) {
                if (currentEditState.id && currentEditState.id !== id) {
                    UIUtils.showModal("Save Changes", "<p>Please save or cancel your current edit first.</p>", [{label: 'OK'}]);
                    return;
                }

                currentEditState = { id: id, type: type };
                renderAll();
                const editInput = document.getElementById(`edit-keyword-${id}`);
                if (editInput) {
                    editInput.focus();
                    editInput.select(); 
                }
            }

            function handleSave(form, id, type) {
                const keywordInput = form.querySelector(`#edit-keyword-${id}`);
                const contentInput = form.querySelector(`#edit-content-${id}`);
                
                const keyword = keywordInput.value.trim();
                const content = contentInput.value.trim();
                const data = state[dataTypesConfig[type].dataKey];
                
                if (keyword === '') {
                    UIUtils.showModal("Invalid Input", "<p>Error: Keyword cannot be blank.</p>", [{label: 'OK'}]);
                    keywordInput.focus();
                    return;
                }
                if (content === '') {
                    UIUtils.showModal("Invalid Input", "<p>Error: Content cannot be blank.</p>", [{label: 'OK'}]);
                    contentInput.focus();
                    return;
                }

                const isDuplicate = data.some(i => 
                    i.id !== id && 
                    i.keyword.toLowerCase() === keyword.toLowerCase()
                );

                if (isDuplicate) {
                    UIUtils.showModal("Duplicate Keyword", `<p>Error: Keyword "${escapeHTML(keyword)}" already exists.</p>`, [{label: 'OK'}]);
                    keywordInput.focus();
                    return;
                }

                const item = data.find(i => i.id === id);
                if (item) {
                    item.keyword = keyword;
                    item.content = content;
                }
                
                saveState();
                
                currentEditState = { id: null, type: null };
                renderAll(); 
            }

            function handleDelete(id, type, skipConfirm = false) {
                if (currentEditState.id === id) {
                    currentEditState = { id: null, type: null };
                }
                
                const config = dataTypesConfig[type];
                const data = state[config.dataKey];
                const index = data.findIndex(i => i.id === id);

                if (index === -1) return;

                data.splice(index, 1);
                
                saveState();
                renderAll(); 
            }
            
            // === DATA IMPORT / EXPORT / BACKUP / RESTORE ===

            function openFilePicker(callback) {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'application/json,.json';
                input.onchange = (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        callback(file);
                    }
                };
                input.click();
            }

            function handleFileLoad(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    UIUtils.showToast("Processing file...");
                    let jsonData;
                    try {
                        jsonData = JSON.parse(e.target.result);
                    } catch (error) {
                        console.error("Failed to parse JSON:", error);
                        UIUtils.showModal("Import Error", "<p>File is not valid JSON.</p>", [{label: 'OK'}]);
                        return;
                    }

                    // --- Logic to determine file type ---
                    
                    // 1. Check for Modern Full Backup (appName: 'lookup', has 'data' key)
                    if (jsonData.appName === APP_NAME && jsonData.data) {
                        UIUtils.showModal("Confirm Restore", "<p>This is a full backup file. Restoring will overwrite all current data.</p>", [
                            { label: 'Cancel' },
                            { 
                                label: 'Restore', 
                                class: 'button-danger',
                                callback: () => {
                                    state = jsonData.data || { routingData: [], snippetsData: [] };
                                    saveState();
                                    currentEditState = { id: null, type: null };
                                    renderAll();
                                    UIUtils.showToast("Restore successful.");
                                }
                            }
                        ]);
                    
                    // 2. Check for Legacy Full Backup (appName: 'assignment_tool', has 'data' key)
                    } else if (jsonData.appName === 'assignment_tool' && jsonData.data) {
                        UIUtils.showModal("Confirm Legacy Restore", "<p>This is a backup from the old 'Assignment Tool'. Restore it?</p>", [
                            { label: 'Cancel' },
                            { 
                                label: 'Restore', 
                                class: 'button-primary', 
                                callback: () => {
                                    state = jsonData.data || { routingData: [], snippetsData: [] };
                                    saveState();
                                    currentEditState = { id: null, type: null };
                                    renderAll();
                                    UIUtils.showToast("Restore successful.");
                                }
                            }
                        ]);

                    // 3. Check for Data-Only Import (has 'routing' or 'snippets' array at root)
                    } else if (Array.isArray(jsonData.routing) || Array.isArray(jsonData.snippets)) {
                        
                        const newRoutingCount = jsonData.routing?.length || 0;
                        const newSnippetsCount = jsonData.snippets?.length || 0;

                        UIUtils.showModal("Confirm Data Import", 
                            `<p>This file contains <strong>${newRoutingCount} routing</strong> entries and <strong>${newSnippetsCount} snippet</strong> entries.</p><p>How do you want to import this data?</p>`, 
                            [
                                { label: 'Cancel' },
                                {
                                    label: 'Merge',
                                    class: 'button-primary',
                                    callback: () => {
                                        state.routingData = (state.routingData || []).concat(jsonData.routing || []);
                                        state.snippetsData = (state.snippetsData || []).concat(jsonData.snippets || []);
                                        saveState();
                                        renderAll();
                                        UIUtils.showToast("Data merged successfully.");
                                    }
                                },
                                {
                                    label: 'Replace All',
                                    class: 'button-danger',
                                    callback: () => {
                                        state.routingData = jsonData.routing || [];
                                        state.snippetsData = jsonData.snippets || [];
                                        saveState();
                                        renderAll();
                                        UIUtils.showToast("Data replaced successfully.");
                                    }
                                }
                            ]
                        );

                    // 4. Unknown file type
                    } else {
                        UIUtils.showModal("Import Error", "<p>Invalid file structure. Not a valid backup or import file.</p>", [{label: 'OK'}]);
                    }

                };
                reader.onerror = () => UIUtils.showModal("Import Error", "<p>Error reading the file.</p>", [{label: 'OK'}]);

                try {
                    reader.readAsText(file);
                } catch (error) {
                    console.error("Failed to read file:", error);
                    UIUtils.showModal("Import Error", `<p>${escapeHTML(error.message)}</p>`, [{label: 'OK'}]);
                }
            }

            function handleBackup() {
                const dataStr = JSON.stringify({
                    appName: APP_NAME,
                    timestamp: new Date().toISOString(),
                    version: '5.9.1', 
                    data: state
                }, null, 2);
                UIUtils.downloadJSON(dataStr, `${APP_NAME}_backup.json`);
                
                // (Mode E Fix 5) Removed tracking of last backup date
                UIUtils.showToast("Backup created.");
            }

            // === EVENT LISTENERS ===
            
            searchInput.addEventListener('input', renderAll);
            btnAddNewEntry.addEventListener('click', handleAddNewEntry);
            
            backupBtn.addEventListener('click', handleBackup);
            restoreBtn.addEventListener('click', () => openFilePicker(handleFileLoad));
            
            // === INITIAL LOAD ===
            loadState();
            renderAll();
        });
    </script>
</body>
</html>


