<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard</title>
    <link rel="stylesheet" href="style.css">
    <style>
        .drag-handle { cursor: grab; color: var(--subtle-text); padding-right: 0.4rem; touch-action: none; }
        .drag-handle:active { cursor: grabbing; }
        .shortcut-item.dragging { opacity: 0.5; background: var(--primary-color); }
        .shortcut-item > .drag-handle { flex-shrink: 0; }
        .shortcut-item > a { flex-grow: 1; }
        .shortcut-item > .delete-btn { flex-shrink: 0; }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="panel">
            <div class="main-content">
                <div class="tabs-container">
                    <a href="dashboard.html" class="tab-link active">Dashboard</a>
                    <a href="tasks.html" class="tab-link">Tasks</a>
                    <a href="assignment_tool.html" class="tab-link">Support Toolkit</a>
                </div>

                <div id="shortcuts-container" class="shortcuts-container"></div>
                <div class="divider"></div>

                <div class="section-header-wrapper">
                    <h3 id="app-section-header" class="section-header">Applications</h3>
                    <div class="actions-menu-wrapper">
                        <button id="actions-btn" class="button-base icon-btn" title="Actions"></button>
                        <div id="actions-menu" class="actions-menu hidden">
                            <a href="#" id="add-shortcut-btn-menu" class="actions-menu-item">+ Shortcut</a>
                            <a href="#" id="add-new-app-btn-menu" class="actions-menu-item">+ App</a>
                            <div class="divider" style="margin: 0.25rem 0;"></div>
                            <a href="#" id="backup-btn-menu" class="actions-menu-item">Backup Dashboard</a>
                            <a href="#" id="restore-btn-menu" class="actions-menu-item">Restore Dashboard</a>
                        </div>
                    </div>
                </div>
                 <div class="form-group" id="app-select-group">
                    <label for="app-search-input">Select Application</label>
                    <div class="search-dropdown-wrapper">
                        <input type="text" id="app-search-input" class="sidebar-input" placeholder="Search applications..." autocomplete="off">
                        <div id="app-dropdown-panel" class="search-dropdown-panel hidden"></div>
                    </div>
                </div>
                <div id="app-empty-state" class="empty-state-message hidden">
                    No applications yet. Click 'Actions' &gt; '+ App' to add one!
                </div>

                <div id="app-details-container" class="hidden">
                    <div id="app-editor-fields">
                        <div class="app-section-box">
                            <div class="form-group hidden" id="edit-app-name-wrapper">
                                <label for="edit-app-name">App Name</label>
                                <input type="text" id="edit-app-name" class="sidebar-input" placeholder="Official Name / Other Name">
                            </div>
                            <div class="form-group">
                                <div class="label-group">
                                    <label for="edit-app-urls">URLs (one per line)</label>
                                    <button id="toggle-details-editor-btn" class="button-base icon-btn" title="Edit Details"></button>
                                </div>
                                <div class="url-links-container" id="url-links-container"></div>
                                <div id="url-editor" class="hidden">
                                   <textarea id="edit-app-urls" class="sidebar-textarea"></textarea>
                                </div>
                            </div>
                        </div>
                        <div class="form-group">
                            <div class="label-group">
                                <label for="edit-app-escalation">Notes</label>
                                <div class="button-group">
                                    <button id="save-changes-btn" class="button-base button-primary save-btn">Save</button>
                                    <button id="delete-app-btn" class="icon-btn delete-btn" title="Delete Application"></button>
                                </div>
                            </div>
                            <textarea id="edit-app-escalation" class="sidebar-textarea"></textarea>
                        </div>
                    </div>
                </div>

                <div class="divider"></div>

                <div class="notepad-wrapper">
                    <div id="notepad-header" class="notepad-header">
                        <select id="note-select" class="sidebar-input"></select>
                        <button id="new-note-btn" class="button-base icon-btn" title="New Note"></button>
                        <button id="rename-note-btn" class="button-base icon-btn" title="Rename Note"></button>
                        <button id="delete-note-btn" class="button-base icon-btn" title="Delete Current Note"></button>
                    </div>
                    <textarea id="notepad-editor" class="notepad-editor" placeholder="Start typing..."></textarea>
                </div>
            </div>
            <div id="toast" class="toast"></div>
            <input type="file" id="restore-file-input" accept=".json" class="hidden">
        </div>
    </div>

    <div id="modal-overlay" class="modal-overlay">
        <div id="modal-content" class="modal-content"></div>
    </div>

    <script>
    {
        const APP_VERSION = '5.3.0'; // Mode F Refinement Release
        const LOCAL_STORAGE_KEY = 'dashboard_state_v5';

        const DEBOUNCE_DELAY = 500;
        const TOAST_DURATION = 3000;
        const UNDO_DURATION = 7000;

        const SVGIcons = {
            plus: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></svg>`,
            pencil: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>`,
            trash: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>`,
            copy: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`,
            menu: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg>`,
        };

        const DOMElements = {
            shortcutsContainer: document.getElementById('shortcuts-container'),
            appSelectGroup: document.getElementById('app-select-group'),
            appSearchInput: document.getElementById('app-search-input'),
            appDropdownPanel: document.getElementById('app-dropdown-panel'),
            appEmptyState: document.getElementById('app-empty-state'),
            modalOverlay: document.getElementById('modal-overlay'),
            modalContent: document.getElementById('modal-content'),
            appDetailsContainer: document.getElementById('app-details-container'),
            editAppNameWrapper: document.getElementById('edit-app-name-wrapper'),
            urlEditor: document.getElementById('url-editor'),
            toggleDetailsEditorBtn: document.getElementById('toggle-details-editor-btn'),
            editAppName: document.getElementById('edit-app-name'),
            editAppUrls: document.getElementById('edit-app-urls'),
            editAppEscalation: document.getElementById('edit-app-escalation'),
            saveChangesBtn: document.getElementById('save-changes-btn'),
            deleteAppBtn: document.getElementById('delete-app-btn'),
            actionsBtn: document.getElementById('actions-btn'),
            actionsMenu: document.getElementById('actions-menu'),
            restoreFileInput: document.getElementById('restore-file-input'),
            notepadHeader: document.getElementById('notepad-header'),
            noteSelect: document.getElementById('note-select'),
            notepadEditor: document.getElementById('notepad-editor'),
            toast: document.getElementById('toast'),
            urlLinksContainer: document.getElementById('url-links-container'),
            newNoteBtn: document.getElementById('new-note-btn'),
            renameNoteBtn: document.getElementById('rename-note-btn'),
            deleteNoteBtn: document.getElementById('delete-note-btn')
        };
        
        const defaultState = {
            apps: [],
            notes: [],
            shortcuts: [],
            version: APP_VERSION
        };

        let state; 
        let shortcutsManager;
        let selectedAppId = null;
        let activeNoteId = null;
        let initialAppData = null;
        let undoTimers = {};

        function loadState() {
            const rawState = localStorage.getItem(LOCAL_STORAGE_KEY);
            if(rawState) {
                try {
                    const parsed = JSON.parse(rawState);
                    if (!parsed || !Array.isArray(parsed.apps) || !Array.isArray(parsed.notes) || !Array.isArray(parsed.shortcuts)) {
                        throw new Error("State data is missing core properties.");
                    }
                    return { ...defaultState, ...parsed };
                } catch(e) { 
                    console.error("Failed to load state, backing up corrupted data.", e);
                    localStorage.setItem(LOCAL_STORAGE_KEY + '_corrupted_' + Date.now(), rawState);
                    return { ...defaultState };
                }
            }
            return { ...defaultState };
        }

        const saveState = () => {
            try {
                state.version = APP_VERSION;
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(state));
            } catch(e) {
                console.error("Failed to save state:", e);
                showToast("Error saving data");
            }
        };

        /**
         * FINAL REVIEW-7: Applies saved theme from localStorage
         */
        function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                document.documentElement.setAttribute('data-theme', savedTheme);
            }
        }

        /**
         * FINAL REVIEW-6: Generates a unique ID with fallback.
         */
        const generateId = () => {
            if (crypto.randomUUID) {
                return crypto.randomUUID();
            }
            // Fallback for older browsers
            return `${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
        };
        
        const debounce = (func, delay) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func(...args), delay);
            };
        };
        const escapeHTML = (str) => {
            if (!str) return '';
            const p = document.createElement('p');
            p.textContent = str;
            return p.innerHTML;
        };
        const validators = {
            url: (value) => {
                if (!value?.trim()) return false;
                let urlToTest = value.trim();
                if (!urlToTest.match(/^(\w+?:\/\/)/)) urlToTest = 'https://' + urlToTest;
                try {
                    const parsedUrl = new URL(urlToTest);
                    return parsedUrl.hostname.includes('.') || parsedUrl.hostname === 'localhost';
                } catch { return false; }
            },
            notEmpty: (value) => value && value.trim().length > 0,
            maxLength: (value, max) => value.length <= max,
        };
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => showToast('Copied to clipboard')).catch(err => console.error('Failed to copy:', err));
        }

        const showModal = (title, contentHtml, actions) => {
            DOMElements.modalContent.innerHTML = `<h3>${escapeHTML(title)}</h3><div>${contentHtml}</div><div class="modal-actions"></div>`;
            const actionsContainer = DOMElements.modalContent.querySelector('.modal-actions');
            actions.forEach(action => {
                const btn = document.createElement('button');
                btn.className = `button-base ${action.class || ''}`;
                btn.textContent = action.label;
                btn.onclick = () => { if (!action.callback || action.callback() !== false) hideModal(); };
                actionsContainer.appendChild(btn);
            });
            DOMElements.modalOverlay.style.display = 'flex';
        };
        const hideModal = () => { DOMElements.modalOverlay.style.display = 'none'; };
        
        const showToast = (message, undoKey = null, undoCallback = null) => {
            const toast = DOMElements.toast;
            if (undoKey && undoTimers[undoKey]) clearTimeout(undoTimers[undoKey]);

            toast.innerHTML = `<span>${escapeHTML(message)}</span>`;
            if (undoKey && undoCallback) {
                const undoButton = document.createElement('button');
                undoButton.textContent = 'Undo';
                undoButton.onclick = () => {
                    undoCallback();
                    toast.classList.remove('show');
                    clearTimeout(undoTimers[undoKey]);
                    delete undoTimers[undoKey];
                };
                undoButton.addEventListener('click', undoCallback, { once: true });
                toast.appendChild(undoButton);
                undoTimers[undoKey] = setTimeout(() => {
                    toast.classList.remove('show');
                    saveState();
                    delete undoTimers[undoKey];
                }, UNDO_DURATION);
            } else {
                 setTimeout(() => toast.classList.remove('show'), TOAST_DURATION);
            }
            toast.classList.add('show');
        };

        const createShortcutsManager = (state, dom, services) => {
            const container = dom.shortcutsContainer;
            let draggedItemId = null;

            const addDragAndDropListeners = (element) => {
                element.addEventListener('dragstart', (e) => {
                    draggedItemId = element.dataset.id;
                    setTimeout(() => element.classList.add('dragging'), 0);
                });
                element.addEventListener('dragend', () => {
                    element.classList.remove('dragging');
                    draggedItemId = null;
                });
            };

            const createShortcutElement = (shortcut) => {
                const div = document.createElement('div');
                div.className = 'shortcut-item';
                div.dataset.id = shortcut.id;
                div.draggable = true;
                // Applied icon-btn class
                div.innerHTML = `
                    <span class="drag-handle" title="Drag to reorder">â˜°</span>
                    <a href="${shortcut.url}" target="_blank" rel="noopener noreferrer">${escapeHTML(shortcut.name)}</a>
                    <button class="icon-btn delete-btn" data-id="${shortcut.id}" title="Delete">${services.SVGIcons.trash}</button>
                `;
                addDragAndDropListeners(div);
                return div;
            };

            const render = () => {
                container.innerHTML = '';
                if (state.shortcuts.length === 0) {
                    container.innerHTML = `<span style="color: var(--subtle-text); font-size: 0.8rem; grid-column: 1 / -1;">No shortcuts. Add from 'Actions'.</span>`;
                } else {
                    state.shortcuts.forEach(shortcut => {
                        const element = createShortcutElement(shortcut);
                        container.appendChild(element);
                    });
                }
            };

            const remove = (shortcutId) => {
                const itemIndex = state.shortcuts.findIndex(s => s.id === shortcutId);
                if (itemIndex === -1) return;

                const itemCopy = { ...state.shortcuts[itemIndex] };
                const name = itemCopy.name;
                state.shortcuts.splice(itemIndex, 1);

                const undo = () => {
                    state.shortcuts.splice(itemIndex, 0, itemCopy);
                    services.saveState();
                    render();
                    services.showToast(`${name} restored.`);
                };

                services.showToast(`${name} deleted`, `shortcut-${shortcutId}`, undo);
                render();
            };

            const add = () => {
                services.showModal('Add Shortcut',
                    `<input type="text" id="shortcut-name" placeholder="Name" class="sidebar-input">
                     <input type="text" id="shortcut-url" placeholder="URL" class="sidebar-input">`,
                    [{ label: 'Cancel' }, {
                        label: 'Add', class: 'button-primary', callback: () => {
                            const nameInput = document.getElementById('shortcut-name');
                            const urlInput = document.getElementById('shortcut-url');
                            const name = nameInput.value;
                            const url = urlInput.value;
                            if (services.validators.notEmpty(name) && services.validators.maxLength(name, 50) && services.validators.url(url)) {
                                state.shortcuts.push({ id: generateId(), name, url });
                                services.saveState();
                                render();
                            } else {
                                services.showToast('Invalid name or URL');
                                return false;
                            }
                        }
                    }]
                );
            };

            const init = () => {
                container.addEventListener('click', (e) => {
                    const deleteBtn = e.target.closest('.delete-btn');
                    if (deleteBtn && deleteBtn.dataset.id) {
                        remove(deleteBtn.dataset.id);
                    }
                });

                container.addEventListener('dragover', (e) => e.preventDefault());
                
                container.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (!draggedItemId) return;

                    try {
                        const targetElement = e.target.closest('.shortcut-item, .shortcuts-container');
                        if (!targetElement) return;

                        const shortcuts = state.shortcuts;
                        const draggedIndex = shortcuts.findIndex(s => s.id === draggedItemId);
                        if (draggedIndex === -1) return;

                        const [draggedItem] = shortcuts.splice(draggedIndex, 1);
                        
                        if (targetElement.classList.contains('shortcut-item') && targetElement.dataset.id !== draggedItemId) {
                            const targetIndex = shortcuts.findIndex(s => s.id === targetElement.dataset.id);
                            shortcuts.splice(targetIndex, 0, draggedItem);
                        } else {
                            shortcuts.push(draggedItem);
                        }
                        services.saveState();
                        render();
                    } catch (error) {
                        console.error('Drag-and-drop error:', error);
                        showToast('Error reordering shortcuts');
                        render(); // Reset display
                    } finally {
                        draggedItemId = null;
                    }
                });
            };

            return { init, render, add };
        };

        const renderAppDropdown = (filterTerm = '') => {
            const panel = DOMElements.appDropdownPanel;
            panel.innerHTML = '';
            const sortedApps = (state?.apps || []).sort((a,b) => a.name.localeCompare(b.name));
            // MODE F-3 FIX: Cache lowercase filter term
            const term = filterTerm.toLowerCase();
            const filteredApps = term 
                ? sortedApps.filter(app => app.name.toLowerCase().includes(term)) 
                : sortedApps;
            
            if (filteredApps.length > 0) {
                // MODE F-6 FIX: Use DocumentFragment
                const fragment = document.createDocumentFragment();
                filteredApps.forEach(app => {
                    const item = document.createElement('div');
                    item.className = 'search-dropdown-item';
                    item.textContent = app.name;
                    item.dataset.id = app.id;
                    fragment.appendChild(item);
                });
                panel.appendChild(fragment);
            } else {
                panel.innerHTML = `<div class="search-dropdown-item" style="color: var(--subtle-text);">No results</div>`;
            }
        };

        const renderAppData = () => {
            if (state.apps.length === 0) {
                DOMElements.appSelectGroup.classList.add('hidden');
                DOMElements.appEmptyState.classList.remove('hidden');
            } else {
                DOMElements.appSelectGroup.classList.remove('hidden');
                DOMElements.appEmptyState.classList.add('hidden');
            }
        };

        const renderNotesData = () => { 
            const noteSelect = DOMElements.noteSelect;
            noteSelect.innerHTML = '';
            state.notes.forEach(note => noteSelect.add(new Option(note.title, note.id)));
            
            if (activeNoteId && state.notes.some(n => n.id == activeNoteId)) {
                 noteSelect.value = activeNoteId;
            } else if (state.notes.length > 0) {
                activeNoteId = state.notes[0].id;
                noteSelect.value = activeNoteId;
            } else {
                activeNoteId = null;
            }
            
            const activeNote = state.notes.find(n => n.id == activeNoteId);
            if (activeNote) {
                DOMElements.notepadEditor.value = activeNote.content;
                DOMElements.notepadEditor.disabled = false;
            } else {
                DOMElements.notepadEditor.value = '';
                DOMElements.notepadEditor.disabled = true;
            }
            DOMElements.deleteNoteBtn.disabled = state.notes.length === 0;
            DOMElements.renameNoteBtn.disabled = state.notes.length === 0;
        };

        // MODE F-1 FIX: Use DocumentFragment
        const renderUrlLinks = (urlString) => { 
            const container = DOMElements.urlLinksContainer;
            if(!urlString) {
                container.innerHTML = '';
                return;
            }
            
            const fragment = document.createDocumentFragment();
            urlString.split('\n').filter(url => url.trim()).forEach(url => {
                const div = document.createElement('div');
                div.className = 'url-link-item';
                div.innerHTML = `<a href="${url}" target="_blank" rel="noopener noreferrer">${escapeHTML(url)}</a>
                <button class="icon-btn copy-btn" data-url="${url}" title="Copy URL">${SVGIcons.copy}</button>`;
                fragment.appendChild(div);
            });
            container.innerHTML = '';
            container.appendChild(fragment);
        };
        const renderAll = () => { 
            if (shortcutsManager) shortcutsManager.render();
            renderAppData();
            renderNotesData();
        };

        const checkFormDirty = () => {
            if (!initialAppData) return false;
            const nameDirty = DOMElements.editAppName.value.trim() !== initialAppData.name;
            const urlsDirty = DOMElements.editAppUrls.value.trim() !== initialAppData.urls;
            const escalationDirty = DOMElements.editAppEscalation.value.trim() !== initialAppData.escalation;
            return nameDirty || urlsDirty || escalationDirty;
        };
        const updateSaveButtonState = () => {
            if(DOMElements.saveChangesBtn) DOMElements.saveChangesBtn.disabled = !checkFormDirty();
        };

        const displayAppDetails = (appId) => {
            selectedAppId = appId;
            DOMElements.appDetailsContainer.classList.toggle('hidden', !appId);

            if (appId) {
                const app = state.apps.find(a => a.id === appId);
                if (app) {
                    initialAppData = {...app};
                    DOMElements.appSearchInput.value = app.name;
                    DOMElements.editAppName.value = app.name;
                    DOMElements.editAppUrls.value = app.urls;
                    DOMElements.editAppEscalation.value = app.escalation;
                    renderUrlLinks(app.urls);
                    DOMElements.editAppNameWrapper.classList.add('hidden');
                    DOMElements.urlEditor.classList.add('hidden');
                    DOMElements.toggleDetailsEditorBtn.innerHTML = SVGIcons.pencil;
                }
            } else {
                initialAppData = null;
                DOMElements.appSearchInput.value = '';
                DOMElements.appSearchInput.placeholder = 'Search applications...';
                renderUrlLinks('');
            }
            updateSaveButtonState();
        };
        
        const createNewAppForm = () => {
            displayAppDetails(null);
            DOMElements.appDetailsContainer.classList.remove('hidden');
            DOMElements.editAppNameWrapper.classList.remove('hidden');
            DOMElements.urlEditor.classList.remove('hidden');
            DOMElements.toggleDetailsEditorBtn.innerHTML = SVGIcons.pencil;
            DOMElements.editAppName.value = '';
            DOMElements.editAppUrls.value = '';
            DOMElements.editAppEscalation.value = '';
            initialAppData = {id: null, name: '', urls: '', escalation: ''};
            updateSaveButtonState();
        };

        [DOMElements.editAppName, DOMElements.editAppUrls, DOMElements.editAppEscalation].forEach(el => {
            el.addEventListener('input', updateSaveButtonState);
        });
        DOMElements.editAppUrls.addEventListener('input', () => renderUrlLinks(DOMElements.editAppUrls.value));

        DOMElements.appSearchInput.addEventListener('focus', () => {
            renderAppDropdown(DOMElements.appSearchInput.value);
            DOMElements.appDropdownPanel.classList.remove('hidden');
        });
        DOMElements.appSearchInput.addEventListener('input', () => {
            renderAppDropdown(DOMElements.appSearchInput.value);
        });

        // FINAL REVIEW-4: Add keyboard navigation
        DOMElements.appSearchInput.addEventListener('keydown', (e) => {
            const panel = DOMElements.appDropdownPanel;
            if (panel.classList.contains('hidden')) return;
            
            const items = Array.from(panel.querySelectorAll('.search-dropdown-item[data-id]'));
            if (items.length === 0) return;

            const selected = panel.querySelector('.search-dropdown-item.selected');
            let index = selected ? items.indexOf(selected) : -1;
            
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                index = Math.min(index + 1, items.length - 1);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                index = Math.max(index - 1, 0);
            } else if (e.key === 'Enter' && selected) {
                e.preventDefault();
                selected.click();
                return;
            } else if (e.key === 'Escape') {
                panel.classList.add('hidden');
                return;
            } else {
                return;
            }
            
            items.forEach(item => item.classList.remove('selected'));
            if (items[index]) {
                items[index].classList.add('selected');
                // Ensure the selected item is visible
                items[index].scrollIntoView({ block: 'nearest' });
            }
        });

        DOMElements.appDropdownPanel.addEventListener('click', (e) => {
            const target = e.target.closest('.search-dropdown-item');
            if (target && target.dataset.id) {
                const targetId = target.dataset.id;
                
                if (checkFormDirty() && targetId !== selectedAppId) {
                    showModal('Unsaved Changes', '<p>You have unsaved changes. Are you sure you want to discard them?</p>', [
                        { label: 'Cancel', callback: () => false },
                        {
                            label: 'Discard', class: 'button-danger',
                            callback: () => {
                                displayAppDetails(targetId);
                                DOMElements.appDropdownPanel.classList.add('hidden');
                            }
                        }
                    ]);
                } else {
                    displayAppDetails(targetId);
                    DOMElements.appDropdownPanel.classList.add('hidden');
                }
            }
        });
        
        DOMElements.appDropdownPanel.addEventListener('mouseover', (e) => {
            const target = e.target.closest('.search-dropdown-item');
            if (target) {
                Array.from(DOMElements.appDropdownPanel.children).forEach(child => child.classList.remove('selected'));
                target.classList.add('selected');
            }
        });
        DOMElements.appDropdownPanel.addEventListener('mouseout', (e) => {
            const target = e.target.closest('.search-dropdown-item');
            if (target) {
                target.classList.remove('selected');
            }
        });


        DOMElements.toggleDetailsEditorBtn.addEventListener('click', (e) => {
            const isHidden = DOMElements.urlEditor.classList.toggle('hidden');
            DOMElements.editAppNameWrapper.classList.toggle('hidden', isHidden);
            e.currentTarget.innerHTML = SVGIcons.pencil;
        });
        
        DOMElements.saveChangesBtn.addEventListener('click', () => {
            const name = DOMElements.editAppName.value.trim();
            const urls = DOMElements.editAppUrls.value.trim();
            const escalation = DOMElements.editAppEscalation.value.trim();

            if (!validators.notEmpty(name) || !validators.maxLength(name, 100)) return showToast('App name must be 1-100 characters');
            if (!validators.notEmpty(urls) && !validators.notEmpty(escalation)) return showToast('App must have at least one URL or a note.');
            
            if (state.apps.some(a => a.name.toLowerCase() === name.toLowerCase() && a.id != selectedAppId)) {
                return showToast('An app with this name already exists. Please use a unique name.');
            }

            const appIndex = state.apps.findIndex(a => a.id == selectedAppId);
            let savedAppId = selectedAppId;
            if (appIndex > -1) {
                state.apps[appIndex] = { ...state.apps[appIndex], name, urls, escalation };
            } else {
                const newApp = { id: generateId(), name, urls, escalation };
                state.apps.push(newApp);
                savedAppId = newApp.id;
            }
            saveState();
            renderAppData();
            displayAppDetails(savedAppId);
            showToast('Changes saved');
        });

        const handleDelete = (list, itemId, itemName, onUndoCallback) => {
            const itemIndex = list.findIndex(item => item.id === itemId);
            if (itemIndex === -1) return;

            const itemCopy = { ...list[itemIndex] };
            list.splice(itemIndex, 1);

            const undo = () => {
                list.splice(itemIndex, 0, itemCopy);
                if (onUndoCallback) onUndoCallback();
                saveState();
                renderAll();
                showToast(`${escapeHTML(itemName)} restored.`);
            };

            showToast(`${escapeHTML(itemName)} deleted`, `delete-${itemId}`, undo);
        };

        DOMElements.deleteAppBtn.addEventListener('click', () => {
             if(selectedAppId) {
                const app = state.apps.find(a => a.id == selectedAppId);
                if (app) {
                    showModal('Delete Application', `<p>Are you sure you want to delete "${escapeHTML(app.name)}"?</p>`, [
                        {label: 'Cancel'},
                        {
                            label: 'Delete', 
                            class: 'button-danger', 
                            callback: () => {
                                handleDelete(state.apps, selectedAppId, app.name, () => {
                                    displayAppDetails(app.id); 
                                });
                                displayAppDetails(null); 
                                renderAll();
                            } 
                        }
                    ]);
                }
             }
        });
        
        DOMElements.urlLinksContainer.addEventListener('click', (e) => {
            const target = e.target.closest('.copy-btn');
            if(target) copyToClipboard(target.dataset.url);
        });

        DOMElements.actionsBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            DOMElements.actionsMenu.classList.toggle('hidden');
        });

        document.addEventListener('click', (e) => {
            if (!e.target.closest('.actions-menu-wrapper')) DOMElements.actionsMenu.classList.add('hidden');
            if (!e.target.closest('.search-dropdown-wrapper')) DOMElements.appDropdownPanel.classList.add('hidden');
        });
        
        DOMElements.actionsMenu.addEventListener('click', (e) => {
            const menuItem = e.target.closest('.actions-menu-item');
            if(!menuItem) return;
            e.preventDefault();
            const id = menuItem.id;
            if (id === 'add-shortcut-btn-menu') shortcutsManager.add();
            if (id === 'add-new-app-btn-menu') {
                if (checkFormDirty()) {
                    showModal('Unsaved Changes', '<p>Discard unsaved changes?</p>', [
                        { label: 'Cancel' },
                        { label: 'Discard', class: 'button-danger', callback: () => createNewAppForm() }
                    ]);
                } else createNewAppForm();
            }
            if (id === 'backup-btn-menu') {
                 const dataStr = JSON.stringify(state, null, 2);
                 const dataBlob = new Blob([dataStr], {type: 'application/json'});
                 const link = document.createElement('a');
                 link.href = URL.createObjectURL(dataBlob);
                 link.download = `dashboard-backup-${new Date().toISOString().split('T')[0]}.json`;
                 link.click();
                 URL.revokeObjectURL(link.href);
            }
            if(id === 'restore-btn-menu') DOMElements.restoreFileInput.click();
        });

        /**
         * FINAL REVIEW-9: Validate state structure during restore
         */
        function validateState(restored) {
            if (!restored || typeof restored !== 'object') return false;
            if (!Array.isArray(restored.apps)) return false;
            if (!Array.isArray(restored.notes)) return false;
            if (!Array.isArray(restored.shortcuts)) return false;
            
            // Validate each app has required fields
            if (!restored.apps.every(a => a && a.id && typeof a.name === 'string' && typeof a.urls === 'string' && typeof a.escalation === 'string')) return false;
            if (!restored.notes.every(n => n && n.id && typeof n.title === 'string' && typeof n.content === 'string')) return false;
            if (!restored.shortcuts.every(s => s && s.id && typeof s.name === 'string' && typeof s.url === 'string')) return false;
            
            return true;
        }
        
        DOMElements.restoreFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const restored = JSON.parse(event.target.result);
                    // FINAL REVIEW-9: Add validation call
                    if(!validateState(restored)) {
                        throw new Error('Invalid dashboard backup file structure.');
                    }
                    showModal('Confirm Restore', `<p>Overwrite dashboard data? This cannot be undone.</p>`, [
                        {label: 'Cancel'},
                        {label: 'Restore', class: 'button-danger', callback: () => {
                            state = { ...defaultState, ...restored };
                            saveState();
                            displayAppDetails(null);
                            renderAll();
                            showToast('Dashboard data restored.');
                        }}
                    ]);
                } catch(err) {
                    console.error("Restore failed:", err);
                    showToast('Restore failed: ' + err.message);
                }
            };
            reader.onerror = () => showToast('Error reading the backup file.');
            reader.readAsText(file);
            e.target.value = '';
        });

        DOMElements.notepadHeader.addEventListener('click', (e) => {
             const button = e.target.closest('button');
             if(!button) return;
             const id = button.id;
             if(id === 'new-note-btn') {
                 const newId = generateId();
                 state.notes.unshift({id: newId, title: `Note ${state.notes.length + 1}`, content:''});
                 activeNoteId = newId;
                 saveState();
                 renderNotesData();
             } else if (id === 'rename-note-btn' && activeNoteId) {
                const note = state.notes.find(n => n.id == activeNoteId);
                if(note) {
                    showModal('Rename Note', `<input id="rename-note-input" class="sidebar-input" value="${escapeHTML(note.title)}">`, [
                        {label: 'Cancel'},
                        {label: 'Save', class: 'button-primary', callback: () => {
                            const newTitle = document.getElementById('rename-note-input').value;
                            if(validators.notEmpty(newTitle) && validators.maxLength(newTitle, 50)) {
                                note.title = newTitle;
                                saveState();
                                renderNotesData();
                            } else {
                                showToast('Invalid title');
                                return false;
                            }
                        }}
                    ]);
                }
             } else if (id === 'delete-note-btn' && activeNoteId) {
                 const note = state.notes.find(n => n.id == activeNoteId);
                 if (!note) return;

                 handleDelete(state.notes, activeNoteId, note.title, () => {
                    activeNoteId = note.id; 
                 });
                 
                 if (state.notes.length === 0) {
                    const newNote = { id: generateId(), title: 'My Scratchpad', content: '' };
                    state.notes.push(newNote);
                    activeNoteId = newNote.id;
                 } else {
                    // MODE C-3 FIX: Simplified logic, removed redundant ?. and || null
                    activeNoteId = state.notes[0].id;
                 }
                 renderAll();
             }
        });

        DOMElements.noteSelect.addEventListener('change', (e) => {
            activeNoteId = e.target.value;
            renderNotesData();
        });

        DOMElements.notepadEditor.addEventListener('input', debounce(() => {
            if (!activeNoteId) return;
            const note = state.notes.find(n => n.id == activeNoteId);
            if(note) {
                note.content = DOMElements.notepadEditor.value;
                saveState();
            }
        }, DEBOUNCE_DELAY));
        
        DOMElements.modalOverlay.addEventListener('click', (e) => { if(e.target === DOMElements.modalOverlay) hideModal() });
        document.addEventListener('keydown', (e) => { if(e.key === 'Escape') hideModal() });

        const init = () => {
            // FINAL REVIEW-7: Apply theme first
            initTheme();
            try {
                state = loadState();
            } catch (e) {
                state = { ...defaultState };
                showModal('Data Corruption Detected', '<p>Saved data could not be read. A backup has been saved and the application has been reset.</p>', [{ label: 'OK' }]);
            }

            const services = { showModal, showToast, validators, SVGIcons, saveState };
            shortcutsManager = createShortCutsManager(state, DOMElements, services);
            shortcutsManager.init();

            DOMElements.actionsBtn.innerHTML = SVGIcons.menu;
            DOMElements.toggleDetailsEditorBtn.innerHTML = SVGIcons.pencil;
            DOMElements.deleteAppBtn.innerHTML = SVGIcons.trash;
            DOMElements.newNoteBtn.innerHTML = SVGIcons.plus;
            DOMElements.renameNoteBtn.innerHTML = SVGIcons.pencil;
            DOMElements.deleteNoteBtn.innerHTML = SVGIcons.trash;

            if (state.notes.length === 0) {
                state.notes.push({ id: generateId(), title: 'My Scratchpad', content: '' });
                saveState();
            }
            renderAll();
        };

        init();
    }
    </script>
</body>
</html>


