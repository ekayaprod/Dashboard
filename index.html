<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="navbar-container"></div>

    <div class="app-container">
        <div class="panel">
            <div class="main-content">
                <div id="shortcuts-container" class="shortcuts-container"></div>
                <div class="divider"></div>

                <div class="section-header-wrapper">
                    <h3 id="app-section-header" class="section-header">Applications</h3>
                    <div class="actions-menu-wrapper button-group">
                        <button id="add-shortcut-btn-menu" class="button-base icon-btn" title="Add Shortcut"></button>
                        <button id="add-new-app-btn-menu" class="button-base icon-btn" title="Add App"></button>
                        <!-- FIX: Replaced Backup/Restore with CSV/Settings -->
                        <button id="btn-export-csv" class="button-base">Export (CSV)</button>
                        <button id="btn-import-csv" class="button-base">Import (CSV)</button>
                        <button id="btn-settings" class="icon-btn" title="Settings"></button>
                    </div>
                </div>
                 <div class="form-group" id="app-select-group">
                    <label for="app-select">Select Application</label>
                    <select id="app-select" class="sidebar-input"></select>
                </div>
                <div id="app-empty-state" class="empty-state-message hidden">
                    No applications yet. Click '+ App' to add one!
                </div>

                <div id="app-details-container" class="hidden">
                    <div id="app-editor-fields" class="app-section-box">
                        <div class="form-group hidden" id="edit-app-name-wrapper">
                            <label for="edit-app-name">App Name</label>
                            <input type="text" id="edit-app-name" class="sidebar-input" placeholder="Official Name / Other Name">
                        </div>
                        <div class="form-group">
                            <label for="edit-app-urls">URLs (one per line)</label>
                            <textarea id="edit-app-urls" class="sidebar-textarea"></textarea>
                        </div>
                        <div class="form-group">
                            <div class="label-group">
                                <label for="edit-app-escalation">App Notes / Escalation</label>
                                <div class="button-group">
                                    <button id="save-changes-btn" class="button-base button-primary save-btn">Save</button>
                                    <button id="delete-app-btn" class="icon-btn delete-btn" title="Delete Application"></button>
                                </div>
                            </div>
                            <textarea id="edit-app-escalation" class="sidebar-textarea"></textarea>
                        </div>
                    </div>
                </div>

                <div class="divider"></div>

                <div class="notepad-wrapper">
                    <div id="notepad-header" class="notepad-header">
                        <select id="note-select" class="sidebar-input"></select>
                        <button id="new-note-btn" class="button-base icon-btn" title="New Note"></button>
                        <button id="rename-note-btn" class="button-base icon-btn" title="Rename Note"></button>
                        <button id="delete-note-btn" class="button-base icon-btn" title="Delete Current Note"></button>
                    </div>
                    <textarea id="notepad-editor" class="notepad-editor" placeholder="Start typing..."></textarea>
                </div>
            </div>
        </div>
    </div>

    <div id="modal-overlay" class="modal-overlay">
        <div id="modal-content" class="modal-content"></div>
    </div>
    <div id="toast" class="toast"></div>

    <script src="js/app-core.js"></script>
    <script src="js/app-ui.js"></script>
    <script src="js/app-data.js"></script>
    <script>
    // FIX: Use non-destructive error banner
    (() => {
        const dependencies = ['SafeUI', 'UIPatterns', 'ListRenderer', 'SearchHelper', 'BackupRestore', 'DataValidator', 'DataConverter', 'CsvManager'];
        const missing = dependencies.filter(dep => typeof window[dep] === 'undefined');
        if (missing.length > 0) {
            const errorTitle = "Application Failed to Load";
            const errorMessage = `One or more required JavaScript files (e.g., app-core.js, app-ui.js) failed to load, or core modules are missing. Missing: ${missing.join(', ')}`;
            
            console.error(errorMessage);
            
            // Try to use the AppLifecycle banner if it loaded, otherwise fallback
            if (typeof window.AppLifecycle !== 'undefined' && typeof window.AppLifecycle._showErrorBanner === 'function') {
                window.AppLifecycle._showErrorBanner(errorTitle, errorMessage);
            } else {
                // Fallback banner
                const banner = document.createElement('div');
                banner.id = 'app-startup-error-inline';
                banner.style.cssText = `position:sticky;top:0;left:0;width:100%;padding:1rem;background-color:#fef2f2;color:#dc2626;border-bottom:2px solid #fecaca;font-family:sans-serif;font-size:1rem;font-weight:600;z-index:10000;box-sizing:border-box;`;
                banner.innerHTML = `<strong>${errorTitle}</strong><p style="margin:0.25rem 0 0 0;font-weight:normal;">${errorMessage}</p>`;
                
                if (document.body) {
                    document.body.prepend(banner);
                } else {
                    document.addEventListener('DOMContentLoaded', () => document.body.prepend(banner));
                }
            }
            // Throw an error to stop execution
            throw new Error(`Critical dependencies missing: ${missing.join(', ')}`);
        }
    })();

    AppLifecycle.run(async () => {
        const APP_VERSION = '6.2.0'; // CSV Import/Export
        const LOCAL_STORAGE_KEY = 'dashboard_state_v5';
        const APP_CONFIG = {
            NAME: 'dashboard',
            APP_CSV_HEADERS: ['id', 'name', 'urls', 'escalation']
        };
        const DEBOUNCE_DELAY = 500;
    
        const defaultState = {
            apps: [],
            notes: [],
            shortcuts: [],
            version: APP_VERSION
        };
    
        const ctx = await AppLifecycle.initPage({
            storageKey: LOCAL_STORAGE_KEY,
            defaultState,
            version: APP_VERSION,
            requiredElements: [
                'shortcuts-container', 'app-select-group', 'app-select',
                'app-empty-state', 'modal-overlay', 'modal-content', 'app-details-container',
                'app-editor-fields', 'edit-app-name-wrapper', 'edit-app-name', 'edit-app-urls',
                'edit-app-escalation', 'save-changes-btn', 'delete-app-btn', 'add-shortcut-btn-menu',
                'add-new-app-btn-menu', 
                // FIX: Add new button IDs
                'btn-export-csv', 'btn-import-csv', 'btn-settings',
                'notepad-header',
                'note-select', 'notepad-editor', 'toast', 'new-note-btn', 'rename-note-btn', 'delete-note-btn',
                'navbar-container'
            ]
        });
    
        if (!ctx) return;
    
        const { elements: DOMElements, state, saveState } = ctx;

        let shortcutsManager;
        let selectedAppId = null;
        let activeNoteId = null;
        let initialAppData = null;

        const getCollection = (type) => state[type];
        const hasItems = (type) => getCollection(type).length > 0;

        const confirmDelete = (type, itemName, onConfirm) => {
            const labels = {apps: 'Application', notes: 'Note', shortcuts: 'Shortcut'};
            const itemTypeLabel = labels[type] || 'Item';
            UIPatterns.confirmDelete(itemTypeLabel, itemName, onConfirm);
        };

        const createShortcutsManager = (state, dom, services) => {
            const container = dom.shortcutsContainer;
            let draggedItemId = null;

            const addDragAndDropListeners = (element) => {
                element.addEventListener('dragstart', (e) => {
                    draggedItemId = element.dataset.id;
                    setTimeout(() => element.classList.add('dragging'), 0);
                });
                element.addEventListener('dragend', () => {
                    element.classList.remove('dragging');
                    draggedItemId = null;
                });
            };

            const createShortcutElement = (shortcut) => {
                const div = document.createElement('div');
                div.className = 'shortcut-item';
                div.dataset.id = shortcut.id;
                div.draggable = true;
                div.innerHTML = `
                    <span class="drag-handle" title="Drag to reorder">â˜°</span>
                    <a href="${shortcut.url}" target="_blank" rel="noopener noreferrer">${services.escapeHTML(shortcut.name)}</a>
                    <button class="icon-btn delete-btn" data-id="${shortcut.id}" title="Delete">${services.SVGIcons.trash}</button>
                `;
                addDragAndDropListeners(div);
                return div;
            };

            const render = () => {
                container.innerHTML = '';
                if (!hasItems('shortcuts')) {
                    container.innerHTML = `<span style="color: var(--subtle-text); font-size: 0.8rem; grid-column: 1 / -1;">No shortcuts. Add from 'Actions'.</span>`;
                } else {
                    const fragment = document.createDocumentFragment();
                    getCollection('shortcuts').forEach(shortcut => {
                        const element = createShortcutElement(shortcut);
                        fragment.appendChild(element);
                    });
                    container.appendChild(fragment);
                }
            };

            const remove = (shortcutId) => {
                const itemIndex = getCollection('shortcuts').findIndex(s => s.id === shortcutId);
                if (itemIndex === -1) return;
                const itemCopy = { ...getCollection('shortcuts')[itemIndex] };

                services.confirmDelete('shortcuts', itemCopy.name, () => {
                    getCollection('shortcuts').splice(itemIndex, 1);
                    services.saveState();
                    render();
                });
            };

            const add = () => {
                services.showModal('Add Shortcut',
                    `<input type="text" id="shortcut-name" placeholder="Name" class="sidebar-input">
                     <input type="text" id="shortcut-url" placeholder="URL" class="sidebar-input">`,
                    [{ label: 'Cancel' }, {
                        label: 'Add', class: 'button-primary', callback: () => {
                            const nameInput = document.getElementById('shortcut-name');
                            const urlInput = document.getElementById('shortcut-url');
                            const name = nameInput.value;
                            const url = urlInput.value;
                            if (services.validators.notEmpty(name) && services.validators.maxLength(name, 50) && services.validators.url(url)) {
                                getCollection('shortcuts').push({ id: services.generateId(), name, url });
                                services.saveState();
                                render();
                            } else {
                                services.showToast('Invalid name or URL');
                                return false;
                            }
                        }
                    }]
                );
            };

            const init = () => {
                container.addEventListener('click', (e) => {
                    const deleteBtn = e.target.closest('.delete-btn');
                    if (deleteBtn && deleteBtn.dataset.id) {
                        remove(deleteBtn.dataset.id);
                    }
                });

                container.addEventListener('dragover', (e) => e.preventDefault());

                container.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (!draggedItemId) return;

                    const targetElement = e.target.closest('.shortcut-item, .shortcuts-container');
                    if (!targetElement) return;

                    const shortcuts = getCollection('shortcuts');
                    const draggedIndex = shortcuts.findIndex(s => s.id === draggedItemId);
                    if (draggedIndex === -1) return;

                    const [draggedItem] = shortcuts.splice(draggedIndex, 1);

                    if (targetElement.classList.contains('shortcut-item') && targetElement.dataset.id !== draggedItemId) {
                        const targetIndex = shortcuts.findIndex(s => s.id === targetElement.dataset.id);
                        if (targetIndex !== -1) {
                            shortcuts.splice(targetIndex, 0, draggedItem);
                        } else {
                            shortcuts.push(draggedItem);
                        }
                    } else if (targetElement.classList.contains('shortcut-item') && targetElement.dataset.id === draggedItemId) {
                        shortcuts.splice(draggedIndex, 0, draggedItem);
                    } else {
                        shortcuts.push(draggedItem);
                    }
                    services.saveState();
                    render();
                    draggedItemId = null;
                });
            };

            return { init, render, add };
        };

        const renderAppDropdown = () => {
            const appSelect = DOMElements.appSelect;
            const selectedValue = appSelect.value;
            appSelect.innerHTML = '<option value="">-- Select an App --</option>';

            const sortedApps = [...getCollection('apps')].sort((a,b) => a.name.localeCompare(b.name));
            
            sortedApps.forEach(app => {
                appSelect.add(new Option(app.name, app.id));
            });
            
            // FIX: Issue #13 - Only restore selection if the app still exists
            if (selectedValue && sortedApps.some(app => app.id === selectedValue)) {
                appSelect.value = selectedValue;
            } else {
                appSelect.value = '';
                if (selectedAppId && !sortedApps.some(app => app.id === selectedAppId)) {
                    selectedAppId = null; // Clear stale reference
                }
            }
        };

        const renderAppData = () => {
            if (!hasItems('apps')) {
                DOMElements.appSelectGroup.classList.add('hidden');
                DOMElements.appEmptyState.classList.remove('hidden');
            } else {
                DOMElements.appSelectGroup.classList.remove('hidden');
                DOMElements.appEmptyState.classList.add('hidden');
                renderAppDropdown();
            }
        };

        const renderNotesData = () => {
            const noteSelect = DOMElements.noteSelect;
            noteSelect.innerHTML = '';

            const fragment = document.createDocumentFragment();
            getCollection('notes').forEach(note => fragment.appendChild(new Option(note.title, note.id)));
            noteSelect.appendChild(fragment);

            if (activeNoteId && getCollection('notes').some(n => n.id == activeNoteId)) {
                 noteSelect.value = activeNoteId;
            } else if (hasItems('notes')) {
                activeNoteId = getCollection('notes')[0].id;
                noteSelect.value = activeNoteId;
            } else {
                activeNoteId = null;
            }

            const activeNote = getCollection('notes').find(n => n.id == activeNoteId);
            if (activeNote) {
                DOMElements.notepadEditor.value = activeNote.content;
                DOMElements.notepadEditor.disabled = false;
            } else {
                DOMElements.notepadEditor.value = '';
                DOMElements.notepadEditor.disabled = true;
            }
            DOMHelpers.triggerTextareaResize(DOMElements.notepadEditor);
            DOMElements.deleteNoteBtn.disabled = !hasItems('notes');
            DOMElements.renameNoteBtn.disabled = !hasItems('notes');
        };

        const renderAll = () => {
            if (shortcutsManager) shortcutsManager.render();
            renderAppData();
            renderNotesData();
        };
        
        const checkFormDirty = () => {
            if (!initialAppData) return false;
            if (initialAppData.id === null) {
                return DOMElements.editAppName.value.trim() !== '' ||
                       DOMElements.editAppUrls.value.trim() !== '' ||
                       DOMElements.editAppEscalation.value.trim() !== '';
            }
            return DOMElements.editAppName.value.trim() !== initialAppData.name ||
                   DOMElements.editAppUrls.value.trim() !== initialAppData.urls ||
                   DOMElements.editAppEscalation.value.trim() !== initialAppData.escalation;
        };
        
        const updateSaveButtonState = () => {
            if(DOMElements.saveChangesBtn) DOMElements.saveChangesBtn.disabled = !checkFormDirty();
        };

        const displayAppDetails = (appId) => {
            selectedAppId = appId;
            const isVisible = !!appId;

            // --- FIX FOR STALE DATA ---
            // Always clear and reset fields first.
            DOMElements.editAppName.value = '';
            DOMElements.editAppUrls.value = '';
            DOMElements.editAppEscalation.value = '';
            DOMElements.editAppNameWrapper.classList.add('hidden'); // Hide app name field by default

            DOMElements.appDetailsContainer.classList.toggle('hidden', !isVisible);

            if (isVisible) {
                const app = getCollection('apps').find(a => a.id === appId);
                if (!app) {
                    console.error(`Failed to find app with ID: ${appId}`);
                    DOMElements.appDetailsContainer.classList.add('hidden'); // Ensure it's hidden if app lookup fails
                    selectedAppId = null;
                    initialAppData = null;
                    return; // Exit
                }
                
                initialAppData = {...app};
                DOMElements.editAppName.value = app.name; // Keep name field populated for save logic
                
                // FIX: Normalize line breaks and set values
                DOMElements.editAppUrls.value = (app.urls || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                DOMElements.editAppEscalation.value = (app.escalation || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n');

            } else {
                initialAppData = null;
            }

            // FIX: Defer resize with setTimeout(0) to allow browser to render
            setTimeout(() => {
                DOMHelpers.triggerTextareaResize(DOMElements.editAppUrls);
                DOMHelpers.triggerTextareaResize(DOMElements.editAppEscalation);
            }, 0);
            
            updateSaveButtonState();
        };

        const createNewAppForm = () => {
            DOMElements.appSelect.value = '';
            displayAppDetails(null);
            DOMElements.appDetailsContainer.classList.remove('hidden');
            DOMElements.editAppNameWrapper.classList.remove('hidden');
            DOMElements.editAppName.focus();
            initialAppData = {id: null, name: '', urls: '', escalation: ''};
            updateSaveButtonState();
        };

        // ====================================================================
        // CSV IMPORT / EXPORT
        // ====================================================================

        /**
         * Validates a row from the CSV file
         */
        const validateCsvRow = (row, index) => {
            const entry = {
                id: row.id || SafeUI.generateId(), // Keep old ID or make new one
                name: (row.name || '').trim(),
                urls: (row.urls || '').trim(),
                escalation: (row.escalation || '').trim()
            };

            if (!SafeUI.validators.notEmpty(entry.name)) {
                return { error: `Row ${index + 2}: 'name' is required.` };
            }
            return { entry };
        };
        
        /**
         * Confirms and processes the CSV import data
         */
        const confirmCsvImport = (validatedData, importErrors) => {
            const newEntries = validatedData.newEntries;
            const updatedEntries = validatedData.updatedEntries;

            const errorList = importErrors.slice(0, 10).map(e => `<li>${SafeUI.escapeHTML(e)}</li>`).join('');
            const moreErrors = importErrors.length > 10 ? `<li>... and ${importErrors.length - 10} more errors.</li>` : '';

            let summaryHtml = `<p>Found <strong>${newEntries.length} new</strong> applications and <strong>${updatedEntries.length} applications to overwrite</strong>.</p>`;
            
            if (importErrors.length > 0) {
                summaryHtml += `<p>The following ${importErrors.length} rows had errors and were skipped:</p>
                                <ul style="font-size: 0.8rem; max-height: 150px; overflow-y: auto; text-align: left;">
                                    ${errorList}${moreErrors}
                                </ul>`;
            }

            summaryHtml += `<p>Do you want to apply these changes? This cannot be undone.</p>`;

            SafeUI.showModal("Confirm CSV Import", summaryHtml, [
                { label: 'Cancel' },
                { 
                    label: 'Import and Overwrite', 
                    class: 'button-primary', 
                    callback: () => {
                        let importedCount = 0;
                        
                        // Add new entries
                        newEntries.forEach(entry => {
                            state.apps.push(entry);
                            importedCount++;
                        });

                        // Update existing entries
                        updatedEntries.forEach(entry => {
                            const existingIndex = state.apps.findIndex(app => app.id === entry.id);
                            if (existingIndex > -1) {
                                state.apps[existingIndex] = entry;
                                importedCount++;
                            }
                        });

                        saveState();
                        renderAll();
                        SafeUI.showToast(`Imported ${importedCount} applications.`);
                    }
                }
            ]);
        };

        // ====================================================================
        // SETTINGS MODAL
        // ====================================================================
        
        const showSettingsModal = () => {
            const modalContent = `
                <div class="form-group">
                    <label>Advanced Data Management</label>
                    <p class="form-help">Use these tools for disaster recovery. "Import/Export" (on the main page) is for managing application data via CSV.</p>
                    <div class="button-group">
                        <button id="modal-backup-btn" class="button-base">Backup ALL (JSON)</button>
                        <button id="modal-restore-btn" class="button-base">Restore ALL (JSON)</button>
                    </div>
                </div>
            `;
            
            SafeUI.showModal("Settings", modalContent, [{ label: 'Close' }]);

            // Attach listeners to modal buttons
            BackupRestore.setupBackupRestoreHandlers({
                state: state,
                appName: APP_CONFIG.NAME,
                backupBtn: document.getElementById('modal-backup-btn'),
                restoreBtn: document.getElementById('modal-restore-btn'),
                itemValidators: {
                    apps: APP_CONFIG.APP_CSV_HEADERS,
                    notes: ['id', 'title', 'content'],
                    shortcuts: ['id', 'name', 'url']
                },
                restoreConfirmMessage: 'This will overwrite all dashboard data (Apps, Notes, and Shortcuts). This cannot be undone.',
                onRestoreCallback: (dataToRestore) => {
                    state.apps = dataToRestore.apps || [];
                    state.notes = dataToRestore.notes || [];
                    state.shortcuts = dataToRestore.shortcuts || [];
                    
                    if (!hasItems('notes')) {
                        getCollection('notes').push({ id: SafeUI.generateId(), title: 'My Scratchpad', content: '' });
                    }
                    
                    saveState();
                    DOMElements.appSelect.value = '';
                    displayAppDetails(null);
                    renderAll();
                    SafeUI.showToast('Dashboard data restored.');
                }
            });
        };


        // ====================================================================
        // EVENT LISTENERS
        // ====================================================================

        const attachEventListeners = () => {
            [DOMElements.editAppName, DOMElements.editAppUrls, DOMElements.editAppEscalation].forEach(el => {
                el.addEventListener('input', updateSaveButtonState);
            });

            DOMElements.appSelect.addEventListener('change', () => {
                const selectedId = DOMElements.appSelect.value;
                
                const switchApp = () => {
                    displayAppDetails(selectedId);
                };
                
                if (checkFormDirty()) {
                    UIPatterns.confirmUnsavedChanges(switchApp);
                } else {
                    switchApp();
                }
            });

            DOMElements.saveChangesBtn.addEventListener('click', () => {
                const name = DOMElements.editAppName.value.trim();
                const urls = DOMElements.editAppUrls.value.trim();
                const escalation = DOMElements.editAppEscalation.value.trim();

                if (!SafeUI.validators.notEmpty(name) || !SafeUI.validators.maxLength(name, 100)) {
                    return SafeUI.showValidationError('Invalid Name', 'App name must be 1-100 characters.', 'edit-app-name');
                }
                if (!SafeUI.validators.notEmpty(urls) && !SafeUI.validators.notEmpty(escalation)) {
                    return SafeUI.showValidationError('Invalid Data', 'App must have at least one URL or a note.');
                }
                
                const isNewApp = initialAppData && initialAppData.id === null;
                const appIndex = isNewApp ? -1 : getCollection('apps').findIndex(a => a.id == selectedAppId);

                if (DataValidator.hasDuplicate(getCollection('apps'), 'name', name, isNewApp ? null : selectedAppId)) {
                    return SafeUI.showValidationError('Duplicate Name', 'An app with this name already exists.', 'edit-app-name');
                }
                
                let savedAppId = selectedAppId;
                if (appIndex > -1) {
                    getCollection('apps')[appIndex] = { ...getCollection('apps')[appIndex], name, urls, escalation };
                } else {
                    const newApp = { id: SafeUI.generateId(), name, urls, escalation };
                    getCollection('apps').push(newApp);
                    savedAppId = newApp.id;
                }
                saveState();
                renderAppData();
                DOMElements.appSelect.value = savedAppId;
                displayAppDetails(savedAppId);
                SafeUI.showToast('Changes saved');
            });

            DOMElements.deleteAppBtn.addEventListener('click', () => {
                 if(selectedAppId) {
                    const appIndex = getCollection('apps').findIndex(item => item.id === selectedAppId);
                    if (appIndex > -1) {
                        const appName = getCollection('apps')[appIndex].name;
                        confirmDelete('apps', appName, () => {
                            getCollection('apps').splice(appIndex, 1);
                            saveState();
                            DOMElements.appSelect.value = '';
                            displayAppDetails(null);
                            renderAll();
                        });
                    }
                 }
            });

            DOMElements.addShortcutBtnMenu.addEventListener('click', (e) => {
                e.preventDefault();
                shortcutsManager.add();
            });

            DOMElements.addNewAppBtnMenu.addEventListener('click', (e) => {
                e.preventDefault();
                if (checkFormDirty()) {
                    UIPatterns.confirmUnsavedChanges(createNewAppForm);
                } else {
                    createNewAppForm();
                }
            });

            // CSV Listeners (using consolidated helper)
            CsvManager.setupExport({
                exportBtn: DOMElements.btnExportCsv,
                dataGetter: () => state.apps,
                headers: APP_CONFIG.APP_CSV_HEADERS,
                filename: 'dashboard-apps-export.csv'
            });

            CsvManager.setupImport({
                importBtn: DOMElements.btnImportCsv,
                headers: APP_CONFIG.APP_CSV_HEADERS,
                onValidate: validateCsvRow,
                onConfirm: (data, errors) => {
                    // Remap data to find new vs. updated based on 'name'
                    const newEntries = [];
                    const updatedEntries = [];
                    
                    data.forEach(item => {
                        const existingApp = state.apps.find(app => app.name.toLowerCase() === item.name.toLowerCase());
                        if (existingApp) {
                            // This is an update. Merge data.
                            updatedEntries.push({
                                ...existingApp, // Keep existing ID
                                name: item.name, // Update name (for casing)
                                urls: item.urls,
                                escalation: item.escalation
                            });
                        } else {
                            // This is a new entry
                            newEntries.push(item);
                        }
                    });
                    
                    confirmCsvImport({ newEntries, updatedEntries }, errors);
                }
            });

            // Settings Modal Listener
            DOMElements.btnSettings.addEventListener('click', showSettingsModal);

            // Notepad Listeners
            DOMElements.notepadHeader.addEventListener('click', (e) => {
                 const button = e.target.closest('button');
                 if(!button) return;
                 const id = button.id;
                 if(id === 'new-note-btn') {
                     const newId = SafeUI.generateId();
                     getCollection('notes').unshift({id: newId, title: `Note ${getCollection('notes').length + 1}`, content:''});
                     activeNoteId = newId;
                     saveState();
                     renderNotesData();
                     DOMElements.notepadEditor.focus();
                 } else if (id === 'rename-note-btn' && activeNoteId) {
                    const note = getCollection('notes').find(n => n.id == activeNoteId);
                    if(note) {
                        SafeUI.showModal('Rename Note', `<input id="rename-note-input" class="sidebar-input" value="${SafeUI.escapeHTML(note.title)}">`, [
                            {label: 'Cancel'},
                            {label: 'Save', class: 'button-primary', callback: () => {
                                const newTitle = document.getElementById('rename-note-input').value;
                                if(SafeUI.validators.notEmpty(newTitle) && SafeUI.validators.maxLength(newTitle, 50)) {
                                    if (DataValidator.hasDuplicate(getCollection('notes'), 'title', newTitle, activeNoteId)) {
                                        SafeUI.showValidationError('Duplicate Title', 'A note with this title already exists.', 'rename-note-input');
                                        return false; 
                                    }
                                    note.title = newTitle;
                                    saveState();
                                    renderNotesData();
                                } else {
                                    SafeUI.showValidationError('Invalid Title', 'Title must be 1-50 characters.', 'rename-note-input');
                                    return false; 
                                }
                            }}
                        ]);
                        setTimeout(() => document.getElementById('rename-note-input')?.select(), 100);
                    }
                 } else if (id === 'delete-note-btn' && activeNoteId) {
                     const noteIndex = getCollection('notes').findIndex(item => item.id === activeNoteId);
                     if (noteIndex === -1) return;
                     
                     const noteName = getCollection('notes')[noteIndex].title;

                     confirmDelete('notes', noteName, () => {
                        getCollection('notes').splice(noteIndex, 1);

                        if (!hasItems('notes')) {
                            const newNote = { id: SafeUI.generateId(), title: 'My Scratchpad', content: '' };
                            getCollection('notes').push(newNote);
                            activeNoteId = newNote.id;
                        } else {
                            activeNoteId = getCollection('notes')[0].id;
                        }
                        saveState();
                        renderAll();
                        
                        // FIX: Issue #14 - Ensure textarea resizes after content is set
                        setTimeout(() => {
                            DOMHelpers.triggerTextareaResize(DOMElements.notepadEditor);
                        }, 0);
                     });
                 }
            });

            DOMElements.noteSelect.addEventListener('change', (e) => {
                activeNoteId = e.target.value;
                renderNotesData();
            });

            DOMElements.notepadEditor.addEventListener('input', SafeUI.debounce(() => {
                if (!activeNoteId) return;
                const note = getCollection('notes').find(n => n.id == activeNoteId);
                if(note) {
                    note.content = DOMElements.notepadEditor.value;
                    saveState();
                    SafeUI.showToast('Note saved');
                }
            }, DEBOUNCE_DELAY));

            DOMElements.notepadEditor.addEventListener('blur', () => {
                if (!activeNoteId) return;
                const note = getCollection('notes').find(n => n.id == activeNoteId);
                if(note && note.content !== DOMElements.notepadEditor.value) {
                    note.content = DOMElements.notepadEditor.value;
                    saveState();
                    SafeUI.showToast('Note saved');
                }
            });
        };


        const init = () => {
            // --- FIX FOR AUTO-GROW ---
            if (DOMElements.editAppEscalation) {
                DOMHelpers.setupTextareaAutoResize(DOMElements.editAppEscalation);
            }
            if (DOMElements.editAppUrls) {
                DOMHelpers.setupTextareaAutoResize(DOMElements.editAppUrls, 150);
            }
            if (DOMElements.notepadEditor) {
                DOMHelpers.setupTextareaAutoResize(DOMElements.notepadEditor);
            }

            const services = {
                showModal: SafeUI.showModal,
                confirmDelete: confirmDelete,
                validators: SafeUI.validators,
                SVGIcons: SafeUI.SVGIcons,
                saveState: saveState, 
                escapeHTML: SafeUI.escapeHTML,
                generateId: SafeUI.generateId,
                showToast: SafeUI.showToast
            };
            shortcutsManager = createShortcutsManager(state, DOMElements, services);
            shortcutsManager.init();

            DOMElements.addShortcutBtnMenu.innerHTML = SafeUI.SVGIcons.plus;
            DOMElements.addNewAppBtnMenu.innerHTML = SafeUI.SVGIcons.plus;
            DOMElements.deleteAppBtn.innerHTML = SafeUI.SVGIcons.trash;
            DOMElements.newNoteBtn.innerHTML = SafeUI.SVGIcons.plus;
            DOMElements.renameNoteBtn.innerHTML = SafeUI.SVGIcons.pencil;
            DOMElements.deleteNoteBtn.innerHTML = SafeUI.SVGIcons.trash;
            // FIX: Add icon for settings button
            DOMElements.btnSettings.innerHTML = SafeUI.SVGIcons.settings;

            if (!hasItems('notes')) {
                getCollection('notes').push({ id: SafeUI.generateId(), title: 'My Scratchpad', content: '' });
                saveState();
            }
            renderAll();
            
            // Attach all event listeners
            attachEventListeners();
            
            SafeUI.loadNavbar("navbar-container");
        };

        init();
        
    });
    </script>
</body>
</html>

