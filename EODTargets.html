<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EOD Targets</title>
    <!-- Using the shared style.css from the root directory -->
    <link rel="stylesheet" href="style.css">
</head>
<body class="eod-targets-page">

    <div class="app-container">
        <div class="panel">
            <div class="main-content">

                <div class="time-bar">
                    <span id="currentTime">Loading clock...</span>
                </div>

                <!-- Section 1: Inputs -->
                <div class="calc-section">
                    <div class="calc-section-header">
                        <h2>1. Your Inputs</h2>
                    </div>
                    <div class="calc-section-content">
                        <!-- FIX: Use new input-grid-3 for a single row -->
                        <div class="input-grid-3">
                            <div>
                                <label for="shiftStart" class="sidebar-label">Shift Start</label>
                                <select id="shiftStart" class="sidebar-select"></select>
                            </div>
                            <div>
                                <label for="shiftEnd" class="sidebar-label">Shift End</label>
                                <select id="shiftEnd" class="sidebar-select"></select>
                            </div>
                            <div>
                                <!-- FIX: Shortened label -->
                                <label for="breakTime" class="sidebar-label">Break (min)</label>
                                <select id="breakTime" class="sidebar-select">
                                    <option value="0">0</option>
                                    <option value="30">30</option>
                                    <option value="45">45</option>
                                    <option value="60" selected>60</option>
                                    <option value="90">90</option>
                                    <option value="120">120</option>
                                </select>
                            </div>
                        </div>

                        <!-- Divider -->
                        <div class="section-divider"></div>

                        <!-- FIX: Use input-grid-2, but with shortened labels -->
                        <div class="input-grid-2">
                            <div>
                                <!-- FIX: Shortened label -->
                                <label for="currentCallTime" class="sidebar-label">Call Time (HH:MM)</label>
                                <input type="text" id="currentCallTime" class="sidebar-input" placeholder="e.g., 01:30" value="00:00">
                            </div>
                            <div>
                                <!-- FIX: Shortened label -->
                                <label for="currentTickets" class="sidebar-label">Tickets Closed</label>
                                <input type="number" id="currentTickets" class="sidebar-input" value="0">
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Section 2: Projections -->
                <div class="calc-section">
                    <div class="calc-section-header">
                        <h2>2. Your Projections</h2>
                    </div>
                    <div class="calc-section-content">
                        <!-- FIX: Use new stat-grid-2x2 for 2x2 layout -->
                        <div class="stat-grid-2x2">
                            <div class="stat-box">
                                <span class="stat-label">Total Prod. Time</span>
                                <span id="totalProductiveTime" class="stat-value">00:00</span>
                            </div>
                            <div class="stat-box">
                                <span class="stat-label">Time Passed</span>
                                <span id="timePassed" class="stat-value">00:00</span>
                            </div>
                            <div class="stat-box">
                                <span class="stat-label">Time Left</span>
                                <span id="timeRemaining" class="stat-value">00:00</span>
                            </div>
                            <div class="stat-box">
                                <span class="stat-label">Avg. Ticket Time</span>
                                <span id="currentAvgTicketTime" class="stat-value">00:00</span>
                            </div>
                        </div>

                        <!-- Divider -->
                        <div class="section-divider"></div>

                        <!-- FIX: Use new target-grid-3 for 3-column card layout -->
                        <div id="targets-content" class="target-grid-3">
                            <!-- Targets will be injected here by JS -->
                            <!-- Skeletons are now built by JS -->
                        </div>
                        <div id="target-info" class="info-box">
                            Targets are based on your projected call pace.
                        </div>
                    </div>
                </div>
        
            </div>
        </div>
    </div>

    <script>
        // --- Configurable Settings ---
        
        // Leeway is 1/7th of the (Shift Time - Break Time)
        // This is based on the original data: (8h shift - 1h break = 7h) / 1h leeway = 1/7th
        const LEEWAY_RATIO = 1 / 7; 

        // Efficiency Targets (in Avg. Minutes per Ticket)
        const workEfficiencyTargets = {
            'Outstanding': { name: 'Outstanding', target: 7.0 },
            'Excellent': { name: 'Excellent', target: 9.3 },
            'Satisfactory': { name: 'Satisfactory', target: 10.8 },
            'Needs Improvement': { name: 'Needs Improvement', target: 11.8 }
        };

        // --- DOM Element Cache ---
        // FIX F-1: Cache DOM elements on startup
        const DOMElements = {};

        // --- Time Helpers ---
        function parseHHMMToMinutes(timeStr) {
            const parts = timeStr.split(':').map(Number);
            if (parts.length === 2) {
                return (parts[0] || 0) * 60 + (parts[1] || 0);
            }
            if (parts.length === 1 && timeStr.length > 0) {
                return (parts[0] || 0) * 60;
            }
            return 0;
        }

        function formatMinutesToHHMM(totalMinutes) {
            if (isNaN(totalMinutes) || totalMinutes < 0) return '00:00';
            const hours = Math.floor(totalMinutes / 60);
            const minutes = Math.floor(totalMinutes % 60);
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }

        function formatMinutesToShortTime(totalMinutes) {
            if (isNaN(totalMinutes) || totalMinutes < 0) return '0m';
            if (totalMinutes < 1) return '< 1m';
            
            const hours = Math.floor(totalMinutes / 60);
            const minutes = Math.floor(totalMinutes % 60);
            
            let parts = [];
            if (hours > 0) parts.push(`${hours}h`);
            if (minutes > 0) parts.push(`${minutes}m`);
            
            return parts.length > 0 ? parts.join(' ') : '0m';
        }

        function formatMinutesToMMSS(totalMinutes) {
            if (isNaN(totalMinutes) || !isFinite(totalMinutes) || totalMinutes <= 0) return '0:00';
            const minutes = Math.floor(totalMinutes);
            const seconds = Math.floor((totalMinutes * 60) % 60);
            return `${minutes}:${String(seconds).padStart(2, '0')}`;
        }

        function populateTimeOptions(selectId, startHour, endHour, defaultVal) {
            const select = document.getElementById(selectId);
            for (let h = startHour; h <= endHour; h++) {
                for (let m = 0; m < 60; m += 15) { // 15-min increments
                    const hourStr = String(h).padStart(2, '0');
                    const minStr = String(m).padStart(2, '0');
                    const timeStr = `${hourStr}:${minStr}`;
                    
                    const option = document.createElement('option');
                    option.value = timeStr;
                    option.text = timeStr;
                    if (timeStr === defaultVal) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                }
            }
        }

        // --- Schedule & Time Calculation ---
        // FIX F-3: Broke out schedule calculation from main loop
        function getScheduleInfo() {
            const now = new Date();
            const startTimeStr = DOMElements.shiftStart.value;
            const endTimeStr = DOMElements.shiftEnd.value;
            const breakTimeMinutes = parseInt(DOMElements.breakTime.value, 10);

            const startTime = new Date(now);
            startTime.setHours(parseInt(startTimeStr.split(':')[0], 10), parseInt(startTimeStr.split(':')[1], 10), 0, 0);
            
            const endTime = new Date(now);
            endTime.setHours(parseInt(endTimeStr.split(':')[0], 10), parseInt(endTimeStr.split(':')[1], 10), 0, 0);

            const totalShiftMinutes = (endTime - startTime) / 60000;
            const postBreakMinutes = totalShiftMinutes - breakTimeMinutes;
            const leewayTimeMinutes = postBreakMinutes * LEEWAY_RATIO;
            const totalProductiveMinutes = postBreakMinutes - leewayTimeMinutes;
            
            let workdayMinutesPassed = (now - startTime) / 60000;
            if (workdayMinutesPassed < 0) workdayMinutesPassed = 0; // Before shift
            if (workdayMinutesPassed > totalShiftMinutes) workdayMinutesPassed = totalShiftMinutes; // After shift

            let productiveMinutesPassed = 0;
            if (totalShiftMinutes > 0) {
                 productiveMinutesPassed = (workdayMinutesPassed / totalShiftMinutes) * totalProductiveMinutes;
            }
            if (productiveMinutesPassed > totalProductiveMinutes) {
                productiveMinutesPassed = totalProductiveMinutes;
            }
            
            const productiveMinutesRemaining = totalProductiveMinutes - productiveMinutesPassed;

            return {
                now,
                totalProductiveMinutes,
                productiveMinutesPassed,
                productiveMinutesRemaining,
                totalShiftMinutes
            };
        }

        // --- UI Update Functions ---
        
        // FIX F-2: Create dedicated render function to avoid innerHTML reset
        function renderTarget(targetName, data) {
            // Guard clause: If elements aren't built, exit.
            if (!DOMElements.targets || !DOMElements.targets[targetName]) return;
            
            const card = DOMElements.targets[targetName].card;
            const valueEl = DOMElements.targets[targetName].value;
            const descEl = DOMElements.targets[targetName].desc;

            card.className = `target-card ${data.boxClass}`;
            valueEl.innerText = data.value;
            descEl.innerHTML = data.desc; // Use innerHTML here for <strong> tag
        }

        function calculateAndRender() {
            // --- 1. Get Schedule & Productive Time ---
            const { 
                now,
                totalProductiveMinutes, 
                productiveMinutesPassed, 
                productiveMinutesRemaining,
                totalShiftMinutes
            } = getScheduleInfo();
            
            DOMElements.totalProductiveTime.innerText = formatMinutesToHHMM(totalProductiveMinutes);

            // --- Handle Invalid Schedule ---
            if (totalProductiveMinutes <= 0) {
                DOMElements.timePassed.innerText = 'N/A';
                DOMElements.timeRemaining.innerText = 'N/A';
                DOMElements.currentAvgTicketTime.innerText = 'N/A';
                DOMElements.targetsContent.innerHTML = `<div class="info-box info-box-danger" style="grid-column: span 3;">Invalid Schedule. Total Productive Time must be > 0.</div>`;
                DOMElements.targetInfo.style.display = 'none';
                return; // Stop calculation
            }
            
            // Restore info box if it was hidden
            DOMElements.targetInfo.style.display = 'block';


            // --- 2. Calculate Current Time Stats ---
            DOMElements.timePassed.innerText = formatMinutesToHHMM(productiveMinutesPassed);
            DOMElements.timeRemaining.innerText = formatMinutesToHHMM(productiveMinutesRemaining);
            DOMElements.currentTime.innerText = `Current Time: ${now.toLocaleTimeString()}`;

            // --- 3. Get User Inputs (SO FAR) ---
            const currentCallTimeSoFar = parseHHMMToMinutes(DOMElements.currentCallTime.value);
            const currentTicketsSoFar = parseInt(DOMElements.currentTickets.value) || 0;

            // --- 4. Calculate Current "So Far" Stats ---
            let currentWorkTimeSoFar = productiveMinutesPassed - currentCallTimeSoFar;
            if (currentWorkTimeSoFar < 0) currentWorkTimeSoFar = 0;

            let currentAvgTicketTime = 0;
            let avgTicketTimeText = '0:00'; // Default
            
            if (productiveMinutesPassed <= 0 && currentTicketsSoFar > 0) {
                avgTicketTimeText = 'N/A'; // Show N/A if before shift
            } else if (currentTicketsSoFar > 0 && currentWorkTimeSoFar > 0) {
                currentAvgTicketTime = currentWorkTimeSoFar / currentTicketsSoFar;
                avgTicketTimeText = formatMinutesToMMSS(currentAvgTicketTime);
            }
            DOMElements.currentAvgTicketTime.innerText = avgTicketTimeText;

            // --- 5. Project EOD Totals ---
            let callPace = 0;
            if (productiveMinutesPassed > 0) {
                callPace = currentCallTimeSoFar / productiveMinutesPassed;
            } else if (currentCallTimeSoFar > 0) {
                callPace = 1.0;
            }
            
            const projectedTotalCallTimeEOD = totalProductiveMinutes * callPace;
            const projectedTotalWorkTimeEOD = totalProductiveMinutes - projectedTotalCallTimeEOD;

            // --- 6. Calculate and Render Targets ---
            const targets = ['Outstanding', 'Excellent', 'Satisfactory'];
            
            // FIX F-2: Check if targetsContent is in a valid state
            if (!DOMElements.targets || !DOMElements.targets.Outstanding) {
                // If schedule was invalid, targetsContent was replaced. Rebuild it.
                buildTargetSkeletons();
            }

            for (const targetName of targets) {
                const targetInfo = workEfficiencyTargets[targetName];
                
                let targetTotalTickets = 0;
                if (projectedTotalWorkTimeEOD > 0) {
                     targetTotalTickets = Math.ceil(projectedTotalWorkTimeEOD / targetInfo.target);
                }
                
                const ticketsNeeded = targetTotalTickets - currentTicketsSoFar;
                const workTimeNeeded = ticketsNeeded > 0 ? ticketsNeeded * targetInfo.target : 0;

                let renderData = {};

                if (projectedTotalWorkTimeEOD <= 0) {
                    renderData = {
                        boxClass: 'target-danger',
                        value: '0',
                        desc: 'High call pace. No time for tickets.'
                    };
                }
                else if (ticketsNeeded <= 0) {
                    renderData = {
                        boxClass: 'target-good',
                        value: 'MET',
                        desc: `Goal: <strong>${targetTotalTickets}</strong> tickets`
                    };
                } 
                else if (productiveMinutesRemaining <= 0 && ticketsNeeded > 0) {
                     renderData = {
                        boxClass: 'target-danger',
                        value: `${ticketsNeeded}`,
                        desc: 'Short. Day is over.'
                    };
                }
                else {
                     renderData = {
                        boxClass: 'target-warn',
                        value: `${ticketsNeeded}`,
                        desc: `(<strong>~${formatMinutesToShortTime(workTimeNeeded)}</strong> work)`
                    };
                }
                renderTarget(targetName, renderData);
            }
        }
        
        // FIX F-2: Function to build the target card skeletons once
        function buildTargetSkeletons() {
            DOMElements.targetsContent.innerHTML = ''; // Clear
            const targets = ['Outstanding', 'Excellent', 'Satisfactory'];
            DOMElements.targets = {};

            for (const targetName of targets) {
                const card = document.createElement('div');
                card.id = `target${targetName}`;
                card.className = 'target-card';
                
                const label = document.createElement('span');
                label.className = 'target-label';
                label.innerText = workEfficiencyTargets[targetName].name;
                
                const value = document.createElement('span');
                value.className = 'target-value';
                value.innerText = '...';

                const desc = document.createElement('span');
                desc.className = 'target-desc';
                desc.innerText = '...';

                card.appendChild(label);
                card.appendChild(value);
                card.appendChild(desc);
                DOMElements.targetsContent.appendChild(card);

                // Cache the elements for updating
                DOMElements.targets[targetName] = { card, value, desc };
            }
        }

        // --- Init ---
        document.addEventListener('DOMContentLoaded', () => {
            // FIX F-1: Populate DOM element cache
            DOMElements.shiftStart = document.getElementById('shiftStart');
            DOMElements.shiftEnd = document.getElementById('shiftEnd');
            DOMElements.breakTime = document.getElementById('breakTime');
            DOMElements.currentCallTime = document.getElementById('currentCallTime');
            DOMElements.currentTickets = document.getElementById('currentTickets');
            DOMElements.currentTime = document.getElementById('currentTime');
            DOMElements.totalProductiveTime = document.getElementById('totalProductiveTime');
            DOMElements.timePassed = document.getElementById('timePassed');
            // FIX: Corrected typo in element ID
            DOMElements.timeRemaining = document.getElementById('timeRemaining'); 
            DOMElements.currentAvgTicketTime = document.getElementById('currentAvgTicketTime');
            DOMElements.targetsContent = document.getElementById('targets-content');
            DOMElements.targetInfo = document.getElementById('target-info');
            
            // Populate time dropdowns
            populateTimeOptions('shiftStart', 6, 12, '08:00'); // 6 AM to 12 PM, default 8:00
            populateTimeOptions('shiftEnd', 12, 18, '16:00'); // 12 PM to 6 PM, default 16:00

            // FIX F-2: Build the target skeletons once on load
            buildTargetSkeletons();

            // De-bounce timer to prevent race condition on input
            let calcTimer;
            const debouncedCalculate = () => {
                clearTimeout(calcTimer);
                // Run calculation on next animation frame for smoothness
                requestAnimationFrame(()_ => {
                    calcTimer = setTimeout(calculateAndRender, 50); // 50ms debounce
                });
            };

            // Calculate on any input change
            DOMElements.shiftStart.addEventListener('input', debouncedCalculate);
            DOMElements.shiftEnd.addEventListener('input', debouncedCalculate);
            DOMElements.breakTime.addEventListener('input', debouncedCalculate);
            DOMElements.currentCallTime.addEventListener('input', debouncedCalculate);
            DOMElements.currentTickets.addEventListener('input', debouncedCalculate);
            
            // FIX F-3: Streamlined interval
            setInterval(() => {
                // This interval ONLY updates what's necessary every second
                const { 
                    now,
                    productiveMinutesPassed, 
                    productiveMinutesRemaining
                } = getScheduleInfo();

                // Check for DOMElements before updating
                if (DOMElements.currentTime) {
                   DOMElements.currentTime.innerText = `Current Time: ${now.toLocaleTimeString()}`;
                }
                if (DOMElements.timePassed) {
                    DOMElements.timePassed.innerText = formatMinutesToHHMM(productiveMinutesPassed);
                }
                if (DOMElements.timeRemaining) {
                    DOMElements.timeRemaining.innerText = formatMinutesToHHMM(productiveMinutesRemaining);
                }
                
                // Re-run the full calculation to keep projections in sync with the clock
                debouncedCalculate();

            }, 1000); // Clock updates every second

            // Run once on load
            calculateAndRender(); 
        });
    </script>
</body>
</html>
