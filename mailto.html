<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MailTo Generator</title>
    <link rel="stylesheet" href="style.css">
    <style>
        /* --- View Styles --- */
        .view { display: none; }
        .view.active { display: block; }

        /* --- Upload Box --- */
        .upload-wrapper {
            border: 2px dashed var(--border-color);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            text-align: center;
            background-color: var(--info-bg);
            transition: background-color 0.2s;
        }
        .upload-wrapper.dragover {
            background-color: var(--primary-hover-bg-light);
            border-color: var(--primary-color);
        }
        .upload-wrapper input[type="file"] {
            display: none;
        }
        .upload-wrapper .button-base {
            cursor: pointer;
        }
        .upload-wrapper p {
            color: var(--subtle-text);
            margin: 0.5rem 0 0 0;
        }
        
        /* --- Tree/List Styles --- */
        .list-item {
            display: flex;
            align-items: center;
            padding: 0.6rem 0.5rem;
            border-radius: var(--border-radius);
            border: 1px solid transparent;
            cursor: default;
            transition: background-color 0.2s;
            gap: 0.75rem;
        }
        .list-item:hover {
            background-color: var(--info-bg);
            border-color: var(--border-color);
        }
        .list-item-icon {
            flex-shrink: 0;
            color: var(--subtle-text);
            width: 20px;
            height: 20px;
        }
        .list-item-icon.folder {
            color: var(--primary-color);
            cursor: pointer;
        }
        .list-item-icon.template {
            color: var(--subtle-text);
        }
        
        .list-item a.list-item-name {
            color: var(--text-color);
            text-decoration: none;
            cursor: pointer;
            flex-grow: 1;
            font-size: 0.9rem;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .list-item a.list-item-name:hover {
            color: var(--primary-color);
            text-decoration: underline;
        }
        .list-item .list-item-name-folder {
            flex-grow: 1;
            font-size: 0.9rem;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
        }
         .list-item .list-item-name-folder:hover {
            color: var(--primary-color);
         }


        .list-item-actions {
            flex-shrink: 0;
        }

        /* --- Breadcrumb Styles --- */
        .breadcrumb-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            align-items: center;
            background-color: var(--info-bg);
            padding: 0.5rem 0.75rem;
            border-radius: var(--border-radius);
            margin-bottom: 0.75rem;
            font-size: 0.85rem;
        }
        .breadcrumb-link {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            cursor: pointer;
        }
        .breadcrumb-link:hover {
            text-decoration: underline;
        }
        .breadcrumb-separator {
            color: var(--subtle-text);
            margin: 0 0.25rem;
        }
        .breadcrumb-current {
            color: var(--text-color);
            font-weight: 500;
        }

    </style>
</head>
<body>
    <div id="navbar-container"></div>

    <div class="app-container">
        <div class="panel">
            <div class="main-content">
                <div id="app-startup-error" class="hidden app-startup-banner"></div>
                
                <!-- VIEW 1: CATALOGUE / LIBRARY (DEFAULT VIEW) -->
                <div id="catalogue-view" class="view active">
                    <div class="section-header-wrapper">
                        <h3 class="section-header">Email Template Library</h3>
                        <div class="button-group">
                            <!-- REFACTOR: Removed btn-import-csv and btn-export-csv -->
                            <button id="btn-settings" class="button-base icon-btn" title="Settings"></button>
                            <button id="btn-new-folder" class="button-base icon-btn" title="New Folder"></button>
                            <button id="btn-new-template" class="button-base button-primary">New Template</button>
                        </div>
                    </div>

                    <div id="breadcrumb-container" class="breadcrumb-container">
                    </div>

                    <div id="tree-list-container">
                    </div>
                </div>

                <!-- VIEW 2: TEMPLATE EDITOR (GENERATOR) -->
                <div id="editor-view" class="view">
                    
                    <div class="section-header-wrapper">
                        <h3 class="section-header">Phase 1: Create or Upload</h3>
                        <div class="button-group">
                            <button id="btn-editor-cancel" class="button-base">Cancel</button>
                        </div>
                    </div>

                    <div id="upload-wrapper" class="upload-wrapper form-group">
                        <input type="file" id="msg-upload" accept=".msg,.oft">
                        <label for="msg-upload" class="button-base button-primary">
                            Upload .msg or .oft file
                        </label>
                        <p>or drag and drop a file here</p>
                    </div>

                    <div class="divider"></div>

                    <div class="section-header-wrapper">
                        <h3 class="section-header">Phase 2: Review and Edit Fields</h3>
                    </div>

                    <div class="form-group">
                        <label for="result-to">To</label>
                        <input type="text" id="result-to" class="sidebar-input">
                    </div>
                    <div class="form-group">
                        <label for="result-cc">CC</label>
                        <input type="text" id="result-cc" class="sidebar-input">
                    </div>
                    <div class="form-group">
                        <label for="result-bcc">BCC</label>
                        <input type="text" id="result-bcc" class="sidebar-input">
                    </div>
                    <div class="form-group">
                        <label for="result-subject">Subject</label>
                        <input type="text" id="result-subject" class="sidebar-input">
                    </div>
                    <div class="form-group">
                        <label for="result-body">Body (Text)</label>
                        <textarea id="result-body" class="sidebar-textarea"></textarea>
                    </div>
                    
                    <div class="form-group">
                         <button id="btn-generate" class="button-base button-primary" style="width: 100%;">Generate Command</button>
                    </div>

                    <!-- Phase 3: Output & Save -->
                    <div id="output-wrapper" class="hidden">
                        <div class="divider"></div>
                        <div class="section-header-wrapper">
                            <h3 class="section-header">Phase 3: Generated Output</h3>
                            <a href="#" id="result-link" target="_blank" class="button-base button-primary">Open in Email Client</a>
                        </div>
                        <div class="form-group">
                            <div class="label-group">
                                <label for="result-mailto">MailTo Command</label>
                                <button id="copy-mailto-btn" class="button-base">Copy</button>
                            </div>
                            <textarea id="result-mailto" class="sidebar-textarea" readonly placeholder="Generated command will appear here..."></textarea>
                        </div>
                        
                        <!-- Save to Library Section -->
                        <div class="app-section-box">
                             <div class="form-group">
                                <label for="save-template-name">Template Name</label>
                                <input type="text" id="save-template-name" class="sidebar-input" placeholder="e.g., Weekly Report Stub">
                            </div>
                            <div class="button-group">
                                <button id="btn-save-to-library" class="button-base button-success">Save to Library</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Global UI Elements -->
    <div id="modal-overlay" class="modal-overlay">
        <div id="modal-content" class="modal-content"></div>
    </div>
    <div id="toast" class="toast"></div>

    <!-- External Libs -->
    <script src="js/msgreader.js"></script>
    
    <!-- App Libs -->
    <script src="js/app-core.js"></script>
    <script src="js/app-ui.js"></script>
    <script src="js/app-data.js"></script>

    <!-- REFACTOR: Removed placeholder <script> tag comment -->

    <script>
    // ===================================================================
    // CONSTANTS & HELPERS (Issue 1, 10, 13, 15)
    // ===================================================================
    
    // C15: Global constant for file size limit
    const MAX_FILE_SIZE_BYTES = 10 * 1024 * 1024; // 10MB

    // Issue 1: Centralized MailTo field names
    const MAILTO_FIELDS = ['to', 'cc', 'bcc', 'subject', 'body'];

    // Issue 10: Extracted Icon SVGs
    const ICONS = {
        folder: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M.54 3.87.5 3.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 .5.5v.07L6.2 7H1.12zM0 4.25a.5.5 0 0 1 .5-.5h6.19l.74 1.85a.5.5 0 0 1 .44.25h4.13a.5.5 0 0 1 .5.5v.5a.5.5 0 0 1-.5.5H.5a.5.5 0 0 1-.5-.5zM.5 7a.5.5 0 0 0-.5.5v5a.5.5 0 0 0 .5.5h15a.5.5 0 0 0 .5-.5v-5a.5.5 0 0 0-.5-.5z"/></svg>',
        template: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M.05 3.555A2 2 0 0 1 2 2h12a2 2 0 0 1 1.95 1.555L8 8.414zM0 4.697v7.104l5.803-3.558zM6.761 8.83l-6.57 4.027A2 2 0 0 0 2 14h12a2 2 0 0 0 1.808-1.144l-6.57-4.027L8 9.586zm.15-1.4-1.291.I-4.276 2.624V4.697l5.562 3.42zM16 4.697v7.104l-5.803-3.558zM9.031 8.83l1.291.79 4.276 2.624V4.697l-5.562 3.42z"/></svg>'
    };

    // Issue 13: Extracted CSV path validation regex
    const CSV_PATH_REGEX = /^\/[\w\s\/-]*$/;

    // Issue 15: Centralized duplicate validation
    /**
     * Checks for a duplicate item in a container and shows a validation error if found.
     * @param {Array} container - The array of items/folders (children).
     * @param {string} name - The name to check.
     * @param {string} errorContext - The context for the error message ('folder' or 'item').
     * @param {string} inputId - The ID of the input field to highlight.
     * @returns {boolean} True if a duplicate exists, false otherwise.
     */
    const validateUniqueInContainer = (container, name, errorContext, inputId) => {
         if (DataValidator.hasDuplicate(container, 'name', name)) {
             SafeUI.showValidationError('Duplicate Name', 'An ' + errorContext + ' with this name already exists in this folder.', inputId);
             return true;
        }
        return false;
    };

    // Dependency Check
    (() => {
        // REFACTOR: Added SharedSettingsModal to dependency check
        const dependencies = ['SafeUI', 'UIPatterns', 'ListRenderer', 'SearchHelper', 'BackupRestore', 'DataValidator', 'DataConverter', 'CsvManager', 'SharedSettingsModal', 'MsgReader'];
        const missing = dependencies.filter(dep => typeof window[dep] === 'undefined');
        
        // REFACTOR: Changed check for MsgReader to be 'object' (not 'function')
        // and check for its 'read' method.
        if (typeof window.MsgReader !== 'object' || typeof window.MsgReader.read !== 'function') {
            if (!missing.includes('MsgReader')) {
                // If it was loaded but isn't the correct structure, mark it as missing
                missing.push('MsgReader (Invalid Type)');
            }
        }

        if (missing.length > 0) {
            const errorTitle = "Application Failed to Load";
            const errorMessage = `One or more required JavaScript files (e.g., app-core.js, msgreader.js) failed to load, or core modules are missing. Missing: ${missing.join(', ')}`;
            
            console.error(errorMessage);
            
            if (typeof window.AppLifecycle !== 'undefined' && typeof window.AppLifecycle._showErrorBanner === 'function') {
                window.AppLifecycle._showErrorBanner(errorTitle, errorMessage);
            } else {
                const banner = document.getElementById('app-startup-error');
                if(banner) {
                    banner.innerHTML = `<strong>${errorTitle}</strong><p style="margin:0.25rem 0 0 0;font-weight:normal;">${errorMessage}</p>`;
                    banner.classList.remove('hidden');
                }
            }
            throw new Error(`Critical dependencies missing: ${missing.join(', ')}`);
        }
    })();


    AppLifecycle.run(async () => {
    
        const APP_CONFIG = {
            NAME: 'mailto_library',
            VERSION: '1.1.0', 
            DATA_KEY: 'mailto_library_v1',
            CSV_HEADERS: ['name', 'path', ...MAILTO_FIELDS] // Issue 1
        };

        const defaultState = {
            version: APP_CONFIG.VERSION,
            library: [] 
        };
    
        const ctx = await AppLifecycle.initPage({
            storageKey: APP_CONFIG.DATA_KEY,
            defaultState: defaultState,
            version: APP_CONFIG.VERSION,
            requiredElements: [
                'navbar-container', 'toast', 'modal-overlay', 'modal-content',
                'catalogue-view', 'editor-view', 
                'btn-new-template', 'btn-new-folder', 
                'btn-settings', 
                /* REFACTOR: Removed 'btn-import-csv', 'btn-export-csv' */
                'breadcrumb-container', 'tree-list-container', 
                'btn-editor-cancel', 'btn-generate', 
                'upload-wrapper', 'msg-upload', 
                'result-to', 'result-cc', 'result-bcc', 'result-subject', 'result-body', 
                'output-wrapper', 'result-link', 'result-mailto', 'copy-mailto-btn', 
                'save-template-name', 'btn-save-to-library' 
            ]
        });
    
        // A7: Ensure context and elements object are valid
        if (!ctx || !ctx.elements) {
            console.error('AppLifecycle failed to initialize context or DOM elements.');
            return;
        }
    
        const { elements: DOMElements, state, saveState } = ctx;
        let currentFolderId = 'root'; 
        let currentMailtoCommand = null; 

        // C2: Helper to clear editor fields
        const clearEditorFields = () => {
            currentMailtoCommand = null;
            MAILTO_FIELDS.forEach(field => { // Issue 1
                const element = DOMElements['result' + field.charAt(0).toUpperCase() + field.slice(1)];
                if (element) element.value = '';
            });
            DOMElements.saveTemplateName.value = '';
            DOMElements.outputWrapper.classList.add('hidden');
        };
        
        // C13, B7, B8: Helper to check for unsaved changes
        const hasUnsavedEditorChanges = () => {
            // Check if any field has a value or if a command has been generated
            return currentMailtoCommand || MAILTO_FIELDS.some(field => {
                const element = DOMElements['result' + field.charAt(0).toUpperCase() + field.slice(1)];
                return element && element.value;
            });
        };
        
        // C29: Helpers for resizing
        const resizeResultBody = () => DOMHelpers.triggerTextareaResize(DOMElements.resultBody);
        const resizeResultMailto = () => DOMHelpers.triggerTextareaResize(DOMElements.resultMailto);

        // C28, A10: Helper for navigation
        const navigateToFolder = (id) => {
            currentFolderId = id;
            renderCatalogue();
        };

        // C6: Helper to generate modal content for new folder
        const createFolderModalHTML = () => {
            return '<input id="folder-name-input" class="sidebar-input" placeholder="Folder Name">';
        };

        // C4: Extracted handler for list item copy button
        const handleTreeItemCopy = (item, copyBtn) => {
            // B6: Stricter validation for dataset value
            const mailtoCommand = copyBtn.dataset.mailto;
            if (mailtoCommand && mailtoCommand !== 'undefined' && mailtoCommand !== 'null') {
                SafeUI.copyToClipboard(mailtoCommand);
                SafeUI.showToast(`Copied "${item.name}" to clipboard!`);
            } else {
                SafeUI.showToast('No command to copy from this template.');
            }
        };

        // C4: Extracted handler for list item delete button
        const handleTreeItemDelete = (id, item) => {
            UIPatterns.confirmDelete(item.type, item.name, () => {
                const container = getItemsInCurrentFolder();
                const index = container.findIndex(i => i.id === id);
                if (index > -1) {
                    container.splice(index, 1);
                    saveState();
                    renderCatalogue();
                }
            });
        };

        // C26: Named handlers for drag-and-drop
        const handleDragEnterOver = (e) => {
            e.preventDefault();
            DOMElements.uploadWrapper.classList.add('dragover');
        };

        const handleDragLeave = (e) => {
            e.preventDefault();
            DOMElements.uploadWrapper.classList.remove('dragover');
        };

        const handleDrop = (e) => {
            e.preventDefault();
            DOMElements.uploadWrapper.classList.remove('dragover'); // Remove dragover class
            const files = e.dataTransfer.files;
            if (files && files.length > 0) handleFile(files[0]);
        };


        // ===================================================================
        // CORE DATA FUNCTIONS
        // ===================================================================

        /**
         * Parses a mailto: string into its plain-text components.
         */
        const parseMailto = (mailtoStr) => {
            const data = {};
            MAILTO_FIELDS.forEach(field => data[field] = ''); // Issue 1: Initialize all fields

            if (!mailtoStr || !mailtoStr.startsWith('mailto:')) {
                return data;
            }
            
            // A3: Validate basic mailto structure before attempting URL constructor
            if (!/^mailto:[^\s]*/.test(mailtoStr)) {
                return data;
            }

            try {
                // Use new URL() for robust parsing. Replace spaces to avoid errors.
                const url = new URL(mailtoStr.replace(/ /g, '%20'));
                
                // pathname holds the 'to' address
                data.to = decodeURIComponent(url.pathname || '');
                
                // searchParams handles all other fields
                MAILTO_FIELDS.slice(1).forEach(field => { // Issue 1: Iterate over cc, bcc, subject, body
                    data[field] = decodeURIComponent(url.searchParams.get(field) || '');
                });
                
                return data;
            } catch (e) {
                console.warn("Mailto string parsing failed:", mailtoStr, e);
                // B1: Fallback logic fix. If '?' exists, we can't safely assign to 'to' field.
                if (mailtoStr.indexOf('?') === -1) {
                     // B10: Decode the 'to' part in the fallback path
                     try { 
                        data.to = decodeURIComponent(mailtoStr.substring(7)); 
                     } catch { 
                        data.to = mailtoStr.substring(7);
                     }
                }
                // If the URL constructor fails AND there are query parameters, return corrupted data empty.
                return data;
            }
        };

        /**
         * Builds a mailto: string from plain-text components.
         */
        const buildMailto = (data) => {
            let mailto = 'mailto:';
            // B1: Handle multiple recipients correctly (comma-separated list for most clients)
            if (data.to) {
                const recipients = data.to.split(',').map(r => r.trim()).filter(Boolean);
                mailto += recipients.map(r => encodeURIComponent(r)).join(',');
            }
            
            const params = [];
            
            MAILTO_FIELDS.slice(1).forEach(field => { // Issue 1: Iterate over cc, bcc, subject, body
                 if (data[field]) {
                    if (field === 'body') {
                        // Normalize line endings and encode for email clients
                        const normalizedBody = data.body.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                        const encodedBody = encodeURIComponent(normalizedBody).replace(/%0A/g, '%0D%0A');
                        params.push('body=' + encodedBody);
                    } else {
                        params.push(field + '=' + encodeURIComponent(data[field]));
                    }
                }
            });
            
            if (params.length > 0) {
                mailto += '?' + params.join('&');
            }
            return mailto;
        };


        // A5: Recursive search for an item/folder in the tree with circular reference protection
        const findItemById = (id, items = state.library, visited = new Set()) => {
            if (id === 'root') return { id: 'root', name: 'Root', children: state.library, path: '/' };
            for (const item of items) {
                // A5: Circular reference protection
                if (visited.has(item.id)) continue; 
                visited.add(item.id); 

                if (item.id === id) return item;
                if (item.type === 'folder' && item.children) {
                    const found = findItemById(id, item.children, visited); // Pass set to recursive call
                    if (found) return found;
                }
            }
            return null;
        };
        
        // Get children of the current folder
        const getItemsInCurrentFolder = () => {
            if (currentFolderId === 'root') {
                return state.library;
            }
            const folder = findItemById(currentFolderId);
            return folder ? folder.children : [];
        };

        // A4: Generate breadcrumb path (iterative with loop protection)
        const getBreadcrumbPath = (folderId) => {
            if (folderId === 'root') return [{ id: 'root', name: 'Root' }];

            const path = [];
            let targetItem = null;
            
            // A4: Circular reference and iteration protection
            const visitedIds = new Set(); 
            let iterations = 0; 
            const maxIterations = state.library.length * 10; // Simple heuristic limit

            // Stack for iterative depth-first search
            const stack = state.library.map(item => [item, []]);

            while (stack.length > 0) {
                 // A4: Check iteration limit
                if (++iterations > maxIterations) { 
                    console.error("Breadcrumb path generation exceeded max iterations, circular reference suspected.");
                    break; 
                }

                const [currentItem, parentPath] = stack.pop();
                
                if (visitedIds.has(currentItem.id)) continue; // Check if already visited in this path search
                visitedIds.add(currentItem.id);

                const currentPath = [...parentPath, { id: currentItem.id, name: currentItem.name }];

                if (currentItem.id === folderId) {
                    targetItem = currentItem;
                    path.push(...currentPath);
                    break; 
                }

                if (currentItem.type === 'folder' && currentItem.children) {
                    for (let i = currentItem.children.length - 1; i >= 0; i--) {
                        stack.push([currentItem.children[i], currentPath]);
                    }
                }
            }
            
            // Always prepend Root
            path.unshift({ id: 'root', name: 'Root' });
            return path;
        };


        // ===================================================================
        // RENDER & VIEW FUNCTIONS
        // ===================================================================

        // C18: Refactored breadcrumb rendering
        const renderBreadcrumbs = (path) => {
            const html = path.map((part, index) => {
                const escapedId = SafeUI.escapeHTML(part.id);
                const escapedName = SafeUI.escapeHTML(part.name);

                if (index === path.length - 1) {
                    return `<span class="breadcrumb-current">${escapedName}</span>`;
                } else {
                    return `<a class="breadcrumb-link" data-id="${escapedId}">${escapedName}</a><span class="breadcrumb-separator">&gt;</span>`;
                }
            }).join('');
            DOMElements.breadcrumbContainer.innerHTML = html;
        };

        // Main Render Function
        const renderCatalogue = () => {
            // Render Breadcrumbs (C18)
            const path = getBreadcrumbPath(currentFolderId);
            renderBreadcrumbs(path);

            // Render List
            const items = getItemsInCurrentFolder();
            // Sort folders first, then items, alphabetically
            const sortedItems = [...items].sort((a, b) => {
                if (a.type === 'folder' && b.type !== 'folder') return -1;
                if (a.type !== 'folder' && b.type === 'folder') return 1;
                // B5: Null/undefined name safety
                return (a.name || '').localeCompare(b.name || '');
            });
            
            ListRenderer.renderList({
                container: DOMElements.treeListContainer,
                items: sortedItems,
                emptyMessage: "This folder is empty. Click 'New Template' to add one.",
                createItemElement: (item) => {
                    const div = document.createElement('div');
                    div.className = 'list-item';
                    div.dataset.id = item.id;
                    div.dataset.type = item.type;
                    
                    const iconType = item.type === 'folder' ? 'folder' : 'template';
                    const iconSvg = ICONS[iconType]; // Issue 10: Use ICONS constant
                    
                    let nameElement = '';
                    const escapedName = SafeUI.escapeHTML(item.name);

                    if (item.type === 'folder') {
                        nameElement = `<span class="list-item-name-folder">${escapedName}</span>`;
                    } else {
                        const escapedMailto = SafeUI.escapeHTML(item.mailto);
                        nameElement = `<a href="${escapedMailto}" class="list-item-name" title="Launch: ${escapedName}">${escapedName}</a>`;
                    }

                    div.innerHTML = `
                        <div class="list-item-icon ${iconType}">${iconSvg}</div>
                        ${nameElement}
                        <div class="list-item-actions">
                            ${item.type === 'item' ? `<button class="icon-btn copy-btn" title="Copy mailto: command" data-mailto="${SafeUI.escapeHTML(item.mailto)}">${SafeUI.SVGIcons.copy}</button>` : ''}
                            <button class="icon-btn delete-btn" title="Delete">${SafeUI.SVGIcons.trash}</button>
                        </div>
                    `;
                    return div;
                }
            });
        };

        // View Switching
        const showView = (viewName) => {
            DOMElements.catalogueView.classList.toggle('active', viewName === 'catalogue');
            DOMElements.editorView.classList.toggle('active', viewName === 'editor');
        };

        // ===================================================================
        // EDITOR FUNCTIONS (UPLOAD & GENERATE)
        // ===================================================================

        const handleFile = (file) => {
            try { // A6: Error boundary
                if (!file) {
                    return SafeUI.showModal('Error', '<p>No file selected.</p>', [{label: 'OK'}]);
                }
                // B2/C15: Validate file size before reading
                if (file.size > MAX_FILE_SIZE_BYTES) { 
                    return SafeUI.showModal('File Too Large', '<p>File must be under 10MB.</p>', [{label: 'OK'}]); 
                }

                // Validate file type
                if (!file.name.endsWith('.msg') && !file.name.endsWith('.oft')) {
                    return SafeUI.showModal('Invalid File', '<p>Please upload a <strong>.msg</strong> or <strong>.oft</strong> file.</p>', [{label: 'OK'}]);
                }
                
                // B4/C2: Clear previous data
                clearEditorFields();

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        // REFACTOR: Check for MsgReader.read as a function
                        if (!window.MsgReader || typeof window.MsgReader.read !== 'function') { 
                            throw new Error('MsgReader library not loaded or invalid.'); 
                        } 

                        // REFACTOR: Call MsgReader.read() static method
                        const fileData = window.MsgReader.read(e.target.result); 

                        // Assuming MsgReader fieldsData now has properties like subject, body, and array recipients
                        
                        DOMElements.resultSubject.value = fileData.getFieldValue('subject') || '';
                        DOMElements.resultBody.value = fileData.getFieldValue('body') || '';

                        // Recipient handling is complex and dependent on MsgReader structure, mocking basic extraction
                        const recipients = fileData.getFieldValue('recipients') || [];
                        DOMElements.resultTo.value = recipients.filter(r => r.recipientType === 1).map(r => r.recipientEmail || r.recipientEmailAddress).filter(Boolean).join(', ');
                        DOMElements.resultCc.value = recipients.filter(r => r.recipientType === 2).map(r => r.recipientEmail || r.recipientEmailAddress).filter(Boolean).join(', ');
                        DOMElements.resultBcc.value = recipients.filter(r => r.recipientType === 3).map(r => r.recipientEmail || r.recipientEmailAddress).filter(Boolean).join(', ');

                        
                        // The save template name will be handled by generateAndShowMailto or handleNewTemplate
                        DOMElements.outputWrapper.classList.add('hidden'); // Hide output on new upload
                        setTimeout(() => resizeResultBody(), 0);
                    } catch (err) {
                        console.error('File parsing error:', err);
                        // A1: The error propagation hazard. Re-throw here relies on outer promise/global handler.
                        throw new Error(`Failed to parse file: ${err.message}`);
                    }
                };
                reader.onerror = () => {
                    // A1: This error is correctly thrown to rely on outer promise/global handler.
                    throw new Error('File reading failed. Could not access file content.');
                };
                reader.readAsArrayBuffer(file);
            } catch (e) {
                console.error('File operation failed:', e);
                SafeUI.showToast('File operation failed due to internal error.');
            }
        };

        const generateAndShowMailto = () => {
            const mailtoData = {
                to: DOMElements.resultTo.value.trim(),
                cc: DOMElements.resultCc.value.trim(),
                bcc: DOMElements.resultBcc.value.trim(),
                subject: DOMElements.resultSubject.value.trim(),
                body: DOMElements.resultBody.value // Body is handled with internal trimming/formatting in buildMailto
            };

            const mailto = buildMailto(mailtoData);

            currentMailtoCommand = mailto; // Save for library
            DOMElements.resultMailto.value = mailto;
            DOMElements.resultLink.href = mailto;
            DOMElements.outputWrapper.classList.remove('hidden');
            
            // B3: Auto-fill template name only if truly empty (not just whitespace)
            const templateNameValue = DOMElements.saveTemplateName.value;
            if (!templateNameValue.trim() && !templateNameValue) {
                 DOMElements.saveTemplateName.value = (mailtoData.subject || 'New Template').replace(/[\r\n\t\/\\]/g, ' ').trim();
            }

            setTimeout(() => resizeResultMailto(), 0);
        };
        
        // ===================================================================
        // LIBRARY ACTION HANDLERS
        // ===================================================================
        
        const handleNewTemplate = () => {
             // B7/C13: Confirm if user has unsaved work
            if (hasUnsavedEditorChanges()) {
                // A3: This relies on UIPatterns.confirmUnsavedChanges executing its callback
                UIPatterns.confirmUnsavedChanges(() => {
                    clearEditorFields(); // C2
                    resizeResultBody(); // C29
                    showView('editor');
                });
                return;
            }

            // Reset editor
            clearEditorFields(); // C2
            resizeResultBody(); // C29
            showView('editor');
        };
        
        const handleNewFolder = () => {
            SafeUI.showModal('New Folder', createFolderModalHTML(), [ // C6: Use helper function
                {label: 'Cancel'},
                {label: 'Create', class: 'button-primary', callback: () => {
                    try { // A6: Error boundary for new folder creation logic
                        const nameInput = document.getElementById('folder-name-input');
                        const name = nameInput.value.trim();
                        
                        // B2: Validation for path separators (critical for path integrity)
                        if (name.includes('/') || name.includes('\\')) {
                             return SafeUI.showValidationError('Invalid Name', 'Folder name cannot contain path separators (/, \\).', 'folder-name-input');
                        }

                        if (!SafeUI.validators.notEmpty(name)) {
                            return SafeUI.showValidationError('Invalid Name', 'Folder name cannot be empty.', 'folder-name-input');
                        }
                        
                        const container = getItemsInCurrentFolder();
                        // Issue 15: Use centralized validation helper
                        if (validateUniqueInContainer(container, name, 'folder', 'folder-name-input')) {
                             return;
                        }
                        
                        container.push({
                            id: SafeUI.generateId(),
                            type: 'folder',
                            name: name,
                            children: []
                        });
                        saveState();
                        renderCatalogue();
                    } catch(e) {
                        console.error('Folder creation failed:', e);
                        SafeUI.showToast('Folder creation failed due to internal error.');
                    }
                }}
            ]);
        };
        
        const handleSaveToLibrary = () => {
            // B3: Check if command has been generated
            if (!currentMailtoCommand) {
                SafeUI.showValidationError('No Command Generated', 'Click "Generate Command" first.', 'btn-generate');
                return;
            }

            const name = DOMElements.saveTemplateName.value.trim();
            if (!SafeUI.validators.notEmpty(name)) {
                return SafeUI.showValidationError('Invalid Name', 'Template name cannot be empty.', 'save-template-name');
            }
            
            const container = getItemsInCurrentFolder();
            // Issue 15: Use centralized validation helper
            if (validateUniqueInContainer(container, name, 'item', 'save-template-name')) {
                return;
            }
            
            container.push({
                id: SafeUI.generateId(),
                type: 'item',
                name: name,
                mailto: currentMailtoCommand
            });
            saveState();
            SafeUI.showToast('Template saved!');
            showView('catalogue');
            renderCatalogue();
        };

        // ===================================================================
        // DATA MANAGEMENT HANDLERS (CSV)
        // ===================================================================
        
        // REFACTOR: This entire `setupCsvImport` function will be moved
        // into the new `setupSettingsModal` function.
        

        // REFACTOR: This new function replaces the old settings init
        const setupSettingsModal = () => {
            // 1. Define page-specific HTML (for CSV buttons)
            const pageDataHtml = `
                <button id="modal-export-csv-btn" class="button-base">Export Library (CSV)</button>
                <button id="modal-import-csv-btn" class="button-base">Import Library (CSV)</button>
            `;

            // 2. Define page-specific "open" callback (to wire up buttons)
            const onModalOpen = () => {
                // Wire up CSV Export
                CsvManager.setupExport({
                    exportBtn: document.getElementById('modal-export-csv-btn'),
                    headers: APP_CONFIG.CSV_HEADERS,
                    dataGetter: () => {
                        const csvData = [];
                        function walk(items, currentPath) {
                            for (const item of items) {
                                if (item.type === 'folder') {
                                    walk(item.children, currentPath + item.name + '/');
                                } else if (item.type === 'item') {
                                    const mailtoParts = parseMailto(item.mailto);
                                    const row = { name: item.name, path: currentPath };
                                    MAILTO_FIELDS.forEach(field => { row[field] = mailtoParts[field]; });
                                    csvData.push(row);
                                }
                            }
                        }
                        walk(state.library, '/');
                        if (csvData.length === 0) {
                             SafeUI.showToast("Library is empty, nothing to export.");
                             return []; 
                        }
                        return csvData;
                    },
                    filename: `${APP_CONFIG.NAME}-export.csv`
                });
                
                // Wire up CSV Import
                const validateCsvRow = (row, index) => {
                    if (!row.name || !row.name.trim()) {
                        return { error: `Row ${index + 2}: 'name' column is required.` };
                    }
                    if (!row.path || !CSV_PATH_REGEX.test(row.path.trim())) { 
                        return { error: `Row ${index + 2}: 'path' must be a valid folder path like /folder or /folder/subfolder` };
                    }
                    return { entry: row };
                };
                const confirmCsvImport = (validatedData, importErrors) => {
                    const summaryHtml = `<p>This will <strong>ADD ${validatedData.length} templates</strong> to your library. It will skip duplicates (same name in the same path).</p>
                                         ${importErrors.length > 0 ? `<p><strong>${importErrors.length} rows had errors and will be skipped.</strong></p>` : ''}
                                         <p>Do you want to continue?</p>`;
                    SafeUI.showModal("Confirm CSV Import", summaryHtml, [
                        { label: 'Cancel' },
                        { 
                            label: 'Import', 
                            class: 'button-primary', 
                            callback: () => {
                                let importedCount = 0;
                                let skippedCount = 0;
                                for (const row of validatedData) {
                                    const pathParts = row.path.split('/').filter(p => p.trim().length > 0); 
                                    let currentContainer = state.library;
                                    for (const part of pathParts) {
                                        let folder = currentContainer.find(i => i.type === 'folder' && i.name.toLowerCase() === part.toLowerCase());
                                        if (!folder) {
                                            folder = { id: SafeUI.generateId(), type: 'folder', name: part, children: [] };
                                            currentContainer.push(folder);
                                        }
                                        currentContainer = folder.children;
                                    }
                                    if (DataValidator.hasDuplicate(currentContainer, 'name', row.name)) {
                                        skippedCount++;
                                    } else {
                                        const newMailto = buildMailto(row);
                                        currentContainer.push({ id: SafeUI.generateId(), type: 'item', name: row.name.trim(), mailto: newMailto });
                                        importedCount++;
                                    }
                                }
                                if (importedCount > 0) { saveState(); renderCatalogue(); }
                                SafeUI.showToast(`Import complete. Added ${importedCount}, skipped ${skippedCount}.`);
                                SafeUI.hideModal(); // Close settings modal
                            }
                        }
                    ]);
                    return false; // Prevent modal from closing
                };
                CsvManager.setupImport({
                    importBtn: document.getElementById('modal-import-csv-btn'),
                    headers: APP_CONFIG.CSV_HEADERS,
                    onValidate: validateCsvRow,
                    onConfirm: confirmCsvImport
                });
            };

            // 3. Define page-specific "restore" callback
            const onRestore = (dataToRestore) => {
                state.library = dataToRestore.library || [];
                currentFolderId = 'root';
                saveState();
                renderCatalogue();
            };

            // 4. Initialize the shared modal
            window.SharedSettingsModal.init({
                buttonId: 'btn-settings',
                appName: APP_CONFIG.NAME,
                state: { library: state.library, version: state.version },
                pageSpecificDataHtml: pageDataHtml, 
                onModalOpen: onModalOpen,           
                onRestoreCallback: onRestore,
                itemValidators: {
                    library: []
                }
            });
        };


        // ===================================================================
        // EVENT LISTENERS
        // ===================================================================

        const attachEventListeners = () => {
            // REFACTOR: Replaced old modal init with new setup function call
            setupSettingsModal();

            // Catalogue View
            DOMElements.btnNewTemplate.addEventListener('click', handleNewTemplate);
            DOMElements.btnNewFolder.addEventListener('click', handleNewFolder);
            
            // REFACTOR: Removed CsvManager.setupExport
            
            // REFACTOR: Removed setupCsvImport() call
            
            // Editor View
            DOMElements.btnEditorCancel.addEventListener('click', () => {
                // B8/C13: Warn about unsaved changes
                if (hasUnsavedEditorChanges()) {
                    UIPatterns.confirmUnsavedChanges(() => {
                        showView('catalogue');
                        renderCatalogue();
                    });
                } else {
                    showView('catalogue');
                    renderCatalogue();
                }
            });

            DOMElements.btnGenerate.addEventListener('click', generateAndShowMailto);
            DOMElements.btnSaveToLibrary.addEventListener('click', handleSaveToLibrary);
            
            // B6: Copy button validation for the main editor output
            DOMElements.copyMailtoBtn.addEventListener('click', async () => {
                if (!currentMailtoCommand) {
                    SafeUI.showToast('No command to copy'); 
                    return;
                }
                const success = await SafeUI.copyToClipboard(currentMailtoCommand);
                SafeUI.showToast(success ? "Command copied to clipboard!" : "Failed to copy.");
            });
            
            // Setup Drag and Drop (Editor) (C26)
            DOMElements.uploadWrapper.addEventListener('dragenter', handleDragEnterOver);
            DOMElements.uploadWrapper.addEventListener('dragover', handleDragEnterOver);
            DOMElements.uploadWrapper.addEventListener('dragleave', handleDragLeave);
            DOMElements.uploadWrapper.addEventListener('drop', handleDrop);
            
            DOMElements.msgUpload.addEventListener('change', (e) => {
                if (e.target.files && e.target.files.length > 0) handleFile(e.target.files[0]);
            });

            // Event Delegation for Lists
            DOMElements.treeListContainer.addEventListener('click', (e) => {
                const itemEl = e.target.closest('.list-item');
                if (!itemEl) return;
                
                // If user clicks the main link, let the browser handle it.
                if (e.target.closest('.list-item-name')) {
                    return; 
                }
                
                e.preventDefault(); // For any other click (buttons, folder icons)

                const id = itemEl.dataset.id;
                const item = getItemsInCurrentFolder().find(i => i.id === id);
                if (!item) return;

                // Handle folder name click (navigation)
                if (e.target.closest('.list-item-name-folder') || e.target.closest('.list-item-icon.folder')) {
                    if (item.type === 'folder') {
                        navigateToFolder(item.id); 
                    }
                    return;
                }

                // C4: Handle Copy Button
                const copyBtn = e.target.closest('.copy-btn');
                if (copyBtn) {
                    handleTreeItemCopy(item, copyBtn);
                    return;
                }
                
                // C4: Handle Delete Button
                if (e.target.closest('.delete-btn')) {
                    handleTreeItemDelete(id, item);
                    return; 
                }
            });
            
            DOMElements.breadcrumbContainer.addEventListener('click', (e) => {
                 const link = e.target.closest('.breadcrumb-link');
                 if (link && link.dataset.id) {
                     const targetId = link.dataset.id;
                     // A10: Validate folder existence before navigating
                     if (targetId === 'root' || findItemById(targetId)) { 
                         navigateToFolder(targetId); // C28
                     } else {
                         console.warn('Folder not found, returning to root');
                         navigateToFolder('root'); // C28
                     }
                 }
            });
        };

        // Init
        const init = () => {
            // A9: Critical state validation/reset
            if (!state.library || !Array.isArray(state.library)) { 
                console.error('State corrupted, resetting library'); 
                state.library = []; 
                saveState(); 
            }
            
            // Setup icons
            DOMElements.btnNewFolder.innerHTML = SafeUI.SVGIcons.plus + ICONS.folder; // Issue 10: Use ICONS constant

            // Setup textareas
            DOMHelpers.setupTextareaAutoResize(DOMElements.resultBody);
            DOMHelpers.setupTextareaAutoResize(DOMElements.resultMailto, 150);
            
            attachEventListeners();
            
            // Initial render
            showView('catalogue');
            renderCatalogue();
        };

        init();
    });
    </script>
</body>
</html>

