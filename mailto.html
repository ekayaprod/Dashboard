<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MailTo Generator</title>
    <link rel="stylesheet" href="style.css">
    <!-- 
      REMOVED: The entire <style> block was moved to style.css
      and prefixed with .mailto-page
    -->
</head>
<body class="mailto-page">
    <div id="navbar-container"></div>

    <div class="app-container">
        <div class="panel">
            <div class="main-content">
                <div id="app-startup-error" class="hidden app-startup-banner"></div>
                
                <!-- VIEW 1: CATALOGUE / LIBRARY (DEFAULT VIEW) -->
                <div id="catalogue-view" class="view active">
                    <div class="section-header-wrapper">
                        <h3 class="section-header">Email Template Library</h3>
                        <div class="button-group">
                            <!-- REFACTOR: Removed btn-import-csv and btn-export-csv -->
                            <button id="btn-settings" class="button-base icon-btn" title="Settings"></button>
                            <button id="btn-new-folder" class="button-base icon-btn" title="New Folder"></button>
                            <button id="btn-new-template" class="button-base button-primary">New Template</button>
                        </div>
                    </div>

                    <div id="breadcrumb-container" class="breadcrumb-container">
                    </div>

                    <div id="tree-list-container">
                    </div>
                </div>

                <!-- VIEW 2: TEMPLATE EDITOR (GENERATOR) -->
                <div id="editor-view" class="view">
                    
                    <div class="section-header-wrapper">
                        <h3 class="section-header">Phase 1: Create or Upload</h3>
                        <div class="button-group">
                            <button id="btn-editor-cancel" class="button-base">Cancel</button>
                        </div>
                    </div>

                    <div id="upload-wrapper" class="upload-wrapper form-group">
                        <input type="file" id="msg-upload" accept=".msg,.oft">
                        <label for="msg-upload" class="button-base button-primary">
                            Upload .msg or .oft file
                        </label>
                        <p>or drag and drop a file here</p>
                    </div>

                    <div class="divider"></div>

                    <div class="section-header-wrapper">
                        <h3 class="section-header">Phase 2: Review and Edit Fields</h3>
                    </div>

                    <div class="form-group">
                        <label for="result-to">To</label>
                        <input type="text" id="result-to" class="sidebar-input">
                    </div>
                    <div class="form-group">
                        <label for="result-cc">CC</label>
                        <input type="text" id="result-cc" class="sidebar-input">
                    </div>
                    <div class="form-group">
                        <label for="result-bcc">BCC</label>
                        <input type="text" id="result-bcc" class="sidebar-input">
                    </div>
                    <div class="form-group">
                        <label for="result-subject">Subject</label>
                        <input type="text" id="result-subject" class="sidebar-input">
                    </div>
                    <div class="form-group">
                        <label for="result-body">Body (Text)</label>
                        <textarea id="result-body" class="sidebar-textarea"></textarea>
                    </div>
                    
                    <div class="form-group">
                         <button id="btn-generate" class="button-base button-primary" style="width: 100%;">Generate Command</button>
                    </div>

                    <!-- Phase 3: Output & Save -->
                    <div id="output-wrapper" class="hidden">
                        <div class="divider"></div>
                        <div class="section-header-wrapper">
                            <h3 class="section-header">Phase 3: Generated Output</h3>
                            <a href="#" id="result-link" target="_blank" class="button-base button-primary">Open in Email Client</a>
                        </div>
                        <div class="form-group">
                            <div class="label-group">
                                <label for="result-mailto">MailTo Command</label>
                                <button id="copy-mailto-btn" class="button-base">Copy</button>
                            </div>
                            <textarea id="result-mailto" class="sidebar-textarea" readonly placeholder="Generated command will appear here..."></textarea>
                        </div>
                        
                        <!-- Save to Library Section -->
                        <div class="app-section-box">
                             <div class="form-group">
                                <label for="save-template-name">Template Name</label>
                                <input type="text" id="save-template-name" class="sidebar-input" placeholder="e.g., Weekly Report Stub">
                            </div>
                            <div class="button-group">
                                <button id="btn-save-to-library" class="button-base button-success">Save to Library</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Global UI Elements -->
    <div id="modal-overlay" class="modal-overlay">
        <div id="modal-content" class="modal-content"></div>
    </div>
    <div id="toast" class="toast"></div>

    <!-- App Libs -->
    <script src="js/app-core.js"></script>
    <script src="js/app-ui.js"></script>
    <script src="js/app-data.js"></script>

    <!-- External Libs -->
    <script src="js/msgreader.js"></script>
    
    <script>
    // ===================================================================
    // CONSTANTS & HELPERS (Issue 1, 10, 13, 15)
    // ===================================================================
    
    // C15: Global constant for file size limit
    const MAX_FILE_SIZE_BYTES = 10 * 1024 * 1024; // 10MB

    // Issue 1: Centralized MailTo field names
    const MAILTO_FIELDS = ['to', 'cc', 'bcc', 'subject', 'body'];

    // Issue 10: Extracted Icon SVGs
    const ICONS = {
        folder: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M.54 3.87.5 3.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 .5.5v.07L6.2 7H1.12zM0 4.25a.5.5 0 0 1 .5-.5h6.19l.74 1.85a.5.5 0 0 1 .44.25h4.13a.5.5 0 0 1 .5.5v.5a.5.5 0 0 1-.5.5H.5a.5.5 0 0 1-.5-.5zM.5 7a.5.5 0 0 0-.5.5v5a.5.5 0 0 0 .5.5h15a.5.5 0 0 0 .5-.5v-5a.5.5 0 0 0-.5-.5z"/></svg>',
        /* * BUG FIX 1: Corrected SVG path data. 
         * The string ".I-" was replaced with ".79l-" to fix the syntax error.
         */
        template: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M.05 3.555A2 2 0 0 1 2 2h12a2 2 0 0 1 1.95 1.555L8 8.414zM0 4.697v7.104l5.803-3.558zM6.761 8.83l-6.57 4.027A2 2 0 0 0 2 14h12a2 2 0 0 0 1.808-1.144l-6.57-4.027L8 9.586zm.15-1.4-1.291.79l-4.276 2.624V4.697l5.562 3.42zM16 4.697v7.104l-5.803-3.558zM9.031 8.83l1.291.79 4.276 2.624V4.697l-5.562 3.42z"/></svg>'
    };

    // Issue 13: Extracted CSV path validation regex
    const CSV_PATH_REGEX = /^\/[\w\s\/-]*$/;

    // Issue 15: Centralized duplicate validation
    /**
     * Checks for a duplicate item in a container and shows a validation error if found.
     * @param {Array} container - The array of items/folders (children).
     * @param {string} name - The name to check.
     * @param {string} errorContext - The context for the error message ('folder' or 'item').
     * @param {string} inputId - The ID of the input field to highlight.
     * @returns {boolean} True if a duplicate exists, false otherwise.
     */
    const validateUniqueInContainer = (container, name, errorContext, inputId) => {
         if (DataValidator.hasDuplicate(container, 'name', name)) {
             SafeUI.showValidationError('Duplicate Name', 'An ' + errorContext + ' with this name already exists in this folder.', inputId);
             return true;
        }
        return false;
    };

    // Dependency Check
    (() => {
        // REFACTOR: Added SharedSettingsModal to dependency check
        const dependencies = ['SafeUI', 'UIPatterns', 'ListRenderer', 'SearchHelper', 'BackupRestore', 'DataValidator', 'DataConverter', 'CsvManager', 'SharedSettingsModal', 'MsgReader'];
        const missing = dependencies.filter(dep => typeof window[dep] === 'undefined');
        
        // REFACTOR: Changed check for MsgReader to be 'object' (not 'function')
        // and check for its 'read' method.
        if (typeof window.MsgReader !== 'object' || typeof window.MsgReader.read !== 'function') {
            if (!missing.includes('MsgReader')) {
                // If it was loaded but isn't the correct structure, mark it as missing
                missing.push('MsgReader (Invalid Type)');
            }
        }

        if (missing.length > 0) {
            const errorTitle = "Application Failed to Load";
            const errorMessage = `One or more required JavaScript files (e.g., app-core.js, msgreader.js) failed to load, or core modules are missing. Missing: ${missing.join(', ')}`;
            
            console.error(errorMessage);
            
            if (typeof window.AppLifecycle !== 'undefined' && typeof window.AppLifecycle._showErrorBanner === 'function') {
                window.AppLifecycle._showErrorBanner(errorTitle, errorMessage);
            } else {
                const banner = document.getElementById('app-startup-error');
                if(banner) {
                    banner.innerHTML = `<strong>${errorTitle}</strong><p style="margin:0.25rem 0 0 0;font-weight:normal;">${errorMessage}</p>`;
                    banner.classList.remove('hidden');
                }
            }
            throw new Error(`Critical dependencies missing: ${missing.join(', ')}`);
        }
    })();


    AppLifecycle.run(async () => {
    
        const APP_CONFIG = {
            NAME: 'mailto_library',
            VERSION: '1.1.0', 
            DATA_KEY: 'mailto_library_v1',
            CSV_HEADERS: ['name', 'path', ...MAILTO_FIELDS] // Issue 1
        };

        const defaultState = {
            version: APP_CONFIG.VERSION,
            library: [] 
        };
    
        const ctx = await AppLifecycle.initPage({
            storageKey: APP_CONFIG.DATA_KEY,
            defaultState: defaultState,
            version: APP_CONFIG.VERSION,
            requiredElements: [
                'navbar-container', 'toast', 'modal-overlay', 'modal-content',
                'catalogue-view', 'editor-view', 
                'btn-new-template', 'btn-new-folder', 
                'btn-settings', 
                'breadcrumb-container', 'tree-list-container', 
                'btn-editor-cancel', 'btn-generate', 
                'upload-wrapper', 'msg-upload', 
                'result-to', 'result-cc', 'result-bcc', 'result-subject', 'result-body', 
                'output-wrapper', 'result-link', 'result-mailto', 'copy-mailto-btn', 
                'save-template-name', 'btn-save-to-library' 
            ]
        });
    
        if (!ctx || !ctx.elements) {
            console.error('AppLifecycle failed to initialize context or DOM elements.');
            return;
        }
    
        const { elements: DOMElements, state, saveState } = ctx;
        let currentFolderId = 'root'; 
        let currentMailtoCommand = null; 

        const clearEditorFields = () => {
            currentMailtoCommand = null;
            MAILTO_FIELDS.forEach(field => { 
                const element = DOMElements['result' + field.charAt(0).toUpperCase() + field.slice(1)];
                if (element) element.value = '';
            });
            DOMElements.saveTemplateName.value = '';
            DOMElements.outputWrapper.classList.add('hidden');
        };
        
        const hasUnsavedEditorChanges = () => {
            return currentMailtoCommand || MAILTO_FIELDS.some(field => {
                const element = DOMElements['result' + field.charAt(0).toUpperCase() + field.slice(1)];
                return element && element.value;
            });
        };
        
        const resizeResultBody = () => DOMHelpers.triggerTextareaResize(DOMElements.resultBody);
        const resizeResultMailto = () => DOMHelpers.triggerTextareaResize(DOMElements.resultMailto);

        const navigateToFolder = (id) => {
            currentFolderId = id;
            renderCatalogue();
        };

        const createFolderModalHTML = () => {
            return '<input id="folder-name-input" class="sidebar-input" placeholder="Folder Name">';
        };

        const handleTreeItemCopy = (item, copyBtn) => {
            const mailtoCommand = copyBtn.dataset.mailto;
            if (mailtoCommand && mailtoCommand !== 'undefined' && mailtoCommand !== 'null') {
                SafeUI.copyToClipboard(mailtoCommand);
                SafeUI.showToast(`Copied "${item.name}" to clipboard!`);
            } else {
                SafeUI.showToast('No command to copy from this template.');
            }
        };

        // REFACTOR: Modified to find the item's parent container for deletion
        const handleTreeItemDelete = (id, item) => {
            UIPatterns.confirmDelete(item.type, item.name, () => {
                // Find the parent container (folder) of the item to delete it
                const parent = findParentOfItem(id);
                if (parent) {
                    const index = parent.children.findIndex(i => i.id === id);
                    if (index > -1) {
                        parent.children.splice(index, 1);
                        saveState();
                        renderCatalogue();
                    }
                }
            });
        };
        
        // NEW FEATURE: Handle moving a template
        const handleTreeItemMove = (id, item) => {
            // 1. Generate list of possible target folders
            const folders = [];
            // Helper to recursively find folders
            function findFolders(container, path, currentFolderId) {
                // Add current folder
                folders.push({
                    id: currentFolderId,
                    name: path,
                    disabled: currentFolderId === findParentOfItem(id)?.id // Disable moving to current folder
                });
                // Find subfolders
                container.forEach(i => {
                    if (i.type === 'folder') {
                        findFolders(i.children, path + i.name + '/', i.id);
                    }
                });
            }
            
            // Find all folders starting from root
            findFolders(state.library, '/', 'root');

            // 2. Build Modal HTML
            const folderListHtml = folders.map(folder => `
                <li class="move-folder-item ${folder.disabled ? 'disabled' : ''}" data-folder-id="${SafeUI.escapeHTML(folder.id)}">
                    ${ICONS.folder} ${SafeUI.escapeHTML(folder.name)}
                </li>
            `).join('');

            const modalHtml = `
                <p>Move "<strong>${SafeUI.escapeHTML(item.name)}</strong>" to:</p>
                <ul class="move-folder-list">
                    ${folderListHtml}
                </ul>
            `;
            
            // 3. Show Modal
            SafeUI.showModal('Move Template', modalHtml, [{ label: 'Cancel' }]);
            
            // 4. Add listeners to the new folder list
            document.querySelector('.move-folder-list').addEventListener('click', (e) => {
                const targetFolderEl = e.target.closest('.move-folder-item');
                if (!targetFolderEl || targetFolderEl.classList.contains('disabled')) {
                    return;
                }
                
                const targetFolderId = targetFolderEl.dataset.folderId;
                
                // Find item's original parent and remove it
                const originalParent = findParentOfItem(id);
                if (!originalParent) return; // Should not happen
                
                const itemIndex = originalParent.children.findIndex(i => i.id === id);
                if (itemIndex === -1) return;
                
                // Remove item and get a reference to it
                const [itemToMove] = originalParent.children.splice(itemIndex, 1);
                
                // Find new parent and add it
                let newParentContainer;
                if (targetFolderId === 'root') {
                    newParentContainer = state.library;
                } else {
                    newParentContainer = findItemById(targetFolderId)?.children;
                }
                
                if (!newParentContainer) {
                    // Failsafe: put it back
                    originalParent.children.splice(itemIndex, 0, itemToMove);
                    return;
                }
                
                newParentContainer.push(itemToMove);
                
                saveState();
                renderCatalogue();
                SafeUI.hideModal();
                SafeUI.showToast('Template moved!');
            });
        };

        const handleDragEnterOver = (e) => {
            e.preventDefault();
            DOMElements.uploadWrapper.classList.add('dragover');
        };

        const handleDragLeave = (e) => {
            e.preventDefault();
            DOMElements.uploadWrapper.classList.remove('dragover');
        };

        const handleDrop = (e) => {
            e.preventDefault();
            DOMElements.uploadWrapper.classList.remove('dragover'); 
            const files = e.dataTransfer.files;
            if (files && files.length > 0) handleFile(files[0]);
        };


        // ===================================================================
        // CORE DATA FUNCTIONS
        // ===================================================================

        const parseMailto = (mailtoStr) => {
            const data = {};
            MAILTO_FIELDS.forEach(field => data[field] = ''); 

            if (!mailtoStr || !mailtoStr.startsWith('mailto:')) {
                return data;
            }
            
            if (!/^mailto:[^\s]*/.test(mailtoStr)) {
                return data;
            }

            try {
                const url = new URL(mailtoStr.replace(/ /g, '%20'));
                data.to = decodeURIComponent(url.pathname || '');
                MAILTO_FIELDS.slice(1).forEach(field => { 
                    data[field] = decodeURIComponent(url.searchParams.get(field) || '');
                });
                return data;
            } catch (e) {
                console.warn("Mailto string parsing failed:", mailtoStr, e);
                if (mailtoStr.indexOf('?') === -1) {
                     try { 
                        data.to = decodeURIComponent(mailtoStr.substring(7)); 
                     } catch { 
                        data.to = mailtoStr.substring(7);
                     }
                }
                return data;
            }
        };

        const buildMailto = (data) => {
            let mailto = 'mailto:';
            if (data.to) {
                const recipients = data.to.split(',').map(r => r.trim()).filter(Boolean);
                mailto += recipients.map(r => encodeURIComponent(r)).join(',');
            }
            
            const params = [];
            
            MAILTO_FIELDS.slice(1).forEach(field => { 
                 if (data[field]) {
                    if (field === 'body') {
                        const normalizedBody = data.body.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                        const encodedBody = encodeURIComponent(normalizedBody).replace(/%0A/g, '%0D%0A');
                        params.push('body=' + encodedBody);
                    } else {
                        params.push(field + '=' + encodeURIComponent(data[field]));
                    }
                }
            });
            
            if (params.length > 0) {
                mailto += '?' + params.join('&');
            }
            return mailto;
        };

        const findItemById = (id, items = state.library, visited = new Set()) => {
            if (id === 'root') return { id: 'root', name: 'Root', children: state.library, path: '/' };
            for (const item of items) {
                if (visited.has(item.id)) continue; 
                visited.add(item.id); 

                if (item.id === id) return item;
                if (item.type === 'folder' && item.children) {
                    const found = findItemById(id, item.children, visited); 
                    if (found) return found;
                }
            }
            return null;
        };
        
        // NEW FEATURE: Helper to find the parent object of an item
        const findParentOfItem = (childId, parent = { id: 'root', children: state.library }, visited = new Set()) => {
            if (visited.has(parent.id)) return null;
            visited.add(parent.id);
            
            if (parent.children) {
                if (parent.children.some(child => child.id === childId)) {
                    return parent;
                }
                for (const item of parent.children) {
                    if (item.type === 'folder') {
                        const foundParent = findParentOfItem(childId, item, visited);
                        if (foundParent) return foundParent;
                    }
                }
            }
            return null;
        };
        
        const getItemsInCurrentFolder = () => {
            if (currentFolderId === 'root') {
                return state.library;
            }
            const folder = findItemById(currentFolderId);
            return folder ? folder.children : [];
        };

        const getBreadcrumbPath = (folderId) => {
            if (folderId === 'root') return [{ id: 'root', name: 'Root' }];

            const path = [];
            let targetItem = null;
            
            const visitedIds = new Set(); 
            let iterations = 0; 
            const maxIterations = state.library.length * 10; 

            const stack = state.library.map(item => [item, []]);

            while (stack.length > 0) {
                if (++iterations > maxIterations) { 
                    console.error("Breadcrumb path generation exceeded max iterations, circular reference suspected.");
                    break; 
                }

                const [currentItem, parentPath] = stack.pop();
                
                if (visitedIds.has(currentItem.id)) continue; 
                visitedIds.add(currentItem.id);

                const currentPath = [...parentPath, { id: currentItem.id, name: currentItem.name }];

                if (currentItem.id === folderId) {
                    targetItem = currentItem;
                    path.push(...currentPath);
                    break; 
                }

                if (currentItem.type === 'folder' && currentItem.children) {
                    for (let i = currentItem.children.length - 1; i >= 0; i--) {
                        stack.push([currentItem.children[i], currentPath]);
                    }
                }
            }
            
            path.unshift({ id: 'root', name: 'Root' });
            return path;
        };


        // ===================================================================
        // RENDER & VIEW FUNCTIONS
        // ===================================================================

        const renderBreadcrumbs = (path) => {
            const html = path.map((part, index) => {
                const escapedId = SafeUI.escapeHTML(part.id);
                const escapedName = SafeUI.escapeHTML(part.name);

                if (index === path.length - 1) {
                    return `<span class="breadcrumb-current">${escapedName}</span>`;
                } else {
                    return `<a class="breadcrumb-link" data-id="${escapedId}">${escapedName}</a><span class="breadcrumb-separator">&gt;</span>`;
                }
            }).join('');
            DOMElements.breadcrumbContainer.innerHTML = html;
        };

        // Main Render Function
        const renderCatalogue = () => {
            const path = getBreadcrumbPath(currentFolderId);
            renderBreadcrumbs(path);

            const items = getItemsInCurrentFolder();
            const sortedItems = [...items].sort((a, b) => {
                if (a.type === 'folder' && b.type !== 'folder') return -1;
                if (a.type !== 'folder' && b.type === 'folder') return 1;
                return (a.name || '').localeCompare(b.name || '');
            });
            
            ListRenderer.renderList({
                container: DOMElements.treeListContainer,
                items: sortedItems,
                emptyMessage: "This folder is empty. Click 'New Template' to add one.",
                createItemElement: (item) => {
                    const div = document.createElement('div');
                    div.className = 'list-item';
                    div.dataset.id = item.id;
                    div.dataset.type = item.type;
                    
                    const iconType = item.type === 'folder' ? 'folder' : 'template';
                    const iconSvg = ICONS[iconType]; 
                    
                    let nameElement = '';
                    const escapedName = SafeUI.escapeHTML(item.name);

                    if (item.type === 'folder') {
                        nameElement = `<span class="list-item-name-folder">${escapedName}</span>`;
                    } else {
                        const escapedMailto = SafeUI.escapeHTML(item.mailto);
                        nameElement = `<a href="${escapedMailto}" class="list-item-name" title="Launch: ${escapedName}">${escapedName}</a>`;
                    }

                    // NEW FEATURE: Added Move button
                    const moveButton = item.type === 'item' ? 
                        `<button class="icon-btn move-btn" title="Move to...">${SVGIcons.pencil}</button>` : '';

                    div.innerHTML = `
                        <div class="list-item-icon ${iconType}">${iconSvg}</div>
                        ${nameElement}
                        <div class="list-item-actions">
                            ${item.type === 'item' ? `<button class="icon-btn copy-btn" title="Copy mailto: command" data-mailto="${SafeUI.escapeHTML(item.mailto)}">${SafeUI.SVGIcons.copy}</button>` : ''}
                            ${moveButton}
                            <button class="icon-btn delete-btn" title="Delete">${SafeUI.SVGIcons.trash}</button>
                        </div>
                    `;
                    return div;
                }
            });
        };

        const showView = (viewName) => {
            DOMElements.catalogueView.classList.toggle('active', viewName === 'catalogue');
            DOMElements.editorView.classList.toggle('active', viewName === 'editor');
        };

        // ===================================================================
        // EDITOR FUNCTIONS (UPLOAD & GENERATE)
        // ===================================================================

        const handleFile = (file) => {
            try { 
                if (!file) {
                    return SafeUI.showModal('Error', '<p>No file selected.</p>', [{label: 'OK'}]);
                }
                if (file.size > MAX_FILE_SIZE_BYTES) { 
                    return SafeUI.showModal('File Too Large', '<p>File must be under 10MB.</p>', [{label: 'OK'}]); 
                }

                if (!file.name.endsWith('.msg') && !file.name.endsWith('.oft')) {
                    return SafeUI.showModal('Invalid File', '<p>Please upload a <strong>.msg</strong> or <strong>.oft</strong> file.</p>', [{label: 'OK'}]);
                }
                
                clearEditorFields();

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        if (!window.MsgReader || typeof window.MsgReader.read !== 'function') { 
                            throw new Error('MsgReader library not loaded or invalid.'); 
                        }

                        // Validate file size
                        const arrayBuffer = e.target.result;
                        if (!arrayBuffer || arrayBuffer.byteLength < 512) {
                            throw new Error('File too small or empty. MSG files must be at least 512 bytes.');
                        }

                        // Log file info for debugging
                        console.log('File info:', {
                            name: file.name,
                            size: file.size,
                            type: file.type,
                            bufferSize: arrayBuffer.byteLength
                        });

                        // Convert ArrayBuffer to plain Array that msgreader.js expects
                        const uint8View = new Uint8Array(arrayBuffer);
                        const plainArray = Array.from(uint8View);
                        
                        // Validate we have actual numeric data
                        if (plainArray.length === 0) {
                            throw new Error('File conversion failed - no data extracted.');
                        }
                        
                        // Check OLE signature (should start with D0 CF 11 E0 or 0E 11 FC 0D)
                        const signature = plainArray.slice(0, 8);
                        const isValidOLE = (
                            (signature[0] === 0xD0 && signature[1] === 0xCF && signature[2] === 0x11 && signature[3] === 0xE0) ||
                            (signature[0] === 0x0E && signature[1] === 0x11 && signature[2] === 0xFC && signature[3] === 0x0D)
                        );
                        
                        if (!isValidOLE) {
                            throw new Error('File does not appear to be a valid MSG/OFT file (invalid OLE signature). The file may be corrupted or is not an Outlook message file.');
                        }
                        
                        console.log('Parsing file with MsgReader...');
                        const fileData = window.MsgReader.read(plainArray);
                        console.log('Parse successful!');

                        DOMElements.resultSubject.value = fileData.getFieldValue('subject') || '';
                        DOMElements.resultBody.value = fileData.getFieldValue('body') || '';

                        const recipients = fileData.getFieldValue('recipients') || [];
                        DOMElements.resultTo.value = recipients.filter(r => r.recipientType === 1).map(r => r.recipientEmail || r.recipientEmailAddress).filter(Boolean).join(', ');
                        DOMElements.resultCc.value = recipients.filter(r => r.recipientType === 2).map(r => r.recipientEmail || r.recipientEmailAddress).filter(Boolean).join(', ');
                        DOMElements.resultBcc.value = recipients.filter(r => r.recipientType === 3).map(r => r.recipientEmail || r.recipientEmailAddress).filter(Boolean).join(', ');

                        DOMElements.outputWrapper.classList.add('hidden'); 
                        setTimeout(() => resizeResultBody(), 0);
                    } catch (err) {
                        console.error('File parsing error:', err);
                        
                        // Provide more helpful error messages
                        let userMessage = err.message;
                        if (err.name === 'CorruptFileError') {
                            userMessage = 'The MSG file appears to be corrupted or uses an unsupported format. ' + err.message;
                        } else if (err.message.includes('Root Entry not found')) {
                            userMessage = 'Unable to read the MSG file structure. The file may be corrupted, encrypted, or created by a newer version of Outlook that is not yet supported.';
                        } else if (err.message.includes('signature')) {
                            userMessage = 'This file is not a valid MSG/OFT file. Please ensure you are uploading an Outlook message file (.msg) or template file (.oft).';
                        }
                        
                        SafeUI.showModal('File Error', `<p>${userMessage}</p>`, [{label: 'OK'}]);
                    }
                };
                reader.onerror = () => {
                    SafeUI.showModal('File Error', '<p>File reading failed. Could not access file content.</p>', [{label: 'OK'}]);
                };
                reader.readAsArrayBuffer(file);
            } catch (e) {
                console.error('File operation failed:', e);
                SafeUI.showToast('File operation failed due to internal error.');
            }
        };

        const generateAndShowMailto = () => {
            const mailtoData = {
                to: DOMElements.resultTo.value.trim(),
                cc: DOMElements.resultCc.value.trim(),
                bcc: DOMElements.resultBcc.value.trim(),
                subject: DOMElements.resultSubject.value.trim(),
                body: DOMElements.resultBody.value 
            };

            const mailto = buildMailto(mailtoData);

            currentMailtoCommand = mailto; 
            DOMElements.resultMailto.value = mailto;
            DOMElements.resultLink.href = mailto;
            DOMElements.outputWrapper.classList.remove('hidden');
            
            const templateNameValue = DOMElements.saveTemplateName.value;
            if (!templateNameValue.trim() && !templateNameValue) {
                 DOMElements.saveTemplateName.value = (mailtoData.subject || 'New Template').replace(/[\r\n\t\/\\]/g, ' ').trim();
            }

            setTimeout(() => resizeResultMailto(), 0);
        };
        
        // ===================================================================
        // LIBRARY ACTION HANDLERS
        // ===================================================================
        
        const handleNewTemplate = () => {
            if (hasUnsavedEditorChanges()) {
                UIPatterns.confirmUnsavedChanges(() => {
                    clearEditorFields(); 
                    resizeResultBody(); 
                    showView('editor');
                });
                return;
            }

            clearEditorFields(); 
            resizeResultBody(); 
            showView('editor');
        };
        
        const handleNewFolder = () => {
            SafeUI.showModal('New Folder', createFolderModalHTML(), [ 
                {label: 'Cancel'},
                {label: 'Create', class: 'button-primary', callback: () => {
                    try { 
                        const nameInput = document.getElementById('folder-name-input');
                        const name = nameInput.value.trim();
                        
                        if (name.includes('/') || name.includes('\\')) {
                             return SafeUI.showValidationError('Invalid Name', 'Folder name cannot contain path separators (/, \\).', 'folder-name-input');
                        }

                        if (!SafeUI.validators.notEmpty(name)) {
                            return SafeUI.showValidationError('Invalid Name', 'Folder name cannot be empty.', 'folder-name-input');
                        }
                        
                        const container = getItemsInCurrentFolder();
                        if (validateUniqueInContainer(container, name, 'folder', 'folder-name-input')) {
                             return;
                        }
                        
                        container.push({
                            id: SafeUI.generateId(),
                            type: 'folder',
                            name: name,
                            children: []
                        });
                        saveState();
                        renderCatalogue();
                    } catch(e) {
                        console.error('Folder creation failed:', e);
                        SafeUI.showToast('Folder creation failed due to internal error.');
                    }
                }}
            ]);
        };
        
        const handleSaveToLibrary = () => {
            if (!currentMailtoCommand) {
                SafeUI.showValidationError('No Command Generated', 'Click "Generate Command" first.', 'btn-generate');
                return;
            }

            const name = DOMElements.saveTemplateName.value.trim();
            if (!SafeUI.validators.notEmpty(name)) {
                return SafeUI.showValidationError('Invalid Name', 'Template name cannot be empty.', 'save-template-name');
            }
            
            const container = getItemsInCurrentFolder();
            if (validateUniqueInContainer(container, name, 'item', 'save-template-name')) {
                return;
            }
            
            container.push({
                id: SafeUI.generateId(),
                type: 'item',
                name: name,
                mailto: currentMailtoCommand
            });
            saveState();
            SafeUI.showToast('Template saved!');
            showView('catalogue');
            renderCatalogue();
        };

        // ===================================================================
        // DATA MANAGEMENT HANDLERS (CSV)
        // ===================================================================
        
        const setupSettingsModal = () => {
            const pageDataHtml = `
                <button id="modal-export-csv-btn" class="button-base">Export Library (CSV)</button>
                <button id="modal-import-csv-btn" class="button-base">Import Library (CSV)</button>
            `;

            const onModalOpen = () => {
                CsvManager.setupExport({
                    exportBtn: document.getElementById('modal-export-csv-btn'),
                    headers: APP_CONFIG.CSV_HEADERS,
                    dataGetter: () => {
                        const csvData = [];
                        function walk(items, currentPath) {
                            for (const item of items) {
                                if (item.type === 'folder') {
                                    walk(item.children, currentPath + item.name + '/');
                                } else if (item.type === 'item') {
                                    const mailtoParts = parseMailto(item.mailto);
                                    const row = { name: item.name, path: currentPath };
                                    MAILTO_FIELDS.forEach(field => { row[field] = mailtoParts[field]; });
                                    csvData.push(row);
                                }
                            }
                        }
                        walk(state.library, '/');
                        if (csvData.length === 0) {
                             SafeUI.showToast("Library is empty, nothing to export.");
                             return []; 
                        }
                        return csvData;
                    },
                    filename: `${APP_CONFIG.NAME}-export.csv`
                });
                
                const validateCsvRow = (row, index) => {
                    if (!row.name || !row.name.trim()) {
                        return { error: `Row ${index + 2}: 'name' column is required.` };
                    }
                    if (!row.path || !CSV_PATH_REGEX.test(row.path.trim())) { 
                        return { error: `Row ${index + 2}: 'path' must be a valid folder path like /folder or /folder/subfolder` };
                    }
                    return { entry: row };
                };
                const confirmCsvImport = (validatedData, importErrors) => {
                    const summaryHtml = `<p>This will <strong>ADD ${validatedData.length} templates</strong> to your library. It will skip duplicates (same name in the same path).</p>
                                         ${importErrors.length > 0 ? `<p><strong>${importErrors.length} rows had errors and will be skipped.</strong></p>` : ''}
                                         <p>Do you want to continue?</p>`;
                    SafeUI.showModal("Confirm CSV Import", summaryHtml, [
                        { label: 'Cancel' },
                        { 
                            label: 'Import', 
                            class: 'button-primary', 
                            callback: () => {
                                let importedCount = 0;
                                let skippedCount = 0;
                                for (const row of validatedData) {
                                    const pathParts = row.path.split('/').filter(p => p.trim().length > 0); 
                                    let currentContainer = state.library;
                                    for (const part of pathParts) {
                                        let folder = currentContainer.find(i => i.type === 'folder' && i.name.toLowerCase() === part.toLowerCase());
                                        if (!folder) {
                                            folder = { id: SafeUI.generateId(), type: 'folder', name: part, children: [] };
                                            currentContainer.push(folder);
                                        }
                                        currentContainer = folder.children;
                                    }
                                    if (DataValidator.hasDuplicate(currentContainer, 'name', row.name)) {
                                        skippedCount++;
                                    } else {
                                        const newMailto = buildMailto(row);
                                        currentContainer.push({ id: SafeUI.generateId(), type: 'item', name: row.name.trim(), mailto: newMailto });
                                        importedCount++;
                                    }
                                }
                                if (importedCount > 0) { saveState(); renderCatalogue(); }
                                SafeUI.showToast(`Import complete. Added ${importedCount}, skipped ${skippedCount}.`);
                                SafeUI.hideModal(); 
                            }
                        }
                    ]);
                    return false; 
                };
                CsvManager.setupImport({
                    importBtn: document.getElementById('modal-import-csv-btn'),
                    headers: APP_CONFIG.CSV_HEADERS,
                    onValidate: validateCsvRow,
                    onConfirm: confirmCsvImport
                });
            };

            const onRestore = (dataToRestore) => {
                state.library = dataToRestore.library || [];
                currentFolderId = 'root';
                saveState();
                renderCatalogue();
            };

            window.SharedSettingsModal.init({
                buttonId: 'btn-settings',
                appName: APP_CONFIG.NAME,
                state: { library: state.library, version: state.version },
                pageSpecificDataHtml: pageDataHtml, 
                onModalOpen: onModalOpen,           
                onRestoreCallback: onRestore,
                itemValidators: {
                    library: []
                }
            });
        };


        // ===================================================================
        // EVENT LISTENERS
        // ===================================================================

        const attachEventListeners = () => {
            setupSettingsModal();

            // Catalogue View
            DOMElements.btnNewTemplate.addEventListener('click', handleNewTemplate);
            DOMElements.btnNewFolder.addEventListener('click', handleNewFolder);
            
            // Editor View
            DOMElements.btnEditorCancel.addEventListener('click', () => {
                if (hasUnsavedEditorChanges()) {
                    UIPatterns.confirmUnsavedChanges(() => {
                        showView('catalogue');
                        renderCatalogue();
                    });
                } else {
                    showView('catalogue');
                    renderCatalogue();
                }
            });

            DOMElements.btnGenerate.addEventListener('click', generateAndShowMailto);
            DOMElements.btnSaveToLibrary.addEventListener('click', handleSaveToLibrary);
            
            DOMElements.copyMailtoBtn.addEventListener('click', async () => {
                if (!currentMailtoCommand) {
                    SafeUI.showToast('No command to copy'); 
                    return;
                }
                const success = await SafeUI.copyToClipboard(currentMailtoCommand);
                SafeUI.showToast(success ? "Command copied to clipboard!" : "Failed to copy.");
            });
            
            // Setup Drag and Drop (Editor) (C26)
            DOMElements.uploadWrapper.addEventListener('dragenter', handleDragEnterOver);
            DOMElements.uploadWrapper.addEventListener('dragover', handleDragEnterOver);
            DOMElements.uploadWrapper.addEventListener('dragleave', handleDragLeave);
            DOMElements.uploadWrapper.addEventListener('drop', handleDrop);
            
            DOMElements.msgUpload.addEventListener('change', (e) => {
                if (e.target.files && e.target.files.length > 0) handleFile(e.target.files[0]);
            });

            // Event Delegation for Lists
            DOMElements.treeListContainer.addEventListener('click', (e) => {
                const itemEl = e.target.closest('.list-item');
                if (!itemEl) return;
                
                if (e.target.closest('.list-item-name')) {
                    return; 
                }
                
                e.preventDefault(); 

                const id = itemEl.dataset.id;
                // REFACTOR: Use findItemById to search the whole tree, not just current folder
                const item = findItemById(id); 
                if (!item) return;

                if (e.target.closest('.list-item-name-folder') || e.target.closest('.list-item-icon.folder')) {
                    if (item.type === 'folder') {
                        navigateToFolder(item.id); 
                    }
                    return;
                }

                const copyBtn = e.target.closest('.copy-btn');
                if (copyBtn) {
                    handleTreeItemCopy(item, copyBtn);
                    return;
                }
                
                // NEW FEATURE: Handle Move Button
                const moveBtn = e.target.closest('.move-btn');
                if (moveBtn) {
                    handleTreeItemMove(id, item);
                    return;
                }
                
                if (e.target.closest('.delete-btn')) {
                    handleTreeItemDelete(id, item);
                    return; 
                }
            });
            
            DOMElements.breadcrumbContainer.addEventListener('click', (e) => {
                 const link = e.target.closest('.breadcrumb-link');
                 if (link && link.dataset.id) {
                     const targetId = link.dataset.id;
                     if (targetId === 'root' || findItemById(targetId)) { 
                         navigateToFolder(targetId); 
                     } else {
                         console.warn('Folder not found, returning to root');
                         navigateToFolder('root'); 
                     }
                 }
            });
        };

        // Init
        const init = () => {
            if (!state.library || !Array.isArray(state.library)) { 
                console.error('State corrupted, resetting library'); 
                state.library = []; 
                saveState(); 
            }
            
            // Setup icons
            DOMElements.btnNewFolder.innerHTML = SafeUI.SVGIcons.plus + ICONS.folder; 

            // Setup textareas
            DOMHelpers.setupTextareaAutoResize(DOMElements.resultBody);
            DOMHelpers.setupTextareaAutoResize(DOMElements.resultMailto, 150);
            
            attachEventListeners();
            
            // Initial render
            showView('catalogue');
            renderCatalogue();
        };

        init();
    });
    </script>
</body>
</html>

