<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale-1.0">
    <title>Password Generator</title>
    <link rel="stylesheet" href="style.css">
</head>
<body class="lookup-page"> <!-- Use lookup-page styles for layout -->

    <div id="navbar-container"></div>

    <div class="container">
        <header class="lookup-header">
            <div class="header-top-row">
                <h1>Password Generator</h1>
                <div class="header-actions">
                    <button id="btn-import-csv" class="button-base" title="Import Word Banks from CSV">Import</button>
                    <button id="btn-export-csv" class="button-base" title="Export Word Banks to CSV">Export</button>
                    <button id="btn-settings" class="icon-btn" title="Settings"></button>
                </div>
            </div>
            <div class="search-controls">
                <select id="generator-select" class="sidebar-input">
                    <option value="passphrase">Secure Passphrase Generator</option>
                    <option value="temp">Temporary Password Generator</option>
                </select>
                <button id="btn-generate" class="button-base button-primary" style="min-width: 100px;">Generate</button>
            </div>
        </header>

        <main class="results-container">
            <!-- Left Column: Generator Configuration -->
            <section class="column" id="config-column">
                <div id="passphrase-config" class="config-wrapper">
                    <h2>Secure Passphrase Options</h2>
                    <div class="app-section-box">
                        <div class="form-group">
                            <label for="pass-num-words"># Words (2-4)</label>
                            <select id="pass-num-words" class="sidebar-input">
                                <option value="2">2</option>
                                <option value="3" selected>3</option>
                                <option value="4">4</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="pass-separator">Separator</label>
                            <select id="pass-separator" class="sidebar-input">
                                <option value="-">-</option>
                                <option value="_">_</option>
                                <option value=" ">space</option>
                                <option value="" selected>None (TitleCase)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="pass-capitalization">Capitalization</label>
                            <select id="pass-capitalization" class="sidebar-input">
                                <option value="caps" selected>Title Case</option>
                                <option value="lower">lowercase</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="pass-num-digits"># Digits (0-9)</label>
                            <input type="number" id="pass-num-digits" value="2" min="0" max="9" class="sidebar-input">
                        </div>
                        <div class="form-group">
                            <label for="pass-num-symbols"># Symbols (0-4)</label>
                            <input type="number" id="pass-num-symbols" value="1" min="0" max="4" class="sidebar-input">
                        </div>
                        <div class="form-group">
                            <label for="pass-min-length">Min Length (8-64)</label>
                            <input type="number" id="pass-min-length" value="12" min="8" max="64" class="sidebar-input">
                        </div>
                        <div class="form-group">
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="checkbox" id="pass-use-seasonal" checked style="width: auto; margin: 0 0.5rem 0 0;">
                                <span>Use Seasonal Theme</span>
                            </label>
                        </div>
                    </div>
                </div>

                <div id="temp-config" class="config-wrapper hidden">
                    <h2>Temporary Password Options</h2>
                    <div class="app-section-box">
                        <div class="form-group">
                            <label for="temp-pass-count"># Passwords (1-10)</label>
                            <input type="number" id="temp-pass-count" class="sidebar-input" value="5" min="1" max="10">
                        </div>
                        <div class="form-group">
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="checkbox" id="temp-pass-symbol" style="width: auto; margin: 0 0.5rem 0 0;">
                                <span>Add random symbol (!, ?, $, %)</span>
                            </label>
                        </div>
                        <div class="form-group">
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="checkbox" id="temp-pass-random-num" style="width: auto; margin: 0 0.5rem 0 0;">
                                <span>Use random number (instead of '1')</span>
                            </label>
                        </div>
                    </div>
                </div>
            </section>
            
            <!-- Right Column: Results -->
            <section class="column" id="results-column">
                <div class="local-header">
                    <h2>Generated Passwords</h2>
                    <span id="results-count" class="form-help" style="margin: 0;"></span>
                </div>
                <ul id="results-list" class="result-list"></ul>
            </section>
        </main>
    </div>

    <div id="toast" class="toast"></div>
    <div id="modal-overlay" class="modal-overlay">
        <div id="modal-content" class="modal-content"></div>
    </div>

    <!-- FIX: Correct path to js/ subfolder -->
    <script src="js/app-core.js"></script>
    <script src="js/app-ui.js"></script>
    <script src="js/app-data.js"></script>
    <script>
    // FIX: Use non-destructive error banner instead of wiping DOM
    (() => {
        const dependencies = ['SafeUI', 'UIPatterns', 'ListRenderer', 'SearchHelper', 'BackupRestore', 'DataValidator', 'DataConverter', 'CsvManager'];
        const missing = dependencies.filter(dep => typeof window[dep] === 'undefined');
        
        if (missing.length > 0) {
            console.error("Critical dependencies missing:", missing);
            const title = "Application Failed to Load";
            const message = `One or more required JavaScript files (e.g., app-core.js, app-ui.js, app-data.js) failed to load. Missing: ${missing.join(', ')}`;
            
            // Create and inject a non-destructive banner
            const banner = document.createElement('div');
            banner.id = 'app-startup-error';
            banner.style.cssText = `position:sticky;top:0;left:0;width:100%;padding:1rem;background-color:#fef2f2;color:#dc2626;border-bottom:2px solid #fecaca;font-family:sans-serif;font-size:1rem;font-weight:600;z-index:10000;box-sizing:border-box;`;
            banner.innerHTML = `<strong>${title}</strong><p style="margin:0.25rem 0 0 0;font-weight:normal;">${message}</p>`;
            
            // Wait for DOM to be ready just in case, then prepend
            if (document.body) {
                document.body.prepend(banner);
            } else {
                document.addEventListener('DOMContentLoaded', () => document.body.prepend(banner));
            }
            
            // Throw error to stop further execution
            throw new Error(`Critical dependencies missing: ${missing.join(', ')}`);
        }
    })();


    const APP_CONFIG = {
        NAME: 'passwords',
        VERSION: '1.0.0',
        DATA_KEY: 'password_tool_v1_data',
        // CSV Headers will be dynamic based on word bank keys
    };

    AppLifecycle.run(async () => {

        // Default state includes the full word banks from the briefing
        const defaultState = {
            // Secure Passphrase Generator Data
            passphrase: {
                fullWordBank: {"Adjective":["Able","Ancient","Basic","Bent","Blank","Brave","Bold","Bumpy","Busy","Clever","Cloudy","Clumsy","Cranky","Curly","Dapper","Eager","Empty","Even","Fancy","Firm","Foggy","Fuzzy","Giant","Glad","Grand","Gritty","Harsh","Heavy","Humble","Jolly","Jumbo","Kind","Known","Large","Lavish","Lean","Major","Minor","Modern","Muddy","Odd","Plain","Quick","Rough","Royal","Sharp","Slim","Zany","Bright","Happy"],"Animal":["Badger","Bat","Beaver","Bison","Bobcat","Camel","Cat","Clam","Cobra","Colt","Coyote","Crow","Dingo","Dog","Dolphin","Dove","Dragon","Duck","Eel","Elk","Falcon","Fawn","Finch","Frog","Gecko","Goose","Grizzly","Guppy","Heron","Hornet","Hound","Jaguar","Koala","Llama","Mammoth","Moose","Moth","Newt","Otter","Panther","Parrot","Pony","Cougar","Rhino","Sloth","Stallion","Swan","Tadpole","Wasp","Wolf","Bear","Fox","Eagle"],"Object":["Anvil","Armor","Armchair","Backpack","Balloon","Banana","Barrel","Basket","Battery","Bell","Bench","Binder","Blanket","Bongo","Book","Booklet","Boulder","Bowl","Box","Bracelet","Bracket","Brick","Brush","Bubble","Bucket","Buckle","Bulb","Bumper","Button","Cabin","Cable","Camera","Candle","Canoe","Canvas","Carton","Castle","Harp","Chalk","Charger","Charm","Chart","Tool","Boat","Cup","Desk","Lamp","Door","Ball"],"Verb":["Argue","Arise","Bake","Bathe","Bend","Blink","Blush","Bolt","Bounce","Bump","Carve","Chase","Chew","Clap","Clash","Climb","Cling","Cough","Cover","Cram","Crawl","Crouch","Cuddle","Dance","Dare","Dash","Daze","Dig","Dip","Dive","Dodge","Drain","Drench","Drill","Drip","Droop","Drop","Drum","Dump","Dust","Gasp","Grab","Press","Scold","Slice","Thump","Tussle","Run","Jump","Sing","Hop","Spin"],"Color":["Amber","Blue","Bronze","Brown","Coral","Cyan","Emerald","Gold","Green","Indigo","Jade","Lavender","Lime","Maroon","Mint","Navy","Olive","Pink","Plum","Purple","Red","Rose","Ruby","Silver","Teal","Violet","White","Yellow","Tan","Gray","Peach","Aqua"],
                "Winter":{"Noun":["Blizzard","Chill","Flake","Frost","Glacier","Hearth","Ice","Icicle","Igloo","Mountain","Pine","Skate","Sled","Snow","Storm","Tundra","Yle"],"Adjective":["Barren","Bitter","Bleak","Brisk","Frigid","Frozen","Glacial","Icy","Hushed","Quiet","Still","Snowy","Chilly"],"Verb":["Drift","Fall","Freeze","Huddle","Melt","Nip","Shiver","Settle","Shine"],"Concept":["Calm","Peace","Silence","Spirit","Legend","Mystery"]},
                "Spring":{"Noun":["April","Blossom","Breeze","Bud","Bulb","Butterfly","Chick","Clover","Crocus","Daffodil","Egg","Equinox","Garden","Lamb","Meadow","Nest","Rabbit","Rainbow","Robin","Seed","Tulip","Rose","Rain"],"Adjective":["Alive","Blooming","Budding","Cheerful","Clean","Dewy","Early","Fresh","Gentle","Green","Growing","Hopeful","Lively","Mild","New","Vibrant","Young"],"Verb":["Bloom","Bud","Burst","Chirp","Emerge","Grow","Hatch","Open","Peep","Sprout","Wake"],"Concept":["Anticipation","Awakening","Beginning","Bloom","Growth","Hope","Freshness","Youth"]},
                "Summer":{"Noun":["August","Beach","Campfire","Canoe","Cicada","Cricket","Festival","Firefly","Hammock","Heat","July","June","Lemonade","Ocean","Picnic","Pool","Sandal","Solstice","Sprinkler","Sunshine","Tent","Sun"],"Adjective":["Balmy","Bright","Carefree","Drowsy","Golden","Hazy","Hot","Humid","Light","Long","Lush","Ripe","Sandy","Sizzling","Sunny","Warm"],"Verb":["Dive","Doze","Explore","Float","Grill","Lounge","Relax","Shine","Sizzle","Splash","Swim","Travel"],"Concept":["Adventure","Bliss","Ease","Freedom","Fun","Glow","Happiness","Journey","Leisure"]},
                "Autumn":{"Noun":["Acorn","Apple","Cider","Corn","Fall","Foliage","Gourd","Harvest","Hay","Leaf","Maple","Orchard","Pumpkin","Spice","Sweater","Wood"],"Adjective":["Blustery","Chilly","Cool","Cozy","Crimson","Dim","Dry","Golden","Mellow","Orange","Quiet","Rustic","Leafy"],"Verb":["Bake","Change","Chill","Cool","Crunch","Fade","Gather","Glow","Rustle"],"Concept":["Calm","Change","Comfort","Cycle","Dusk","Memory","Thought","Joy"]}},
                phraseStructures: {"standard":{"2":[["Adjective","Animal"],["Adjective","Object"],["Color","Object"],["Color","Animal"],["Verb","Animal"],["Animal","Object"],["Object","Object"]],"3":[["Adjective","Color","Animal"],["Verb","Adjective","Object"],["Adjective","Object","Verb"]],"4":[["Adjective","Animal","Color","Verb"],["Color","Adjective","Object","Verb"]]},"seasonal":{"2":[["SeasonAdjective","Object"],["Adjective","SeasonNoun"],["SeasonVerb","Animal"],["Color","SeasonNoun"],["SeasonVerb","Object"],["Color","SeasonConcept"],["SeasonNoun","Animal"]],"3":[["Adjective","Color","SeasonConcept"],["SeasonAdjective","Verb","Object"],["Verb","Adjective","SeasonNoun"]],"4":[["Adjective","Verb","Color","SeasonNoun"],["SeasonAdjective","Adjective","Object","Verb"]]}},
                symbolRules: {"beforeNum":["$","#","*"],"afterNum":["%","+"],"junction":["=","@",".","-"],"end":["!","?"]}
            },
            // Temporary Password Generator Data
            temp: {
                wordList: ["Applebutter","Appleslicer","Automobiles","Backpackers","Beachcomber","Biographies","Blackmarker","Bluebonnets","Blueberries","Bluehorizon","Bookkeepers","Breadbasket","Brightlight","Broadstreet","Brotherhood","Buttercream","Butterflies","Calculators","Campgrounds","Candlestick","Caterpillar","Cheesemaker","Cheesesteak","Cherrycider","Cherrypatch","Cherrytrees","Ciderdonuts","Coffeebeans","Coffeehouse","Dragonflies","Fingerprint","Firefighter","Firestation","Fishmongers","Flashlights","Fluteplayer","Footbridges","Gardenhouse","Gingersnaps","Goldfinches","Goldenapple","Grandfather","Grandmother","Grasshopper","Greenhouses","Grizzlybear","Handwriting","Helicopters","Hummingbird","Icecreamery","Instruments","Ironworkers","Jellydonuts","Killerwhale","Libertybell","Lightheaded","Lighthouses","Loudspeaker","Mapledonuts","Mapleforest","Marshmallow","Mockingbird","Motorcycles","Nightrunner","Paperbridge","Papermakers","Paperweight","Peacemakers","Peppergrass","Pharmacists","Phonenumber","Photographs","Pineneedles","Polarbreeze","Powerhouses","Preschooler","Quickstride","Quicksprint","Rainbowfish","Rattlesnake","Refrigerate","Restaurants","Rivermarket","Rivervalley","Rollerblade","Salamanders","Sandcastles","Schoolhouse","Scratchcard","Scratchpads","Screwdriver","Silvermaple","Skateboards","Skyscrapers","Smartphones","Snowleopard","Softpretzel","Springwater","Stonebridge","Storyteller","Sugarcookie","Sunrisepark","Switchboard","Televisions","Thermometer","Thermostats","Toothpastes","Typewriters","Valleyparks","Waterbottle","Waterlilies","Wildflowers","Windowpanes","Woodpeckers","Workbenches","Yellowfinch","Yellowstone"],
                symbols: ['!','?','$','%']
            }
        };

        const ctx = await AppLifecycle.initPage({
            storageKey: APP_CONFIG.DATA_KEY,
            defaultState: defaultState,
            version: APP_CONFIG.VERSION,
            requiredElements: [
                'navbar-container', 'toast', 'modal-overlay', 'modal-content',
                'generator-select', 'btn-generate', 'btn-import-csv', 'btn-export-csv', 'btn-settings',
                'passphrase-config', 'temp-config',
                'pass-num-words', 'pass-separator', 'pass-capitalization', 'pass-num-digits', 'pass-num-symbols', 'pass-min-length', 'pass-use-seasonal',
                'temp-pass-count', 'temp-pass-symbol', 'temp-pass-random-num',
                'results-list', 'results-count'
            ]
        });

        if (!ctx) return;

        let { elements: DOMElements, state, saveState: originalSaveState } = ctx;
        
        // Use non-sorting save for generators
        const saveState = () => {
            try {
                originalSaveState();
            } catch (e) {
                console.error("Failed to save state:", e);
                SafeUI.showModal("Error", "<p>Failed to save data. Storage might be full.</p>", [{label: 'OK'}]);
            }
        }
        
        // ====================================================================
        //  Generator Logic (Adapted from Briefing)
        // ====================================================================

        // Crypto-safe random number helpers
        const getRand = (m) => {
            const r = new Uint32Array(1);
            window.crypto.getRandomValues(r);
            return r[0] % m;
        }
        const R = (a) => a[getRand(a.length)];

        /**
         * Generates a list of secure passphrases
         */
        function generateSecurePassphrases() {
            const C = { // Config from DOM
                w: parseInt(DOMElements.passNumWords.value, 10),
                t: DOMElements.passUseSeasonal.checked,
                s: DOMElements.passSeparator.value,
                c: DOMElements.passCapitalization.value,
                d: parseInt(DOMElements.passNumDigits.value, 10),
                y: parseInt(DOMElements.passNumSymbols.value, 10),
                m: parseInt(DOMElements.passMinLength.value, 10)
            };
            
            const W = state.passphrase; // Word banks from state

            // Determine season (from briefing logic)
            const season = C.t ? (d => {
                const Y = d.getFullYear();
                function getMemorialDay(y) { const date = new Date(y, 4, 31); date.setDate(date.getDate() - (date.getDay() + 6) % 7); return date; } // Corrected month (0-indexed)
                function getLaborDay(y) { const date = new Date(y, 8, 1); const dayOfWeek = date.getDay(); const offset = (dayOfWeek <= 1) ? 1 - dayOfWeek : 8 - dayOfWeek; date.setDate(date.getDate() + offset); return date; }
                
                const memorialDay = getMemorialDay(Y);
                const laborDay = getLaborDay(Y);
                const springOfficialStart = new Date(Y, 2, 17);
                const summerOfficialStart = memorialDay;
                const autumnOfficialStart = laborDay;
                const winterOfficialStart = new Date(Y, 11, 1);
                
                const springStart = new Date(springOfficialStart.getTime() - 7 * 24 * 60 * 60 * 1000);
                const springEnd = new Date(summerOfficialStart.getTime() - 60 * 24 * 60 * 60 * 1000); // Typo from briefing (was 60*), corrected to 1*
                const summerStart = new Date(summerOfficialStart.getTime() - 7 * 24 * 60 * 60 * 1000);
                const summerEnd = new Date(autumnOfficialStart.getTime() - 60 * 24 * 60 * 60 * 1000); // Typo from briefing (was 60*), corrected to 1*
                const autumnStart = new Date(autumnOfficialStart.getTime() - 7 * 24 * 60 * 60 * 1000);
                const autumnEnd = new Date(winterOfficialStart.getTime() - 60 * 24 * 60 * 60 * 1000); // Typo from briefing (was 60*), corrected to 1*
                const winterStart = new Date(winterOfficialStart.getTime() - 7 * 24 * 60 * 60 * 1000);
                const winterEnd = new Date(springOfficialStart.getTime() - 60 * 24 * 60 * 60 * 1000); // Typo from briefing (was 60*), corrected to 1*

                if (d >= springStart && d <= springEnd) return 'Spring';
                if (d >= summerStart && d <= summerEnd) return 'Summer';
                if (d >= autumnStart && d <= autumnEnd) return 'Autumn';
                if (d >= winterStart || d <= winterEnd) return 'Winter';
                return null;
            })(new Date()) : null;

            let allPasses = [];
            for (let i = 0; i < 5; i++) { // Generate 5 options
                let words = [];
                const P = W.phraseStructures;
                let struct;

                if (season && P.seasonal && P.seasonal[C.w]) {
                    struct = R(P.seasonal[C.w]);
                } else if (P.standard && P.standard[C.w]) {
                    struct = R(P.standard[C.w]);
                } else {
                    struct = ['Adjective', 'Animal']; // Fallback
                }
                
                words = struct.map(cat => {
                    if (cat.startsWith('Season')) {
                        const sCat = cat.replace('Season', '');
                        return R(W.fullWordBank[season][sCat]);
                    }
                    return R(W.fullWordBank[cat]);
                });

                if (C.c === 'caps') {
                    words = words.map(s => s.charAt(0).toUpperCase() + s.slice(1).toLowerCase());
                } else if (C.c === 'lower') {
                    words = words.map(w => w.toLowerCase());
                }

                let wordStr = words.join(C.s);
                let numberBlock = [];
                for (let j = 0; j < C.d; j++) {
                    numberBlock.push(getRand(10));
                }
                
                let symbolsToUse = { beforeNum: '', afterNum: '', junction: '', end: '' };
                let preliminaryLength = wordStr.length + numberBlock.length;
                let paddingNeeded = Math.max(0, C.m - preliminaryLength);
                let willHaveNumbers = (numberBlock.length + paddingNeeded) > 0;

                if (C.y > 0) {
                    let availableTypes = ['end', 'junction'];
                    if (willHaveNumbers) {
                        availableTypes.push('beforeNum', 'afterNum');
                    }
                    // Shuffle available types
                    for (let k = availableTypes.length - 1; k > 0; k--) {
                        const l = getRand(k + 1);
                        [availableTypes[k], availableTypes[l]] = [availableTypes[l], availableTypes[k]];
                    }
                    for (let j = 0; j < C.y; j++) {
                        if (availableTypes.length === 0) break;
                        let type = availableTypes.shift();
                        if (type) {
                            symbolsToUse[type] = R(W.symbolRules[type]);
                        }
                    }
                }
                
                let currentLength = wordStr.length + numberBlock.length + Object.values(symbolsToUse).join('').length;
                paddingNeeded = Math.max(0, C.m - currentLength);
                for (let j = 0; j < paddingNeeded; j++) {
                    numberBlock.push(getRand(10));
                }

                let numberPart = symbolsToUse.beforeNum + numberBlock.join('') + symbolsToUse.afterNum;
                let finalPass;
                
                if (getRand(2) === 0 && numberPart) {
                    finalPass = numberPart + symbolsToUse.junction + wordStr + symbolsToUse.end;
                } else {
                    finalPass = wordStr + symbolsToUse.junction + numberPart + symbolsToUse.end;
                }
                allPasses.push(finalPass);
            }
            return allPasses;
        }

        /**
         * Generates a list of temporary passwords
         */
        function generateTempPasswords() {
            const C = { // Config from DOM
                count: parseInt(DOMElements.tempPassCount.value, 10),
                addSymbol: DOMElements.tempPassSymbol.checked,
                randomNum: DOMElements.tempPassRandomNum.checked
            };
            const W = state.temp.wordList;
            const S = state.temp.symbols;

            let passes = [];
            for (let i = 0; i < C.count; i++) {
                let p = R(W);
                p += C.randomNum ? getRand(10) : '1';
                if (C.addSymbol) {
                    p += R(S);
                }
                passes.push(p);
            }
            return passes;
        }
        
        // ====================================================================
        //  UI / Event Handlers
        // ====================================================================

        /**
         * Renders the generated passwords to the results list
         */
        function renderResults(passwords) {
            DOMElements.resultsCount.textContent = `${passwords.length} results`;
            ListRenderer.renderList({
                container: DOMElements.resultsList,
                items: passwords,
                emptyMessage: "Click 'Generate' to create passwords.",
                createItemElement: (pass) => {
                    const li = document.createElement('li');
                    li.className = 'result-item'; // Re-use lookup style
                    li.innerHTML = `
                        <div class="item-grid" style="grid-template-columns: 1fr auto;">
                            <div style="font-family: monospace; font-size: 0.9rem; user-select: text; word-break: break-all;">${SafeUI.escapeHTML(pass)}</div>
                            <button class="btn-copy icon-btn" title="Copy Password" data-copy="${SafeUI.escapeHTML(pass)}">ðŸ“‹</button>
                        </div>
                    `;
                    return li;
                }
            });
        }
        
        /**
         * Main generate button click handler
         */
        function handleGenerateClick() {
            const generatorType = DOMElements.generatorSelect.value;
            let results = [];
            try {
                if (generatorType === 'passphrase') {
                    results = generateSecurePassphrases();
                } else {
                    results = generateTempPasswords();
                }
                renderResults(results);
            } catch (err) {
                console.error("Password generation failed:", err);
                SafeUI.showModal("Generation Error", `<p>${SafeUI.escapeHTML(err.message)}</p>`, [{label: 'OK'}]);
            }
        }

        /**
         * Toggles the visible configuration panel
         */
        function toggleConfigPanel() {
            const generatorType = DOMElements.generatorSelect.value;
            if (generatorType === 'passphrase') {
                DOMElements.passphraseConfig.classList.remove('hidden');
                DOMElements.tempConfig.classList.add('hidden');
            } else {
                DOMElements.passphraseConfig.classList.add('hidden');
                DOMElements.tempConfig.classList.remove('hidden');
            }
        }
        
        // ====================================================================
        // CSV Import / Export
        // ====================================================================

        /**
         * Converts the complex word bank state into a flat array for CSV.
         */
        function stateToCsvArray() {
            const data = [];
            const { passphrase, temp } = state;
            
            // Add Passphrase words
            Object.keys(passphrase.fullWordBank).forEach(category => {
                if (Array.isArray(passphrase.fullWordBank[category])) {
                    passphrase.fullWordBank[category].forEach(word => {
                        data.push({ category: `passphrase.fullWordBank.${category}`, word: word });
                    });
                } else {
                    // Seasonal
                    Object.keys(passphrase.fullWordBank[category]).forEach(subCat => {
                         passphrase.fullWordBank[category][subCat].forEach(word => {
                            data.push({ category: `passphrase.fullWordBank.${category}.${subCat}`, word: word });
                        });
                    });
                }
            });
            
            // Add Temp words
            temp.wordList.forEach(word => {
                data.push({ category: 'temp.wordList', word: word });
            });
            
            // Add Symbols
            temp.symbols.forEach(word => {
                data.push({ category: 'temp.symbols', word: word });
            });
            
            // Add Passphrase symbols
             Object.keys(passphrase.symbolRules).forEach(category => {
                passphrase.symbolRules[category].forEach(word => {
                    data.push({ category: `passphrase.symbolRules.${category}`, word: word });
                });
            });
            
            return data;
        }

        /**
         * Validates a single row from the CSV.
         */
        function validateCsvRow(row, index) {
            const entry = {
                category: (row.category || '').trim(),
                word: (row.word || '').trim()
            };
            if (!entry.category || !entry.word) {
                return { valid: false, error: `Row ${index + 2}: 'category' and 'word' are required.` };
            }
            if (!entry.category.includes('.')) {
                 return { valid: false, error: `Row ${index + 2}: Invalid category format. Expected 'type.bank.list'.` };
            }
            return { valid: true, entry: entry };
        }

        /**
         * Performs the final import, rebuilding the state from the CSV data.
         */
        function confirmCsvImport(sanitizedData) {
            // 1. Create a new, empty state structure
            const newState = {
                passphrase: { fullWordBank: {}, phraseStructures: state.passphrase.phraseStructures, symbolRules: {} },
                temp: { wordList: [], symbols: [] }
            };

            // 2. Populate the new state from the CSV rows
            sanitizedData.forEach(item => {
                const parts = item.category.split('.');
                const type = parts[0]; // 'passphrase' or 'temp'
                const bank = parts[1]; // 'fullWordBank', 'symbolRules', 'wordList', 'symbols'
                const list = parts[2]; // 'Adjective', 'Winter', 'Noun', 'beforeNum', etc.
                const subList = parts[3]; // 'Noun', 'Adjective', etc. (for seasonal)

                if (type === 'passphrase') {
                    if (bank === 'fullWordBank') {
                        if (subList) { // Seasonal
                            if (!newState.passphrase.fullWordBank[list]) newState.passphrase.fullWordBank[list] = {};
                            if (!newState.passphrase.fullWordBank[list][subList]) newState.passphrase.fullWordBank[list][subList] = [];
                            newState.passphrase.fullWordBank[list][subList].push(item.word);
                        } else { // Standard
                            if (!newState.passphrase.fullWordBank[list]) newState.passphrase.fullWordBank[list] = [];
                            newState.passphrase.fullWordBank[list].push(item.word);
                        }
                    } else if (bank === 'symbolRules') {
                        if (!newState.passphrase.symbolRules[list]) newState.passphrase.symbolRules[list] = [];
                        newState.passphrase.symbolRules[list].push(item.word);
                    }
                } else if (type === 'temp') {
                    if (bank === 'wordList') {
                        newState.temp.wordList.push(item.word);
                    } else if (bank === 'symbols') {
                        newState.temp.symbols.push(item.word);
                    }
                }
            });
            
            // 3. Overwrite the main state
            state.passphrase.fullWordBank = newState.passphrase.fullWordBank;
            state.passphrase.symbolRules = newState.passphrase.symbolRules;
            state.temp.wordList = newState.temp.wordList;
            state.temp.symbols = newState.temp.symbols;
            
            saveState();
            SafeUI.showToast(`Imported ${sanitizedData.length} words across all banks.`);
        }
        
        // ====================================================================
        // Settings Modal (for JSON Backup/Restore)
        // ====================================================================

        function showSettingsModal() {
            BackupRestore.setupBackupRestoreHandlers({
                settingsBtn: DOMElements.btnSettings,
                state: state,
                appName: APP_CONFIG.NAME,
                itemValidators: {
                    passphrase: [], // Just check that keys exist
                    temp: []
                },
                restoreConfirmMessage: 'Overwrite ALL password generator data (word banks, symbols, rules)? This cannot be undone.',
                onRestore: (dataToRestore) => {
                    // This is the page-specific restore logic
                    state.passphrase = dataToRestore.passphrase || defaultState.passphrase;
                    state.temp = dataToRestore.temp || defaultState.temp;
                    saveState();
                    SafeUI.hideModal(); // Close settings modal
                    SafeUI.showToast('Password data restored.');
                }
            });
            
            // Show the modal
            SafeUI.showModal("Settings", 
                `<div class="form-group">
                    <label>Advanced Data Management (JSON)</label>
                    <p class="form-help">Use these tools for disaster recovery. "Import/Export" (on the main page) is for managing word banks via CSV.</p>
                    <div class="button-group">
                        <button id="modal-backup-btn" class="button-base">Backup (JSON)</button>
                        <button id="modal-restore-btn" class="button-base">Restore (JSON)</button>
                    </div>
                </div>`,
                [{ label: 'Close' }]
            );

            // Attach listeners to modal-specific buttons
            document.getElementById('modal-backup-btn').addEventListener('click', () => {
                BackupRestore.createBackup(state, APP_CONFIG.NAME);
            });
            document.getElementById('modal-restore-btn').addEventListener('click', () => {
                BackupRestore.handleRestoreUpload(); // Will trigger the handler set up by setupBackupRestoreHandlers
            });
        }

        // ====================================================================
        //  INIT
        // ====================================================================
        
        function init() {
            // Load SVG icons
            DOMElements.btnSettings.innerHTML = SafeUI.SVGIcons.settings;

            // Wire up event listeners
            DOMElements.generatorSelect.addEventListener('change', toggleConfigPanel);
            DOMElements.btnGenerate.addEventListener('click', handleGenerateClick);
            DOMElements.btnSettings.addEventListener('click', showSettingsModal);
            
            // Wire up copy-to-clipboard delegation
            DOMElements.resultsList.addEventListener('click', async (e) => {
                const copyBtn = e.target.closest('.btn-copy');
                if (copyBtn) {
                    const success = await SafeUI.copyToClipboard(copyBtn.dataset.copy);
                    SafeUI.showToast(success ? "Copied to clipboard!" : "Failed to copy.");
                }
            });

            // Wire up CSV Import/Export
            CsvManager.setupExport(
                DOMElements.btnExportCsv,
                stateToCsvArray, // Get data function
                ['category', 'word'], // Headers
                'password-word-banks.csv'
            );
            
            CsvManager.setupImport({
                importBtn: DOMElements.btnImportCsv,
                headers: ['category', 'word'],
                onValidateRow: validateCsvRow,
                onConfirmImport: confirmCsvImport,
                confirmMessage: `This will Do you want to <strong>overwrite all word banks</strong> with data from this file? This cannot be undone.`
            });

            // Initial setup
            toggleConfigPanel();
            renderResults([]); // Show empty state
            SafeUI.loadNavbar("navbar-container");
        }

        init();
    });
    </script>
</body>
</html>

