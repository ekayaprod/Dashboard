<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Passwords</title>
    <link rel="stylesheet" href="style.css">
</head>
<body class="passwords-page">

    <div id="navbar-container"></div>

    <div class="app-container">
        <div class="panel">
            <div class="main-content">
                <div id="app-startup-error" class="hidden sticky-banner"></div>

                <header class="section-header-wrapper header-wrapper-padded">
                    <h3 class="section-header">Password Generator</h3>
                    <div class="header-actions button-group">
                        <button id="btn-settings" class="icon-btn" title="Settings"></button>
                    </div>
                </header>

                <div class="generator-section">
                    <button id="btn-quick-generate-temp" class="btn-full-width-padded button-primary">
                        Generate Temporary Password
                    </button>
                </div>

                <div class="generator-section">
                    <div class="section-header-wrapper section-header-bottom-margin">
                        <h3 class="section-header">Quick Actions</h3>
                        <div class="button-group">
                            <button id="btn-add-preset" class="button-base button-primary" title="Save current settings as a new preset">
                                Save Preset
                            </button>
                            <button id="btn-add-quick-copy" class="button-base" title="Add static password">
                                Add Quick Copy
                            </button>
                        </div>
                    </div>
                    <div id="quick-actions-container" class="shortcuts-container"></div>
                </div>
                
                <div class="generator-section">
                    <div class="accordion-header" id="custom-gen-header" role="button" aria-expanded="true" aria-controls="custom-generator-config">
                        <h3 class="section-header">Custom Generator</h3>
                        <button id="accordion-toggle" class="icon-btn" title="Toggle settings" tabindex="-1">
                            <span class="accordion-icon">▼</span>
                        </button>
                    </div>
                    
                    <div id="custom-generator-config" class="accordion-content">
                        <div id="tab-content-passphrase">
                            <div class="config-section">
                                <div class="config-grid-2col">
                                    <div class="form-group">
                                        <label for="passNumWords">Words</label>
                                        <select id="passNumWords" class="sidebar-input">
                                            <option value="0">0</option>
                                            <option value="1">1</option>
                                            <option value="2">2</option>
                                            <option value="3" selected>3</option>
                                            <option value="4">4</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label for="passNumDigits">Digits</label>
                                        <input type="number" id="passNumDigits" value="1" min="0" max="9" class="sidebar-input">
                                    </div>

                                    <div class="form-group">
                                        <label for="passNumSymbols">Symbols</label>
                                        <input type="number" id="passNumSymbols" value="0" min="0" max="4" class="sidebar-input">
                                    </div>
                                    <div class="form-group">
                                        <label for="passSeparator">Sep.</label>
                                        <select id="passSeparator" class="sidebar-input"><option value="-">-</option><option value="_">_</option><option value=" ">spc</option><option value="" selected>None</option></select>
                                    </div>

                                    <div class="form-group">
                                        <label for="passMinLength">Min</label>
                                        <input type="number" id="passMinLength" value="10" min="4" max="64" class="sidebar-input">
                                    </div>
                                    <div class="form-group">
                                        <label for="passMaxLength">Max</label>
                                        <input type="number" id="passMaxLength" value="20" min="4" max="64" class="sidebar-input">
                                    </div>

                                    <div class="form-group">
                                        <label for="seasonal-bank-select">Theme</label>
                                        <select id="seasonal-bank-select" class="sidebar-input">
                                            <option value="auto" selected>Auto</option>
                                            <option value="none">None</option>
                                            <option value="winter">Winter</option>
                                            <option value="spring">Spring</option>
                                            <option value="summer">Summer</option>
                                            <option value="autumn">Autumn</option>
                                        </select>
                                    </div>
                                    <label class="checkbox-label checkbox-label-padded">
                                        <input type="checkbox" id="passPadToMin">
                                        <span>Pad</span>
                                    </label>
                                </div>
                            </div>
                        
                            <div class="generate-actions">
                                <button id="btn-generate" class="button-base button-primary btn-generate-padded">Generate</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="results-wrapper generator-section">
                    <ul id="results-list" class="result-list">
                        <div class="empty-state-message">
                            Click "Generate" or a button above.
                        </div>
                    </ul>
                </div>

            </div>
        </div>
    </div>

    <div id="toast" class="toast"></div>
    <div id="modal-overlay" class="modal-overlay">
        <div id="modal-content" class="modal-content"></div>
    </div>
    
    <!-- Scroll to Top Button -->
    <button id="scroll-to-top" class="scroll-to-top-btn" title="Back to Top">↑</button>

    <!-- 
      CRITICAL: Bootstrap script must be at the END of the body.
      It loads the Navbar HTML and all JS dependencies in parallel.
    -->
    <script src="js/bootstrap.js"></script>

    <script>
    // Wait for bootstrap, but timeout if it fails
    let bootstrapReady = false;

    document.addEventListener('bootstrap:ready', () => {
        bootstrapReady = true;
        initializePage();
    });

    // Fallback: If bootstrap doesn't fire within 5 seconds, show error
    setTimeout(() => {
        if (!bootstrapReady) {
            console.error('Bootstrap did not complete within 5 seconds');
            const banner = document.createElement('div');
            banner.className = 'app-startup-banner'; // Use app-startup-banner for consistency
            banner.style.cssText = "position: fixed; top: 0; left: 0; width: 100%; padding: 1rem; background-color: #fef2f2; color: #dc2626; border-bottom: 2px solid #fecaca; font-family: sans-serif; z-index: 10000;";
            banner.innerHTML = `
                <strong>Application Startup Timeout</strong>
                <p>The application failed to load within 5 seconds. Check the browser console for errors.</p>
            `;
            if(document.body) document.body.insertBefore(banner, document.body.firstChild);
        }
    }, 5000);

    // This function now holds all the page logic, just like your other pages
    function initializePage() {
        // FIX: Wrap all logic in the self-invoking async function
        (async () => {
            try {
                // 1. Dependency Check
                const dependencies = ['SafeUI', 'UIPatterns', 'ListRenderer', 'SearchHelper', 'BackupRestore', 'DataValidator', 'DataConverter', 'CsvManager', 'QuickListManager', 'SharedSettingsModal', 'DataHelpers', 'AppLifecycle'];
                const missing = dependencies.filter(dep => typeof window[dep] === 'undefined');
                if (missing.length > 0) {
                    const errorTitle = "Application Failed to Load";
                    const errorMessage = `One or more required JavaScript files failed to load. Missing: ${missing.join(', ')}`;
                    console.error(errorMessage);
                    
                    // Use the standard error banner
                    const banner = document.getElementById('app-startup-error');
                    if(banner) {
                        banner.innerHTML = `<strong>${errorTitle}</strong><p style="margin:0.25rem 0 0 0;font-weight:normal;">${errorMessage}</p>`;
                        banner.classList.add('sticky-banner'); // or 'app-startup-banner'
                        banner.classList.remove('hidden');
                    }
                    throw new Error(`Critical dependencies missing: ${missing.join(', ')}`);
                }

                // 2. Define Configs and Defaults
                const APP_CONFIG = {
                    NAME: 'passwords',
                    VERSION: '1.5.0',
                    DATA_KEY: 'passwords_v1_data',
                };
                
                console.log(`[Passwords] v${APP_CONFIG.VERSION} initialized`);

                const defaultPhraseStructures = {
                    "standard": {
                        "1": [["Compound"]], 
                        "2": [["Adjective","Animal"],["Color","Object"]],
                        "3": [["Adjective","Color","Animal"]],
                        "4": [["Adjective","Animal","Color","Verb"]]
                    },
                    "seasonal": {
                        "1": [["Noun"]], 
                        "2": [["Adjective","Noun"]],
                        "3": [["Adjective","Verb","Object"]],
                        "4": [["Adjective","Verb","Color","Noun"]]
                    }
                };
                
                const defaultSymbolRules = {"beforeNum":["$","#","*"],"afterNum":["%","+"],"junction":["=","@",".","-"],"end":["!","?"]};

                const defaultState = {
                    wordBank: null,       
                    phraseStructures: defaultPhraseStructures,
                    symbolRules: defaultSymbolRules,
                    quickCopyItems: [],
                    generatorPresets: [],
                    settings: {},
                    ui: {
                        passNumWords: 2,
                        passSeparator: '',
                        passNumDigits: 1,
                        passNumSymbols: 0,
                        passMinLength: 12,
                        passMaxLength: 16,
                        passPadToMin: false,
                        seasonalBank: 'auto',
                        accordionCollapsed: false,
                        resultsScrollTop: 0
                    }
                };

                // 3. Call initPage to get context (ctx)
                // This is the correct pattern for pages loaded via bootstrap.js
                const ctx = await AppLifecycle.initPage({
                    storageKey: APP_CONFIG.DATA_KEY,
                    defaultState: defaultState,
                    version: APP_CONFIG.VERSION,
                    requiredElements: [
                        'quick-actions-container', 'btn-add-quick-copy', 'btn-add-preset',
                        'btn-quick-generate-temp',
                        'tab-content-passphrase',
                        'passNumWords', 'passSeparator', 'seasonal-bank-select',
                        'passNumDigits', 'passNumSymbols', 
                        'passMinLength', 'passMaxLength', 'passPadToMin',
                        'btn-generate',
                        'results-list',
                        'btn-settings',
                        'toast', 'modal-overlay', 'modal-content',
                        'navbar-container',
                        'custom-gen-header', 'accordion-toggle', 'custom-generator-config'
                    ]
                });

                if (!ctx) return;

                // 4. All page logic now runs inside this async function
                let { elements: DOMElements, state, saveState } = ctx;
                let generatedPasswords = [];
                
                let activeWordBank = {}; 
                let availableStructures = {};

                const showError = (title, err) => {
                    console.error(title, err);
                    SafeUI.showModal(title, `<p>${SafeUI.escapeHTML(err.message || err)}</p>`, [{label: 'OK'}]);
                };

                // REFACTOR: Migrated accordion state to state.ui
                const toggleAccordion = (e) => {
                    if (e) {
                        if (e.target.closest('button') && e.currentTarget.id === 'custom-gen-header') {
                            e.stopPropagation();
                            return;
                        }
                        if (e.target.id === 'custom-gen-header' && e.currentTarget.id === 'accordion-toggle') {
                             e.stopPropagation();
                            return;
                        }
                    }

                    const content = DOMElements.customGeneratorConfig;
                    const icon = document.querySelector('.accordion-icon');
                    const header = DOMElements.customGenHeader;
                    const isCollapsed = content.classList.toggle('collapsed');
                    
                    if (icon) icon.style.transform = isCollapsed ? 'rotate(-90deg)' : 'rotate(0deg)';
                    if (header) header.setAttribute('aria-expanded', !isCollapsed);
                    
                    if (state.ui) {
                        state.ui.accordionCollapsed = isCollapsed;
                        saveState();
                    }
                };

                const initAccordion = () => {
                    // Check for old localStorage key and migrate if needed
                    const OLD_KEY = 'password_generator_accordion_collapsed';
                    if (localStorage.getItem(OLD_KEY)) {
                        const oldVal = localStorage.getItem(OLD_KEY) === 'true';
                        if (state.ui) {
                            state.ui.accordionCollapsed = oldVal;
                            saveState();
                        }
                        localStorage.removeItem(OLD_KEY);
                    }

                    let collapsed = state.ui ? state.ui.accordionCollapsed : false;
                    
                    const content = DOMElements.customGeneratorConfig;
                    const icon = document.querySelector('.accordion-icon');
                    const header = DOMElements.customGenHeader;

                    if (collapsed) {
                        content.classList.add('collapsed');
                        if (icon) icon.style.transform = 'rotate(-90deg)';
                        if (header) header.setAttribute('aria-expanded', 'false');
                    } else {
                        content.classList.remove('collapsed');
                        if (icon) icon.style.transform = 'rotate(0deg)';
                        if (header) header.setAttribute('aria-expanded', 'true');
                    }
                    
                    DOMElements.accordionToggle?.addEventListener('click', toggleAccordion);
                    DOMElements.customGenHeader?.addEventListener('click', toggleAccordion);
                };

                const getRand = (() => {
                    let cryptoAvailable = window.crypto && window.crypto.getRandomValues;
                    if (!cryptoAvailable) {
                        console.warn("Crypto API not available. Falling back to Math.random().");
                    }
                    
                    return (m) => {
                        if (cryptoAvailable) {
                            try {
                                const r = new Uint32Array(1);
                                window.crypto.getRandomValues(r);
                                return r[0] % m;
                            } catch (e) {
                                console.error("Crypto API failed, falling back to Math.random()", e);
                                cryptoAvailable = false;
                            }
                        }
                        return Math.floor(Math.random() * m);
                    };
                })();

                const R = (a) => a[getRand(a.length)];
                const Cap = (s) => s.charAt(0).toUpperCase() + s.slice(1).toLowerCase();

                const getSeason = (d) => {
                    const m = d.getMonth(); 
                    if (m === 11 || m === 0 || m === 1) return 'winter';
                    if (m >= 2 && m <= 4) return 'spring';
                    if (m >= 5 && m <= 7) return 'summer';
                    return 'autumn';
                };

                const generatePassphrase = (config) => {
                    const C = { ...config }; 
                    const P_structs = availableStructures; 
                    const W = activeWordBank;      
                    const SYMBOL_RULES = state.symbolRules;
                    const MAX_RETRIES = 500;
                    let retries = 0;

                    if (C.minLength > C.maxLength) return "[Min length > Max length]";
                    if (!C.passNumWords && !C.passNumDigits && !C.passNumSymbols) return "[No content selected]";

                    let resolvedSeason = C.seasonalBank;
                    if (C.seasonalBank === 'auto') resolvedSeason = getSeason(new Date());

                    let minEstimate = C.passNumDigits + C.passNumSymbols + (C.passNumWords * 4);
                    if (C.passNumWords > 1) minEstimate += (C.passNumWords - 1) * C.passSeparator.length;
                    if (minEstimate > C.maxLength) return "[Settings exceed Max Length]";

                    while (retries < MAX_RETRIES) {
                        retries++;
                        let words = [];
                        let struct;

                        if (resolvedSeason && resolvedSeason !== 'none' && P_structs.seasonal && P_structs.seasonal[C.passNumWords] && P_structs.seasonal[C.passNumWords].length > 0) {
                            struct = R(P_structs.seasonal[C.passNumWords]);
                        } else if (P_structs.standard && P_structs.standard[C.passNumWords] && P_structs.standard[C.passNumWords].length > 0) {
                            struct = R(P_structs.standard[C.passNumWords]);
                        }

                        if (!struct || struct.length === 0) {
                            if (C.passNumWords === 0) {
                                 struct = []; 
                            } else {
                                const fallbackCat = W['Object'] ? 'Object' : (W['Word'] ? 'Word' : 'Adjective');
                                if (!W[fallbackCat] || W[fallbackCat].length === 0) return "[No fallback words available]"; 
                                struct = Array(C.passNumWords).fill(fallbackCat);
                            }
                        }
                        
                        if (!struct && C.passNumWords > 0) return "[No valid word structure found]"; 

                        words = struct.map(cat => {
                            if (!W[cat] || W[cat].length === 0) {
                                const fallbackCat = W['Object'] ? 'Object' : 'Word';
                                return R(W[fallbackCat]); 
                            }
                            return R(W[cat]);
                        });

                        if (words.some(w => !w || w.length === 0)) continue;

                        let wordStr;
                        if (C.passSeparator === '') {
                            words = words.map(Cap);
                            wordStr = words.join('');
                        } else {
                            words = words.map(w => w.toLowerCase());
                            wordStr = words.join(C.passSeparator);
                        }

                        let numberBlock = [];
                        for (let j = 0; j < C.passNumDigits; j++) { numberBlock.push(getRand(10)); }

                        let preliminaryLength = wordStr.length + numberBlock.length + C.passNumSymbols; 
                        
                        if (C.padToMin && preliminaryLength < C.minLength) {
                            const paddingNeeded = C.minLength - preliminaryLength;
                            for (let j = 0; j < paddingNeeded; j++) { numberBlock.push(getRand(10)); }
                            preliminaryLength += paddingNeeded;
                        }

                        if (preliminaryLength > C.maxLength) continue;

                        let symbolsToUse = { beforeNum: '', afterNum: '', junction: '', end: '' };

                        if (C.passNumSymbols > 0) {
                            let availableTypes = ['end', 'junction'];
                            if (numberBlock.length > 0) { availableTypes.push('beforeNum', 'afterNum'); }
                            
                            for (let k = availableTypes.length - 1; k > 0; k--) {
                                const l = getRand(k + 1);
                                [availableTypes[k], availableTypes[l]] = [availableTypes[l], availableTypes[k]];
                            }
                            for (let j = 0; j < C.passNumSymbols; j++) {
                                if (availableTypes.length === 0) break;
                                let type = availableTypes.shift();
                                if (type && SYMBOL_RULES[type] && SYMBOL_RULES[type].length > 0) {
                                    const symbol = R(SYMBOL_RULES[type]);
                                    symbolsToUse[type] = symbol;
                                }
                            }
                        }

                        let numberPart = symbolsToUse.beforeNum + numberBlock.join('') + symbolsToUse.afterNum;
                        
                        let finalPass;
                        if (wordStr.length === 0) {
                            finalPass = numberPart + symbolsToUse.end;
                        } else {
                            finalPass = (getRand(2) === 0 && numberPart.length > 0) 
                                ? (numberPart + symbolsToUse.junction + wordStr) 
                                : (wordStr + symbolsToUse.junction + numberPart);
                            finalPass += symbolsToUse.end;
                        }

                        if (finalPass.length > C.maxLength) continue; 
                        if (!C.padToMin && finalPass.length < C.minLength) continue; 

                        return finalPass; 
                    }

                    return "[Retry limit hit. Relax length settings.]";
                };

                const loadWordBank = async () => {
                    if (state.wordBank && state.wordBank.Adjective) return true; 

                    try {
                        const response = await fetch('wordbanks/wordbank-base.json'); 
                        if (!response.ok) throw new Error(`Failed to fetch 'wordbanks/wordbank-base.json': ${response.statusText}`);
                        const data = await response.json();
                        
                        if (!data.wordBank) throw new Error("Invalid base wordbank file structure.");

                        state.wordBank = data.wordBank;
                        saveState();
                        return true;
                    } catch (err) {
                        console.error("Fatal Error loading wordbank:", err);
                        SafeUI.showModal("Fatal Error", `<p>Failed to load the default wordbank file from <code>wordbanks/wordbank-base.json</code>.</p>`, [{label: 'OK'}]);
                        return false;
                    }
                };

                const analyzeWordBank = async () => {
                    const selectedSeason = DOMElements.seasonalBankSelect.value;
                    
                    if (!state.wordBank) {
                        const loaded = await loadWordBank();
                        if (!loaded) return; 
                    }
                    
                    activeWordBank = JSON.parse(JSON.stringify(state.wordBank));
                    
                    if (selectedSeason !== 'none' && selectedSeason !== 'auto') {
                        try {
                            const response = await fetch(`wordbanks/wordbank-${selectedSeason}.json`);
                            if (!response.ok) throw new Error(`File not found or failed to load (Status: ${response.status})`);
                            const seasonalBank = await response.json();
                            
                            for (const category in seasonalBank) {
                                if (activeWordBank[category]) {
                                    activeWordBank[category] = [...activeWordBank[category], ...seasonalBank[category]];
                                } else {
                                    activeWordBank[category] = seasonalBank[category];
                                }
                            }
                        } catch (err) {
                            console.error(err);
                            SafeUI.showToast(`Error loading ${selectedSeason} wordbank. Using base words only.`);
                        }
                    }
                    
                    const availableCategories = Object.keys(activeWordBank).filter(cat => activeWordBank[cat] && activeWordBank[cat].length > 0);
                    
                    availableStructures = {};
                    const baseStructures = state.phraseStructures;
                    
                    const filterStructures = (structureSet) => {
                        const filtered = {};
                        if (!structureSet) return filtered; 
                        for (const num in structureSet) {
                            filtered[num] = structureSet[num].filter(chain => 
                                chain.every(category => availableCategories.includes(category))
                            );
                        }
                        return filtered;
                    };
                    
                    availableStructures.standard = filterStructures(baseStructures.standard);
                    availableStructures.seasonal = filterStructures(baseStructures.seasonal);
                };

                const renderResults = () => {
                    ListRenderer.renderList({
                        container: DOMElements.resultsList,
                        items: generatedPasswords,
                        emptyMessage: 'Click "Generate" or a button above.',
                        createItemElement: (pass) => {
                            const li = document.createElement('li');
                            li.className = 'result-item';
                            
                            const text = document.createElement('span');
                            text.textContent = pass;
                            
                            const isError = pass.startsWith('[');
                            if (isError) text.className = 'error';

                            const copyBtn = document.createElement('button');
                            copyBtn.className = 'copy-btn icon-btn';
                            copyBtn.title = 'Copy';
                            copyBtn.innerHTML = SafeUI.SVGIcons.copy;
                            copyBtn.disabled = isError;
                            copyBtn.onclick = async () => {
                                const success = await SafeUI.copyToClipboard(pass);
                                SafeUI.showToast(success ? "Copied!" : "Failed to copy.");
                            };
                            
                            li.appendChild(text);
                            li.appendChild(copyBtn);
                            return li;
                        }
                    });
                };

                const disableAllControls = () => {
                    const controlsToDisable = [
                        'btnAddQuickCopy', 'btnAddPreset', 'btnQuickGenerateTemp',
                        'passNumWords', 'passSeparator', 'seasonalBankSelect',
                        'passNumDigits', 'passNumSymbols', 'passMinLength', 'passMaxLength', 'passPadToMin',
                        'btnGenerate', 
                    ];
                    
                    controlsToDisable.forEach(key => {
                        const el = DOMElements[key];
                        if (el) {
                            el.disabled = true;
                            if (el.classList.contains('button-base')) {
                                el.style.opacity = '0.7';
                                el.style.cursor = 'not-allowed';
                            }
                        }
                    });
                    
                    ListRenderer.renderList({
                        container: DOMElements.resultsList,
                        items: [],
                        emptyMessage: 'Password generator is disabled.',
                    });
                };

                const getConfigFromUI = () => {
                    const config = {
                        passNumWords: parseInt(DOMElements.passNumWords.value, 10),
                        passSeparator: DOMElements.passSeparator.value,
                        passNumDigits: parseInt(DOMElements.passNumDigits.value, 10),
                        passNumSymbols: parseInt(DOMElements.passNumSymbols.value, 10),
                        minLength: parseInt(DOMElements.passMinLength.value, 10),
                        maxLength: parseInt(DOMElements.passMaxLength.value, 10),
                        padToMin: DOMElements.passPadToMin.checked,
                        seasonalBank: DOMElements.seasonalBankSelect.value
                    };
                    return { type: 'passphrase', config: config };
                };

                const setConfigToUI = (config) => {
                    const C = config;
                    if (DOMElements.passNumWords) DOMElements.passNumWords.value = C.passNumWords;
                    if (DOMElements.passSeparator) DOMElements.passSeparator.value = C.passSeparator;
                    if (DOMElements.passNumDigits) DOMElements.passNumDigits.value = C.passNumDigits;
                    if (DOMElements.passNumSymbols) DOMElements.passNumSymbols.value = C.passNumSymbols;
                    if (DOMElements.passMinLength) DOMElements.passMinLength.value = C.minLength;
                    if (DOMElements.passMaxLength) DOMElements.passMaxLength.value = C.maxLength;
                    if (DOMElements.passPadToMin) DOMElements.passPadToMin.checked = C.padToMin;
                    if (DOMElements.seasonalBankSelect) DOMElements.seasonalBankSelect.value = C.seasonalBank;
                };
                
                const saveGeneratorConfigToState = () => {
                    if (!state.ui) state.ui = {};
                    const { config } = getConfigFromUI();
                    
                    state.ui = {
                        ...state.ui,
                        passNumWords: config.passNumWords,
                        passSeparator: config.passSeparator,
                        passNumDigits: config.passNumDigits,
                        passNumSymbols: config.passNumSymbols,
                        passMinLength: config.minLength,
                        passMaxLength: config.maxLength,
                        passPadToMin: config.padToMin,
                        seasonalBank: config.seasonalBank
                    };
                    saveState();
                };

                const handleGenerate = async (configObj) => {
                    const { config } = configObj || getConfigFromUI();
                    
                    generatedPasswords = [];
                    for (let i = 0; i < 5; i++) {
                        generatedPasswords.push(generatePassphrase(config));
                    }
                    
                    renderResults();

                    const content = DOMElements.customGeneratorConfig;
                    if (content && !content.classList.contains('collapsed')) {
                        toggleAccordion(null);
                    }
                    
                    if (!configObj) {
                        saveGeneratorConfigToState();
                    }
                };
                
                const initQuickActions = () => {
                    const presets = state.generatorPresets || [];
                    const quickCopy = state.quickCopyItems || [];
                    
                    const combinedItems = [
                        ...presets.map(p => ({ ...p, type: 'preset' })),
                        ...quickCopy.map(q => ({ ...q, type: 'quickcopy' }))
                    ];
                    
                    window.QuickListManager.init({
                        container: DOMElements.quickActionsContainer,
                        items: combinedItems,
                        emptyMessage: "No quick actions. Save a preset or add a quick-copy password.",
                        getItemName: (item) => item.name,
                        onItemClick: async (item) => {
                            if (item.type === 'preset') {
                                setConfigToUI(item.config);
                                const content = DOMElements.customGeneratorConfig;
                                if (content && content.classList.contains('collapsed')) {
                                    toggleAccordion(null);
                                }
                                handleGenerate({ type: 'passphrase', config: item.config });
                                SafeUI.showToast(`Generated using preset: ${item.name}`);
                            } else if (item.type === 'quickcopy') {
                                const success = await SafeUI.copyToClipboard(item.value);
                                SafeUI.showToast(success ? `Copied: ${item.name}` : "Failed to copy.");
                            }
                        },
                        onDeleteClick: (item, renderCallback) => {
                            const collectionName = item.type === 'preset' ? 'Preset' : 'Password';
                            const stateKey = item.type === 'preset' ? 'generatorPresets' : 'quickCopyItems';

                            UIPatterns.confirmDelete(collectionName, item.name, () => {
                                const collection = state[stateKey];
                                const index = collection.findIndex(i => i.id === item.id);
                                if (index > -1) {
                                    collection.splice(index, 1);
                                    saveState();
                                    renderCallback();
                                }
                            });
                        },
                    });
                };

                const handleAddQuickCopy = () => {
                    SafeUI.showModal('Add Quick Copy Password', 
                        `<div class="form-group">
                            <label for="qc-name">Name (e.g., "Guest WiFi")</label>
                            <input id="qc-name" class="sidebar-input" placeholder="Name">
                         </div>
                         <div class="form-group">
                            <label for="qc-value">Password Value</label>
                            <input id="qc-value" class="sidebar-input" placeholder="The password to copy">
                         </div>`, 
                        [
                            { label: 'Cancel' },
                            { 
                                label: 'Save', 
                                class: 'button-primary', 
                                callback: () => {
                                    const name = document.getElementById('qc-name').value.trim();
                                    const value = document.getElementById('qc-value').value; 

                                    if (!SafeUI.validators.notEmpty(name) || !SafeUI.validators.maxLength(name, 50)) {
                                        SafeUI.showValidationError('Invalid Name', 'Name must be 1-50 characters.', 'qc-name');
                                        return false;
                                    }
                                    if (!SafeUI.validators.notEmpty(value)) {
                                        SafeUI.showValidationError('Invalid Password', 'Password value cannot be empty.', 'qc-value');
                                        return false;
                                    }
                                    if (DataValidator.hasDuplicate(state.quickCopyItems, 'name', name)) {
                                        SafeUI.showValidationError('Duplicate Name', 'A password with this name already exists.', 'qc-name');
                                        return false;
                                    }

                                    state.quickCopyItems.push({ id: SafeUI.generateId(), name: name, value: value });
                                    saveState();
                                    initQuickActions(); 
                                    SafeUI.showToast('Password saved!');
                                }
                            }
                        ]
                    );
                };

                const handleAddPreset = () => {
                    const { config } = getConfigFromUI();
                    SafeUI.showModal('Save Generator Preset', '<input id="preset-name" class="sidebar-input" placeholder="e.g., 4-Word TitleCase">', [
                        { label: 'Cancel' },
                        { 
                            label: 'Save', 
                            class: 'button-primary', 
                            callback: () => {
                                const name = document.getElementById('preset-name').value.trim();
                                if (!SafeUI.validators.notEmpty(name) || !SafeUI.validators.maxLength(name, 50)) {
                                    SafeUI.showValidationError('Invalid Name', 'Name must be 1-50 characters.', 'preset-name');
                                    return false;
                                }
                                if (DataValidator.hasDuplicate(state.generatorPresets, 'name', name)) {
                                    SafeUI.showValidationError('Duplicate Name', 'A preset with this name already exists.', 'preset-name');
                                    return false;
                                }

                                state.generatorPresets.push({ id: SafeUI.generateId(), name: name, config: config });
                                saveState();
                                initQuickActions(); 
                                SafeUI.showToast('Preset saved!');
                            }
                        }
                    ]);
                };

                const handleExportWordbank = () => {
                    try {
                        const data = { wordBank: state.wordBank };
                        const dataStr = JSON.stringify(data, null, 2);
                        SafeUI.downloadJSON(dataStr, 'password-wordbank-export.json', 'application/json');
                    } catch (err) {
                        showError("Export Error", err);
                    }
                };

                const handleImportWordbank = () => {
                    SafeUI.openFilePicker(async (file) => {
                        SafeUI.readJSONFile(file, async (importedData) => {
                            try {
                                if (!importedData || (!importedData.wordBank)) {
                                    throw new Error("Invalid wordbank file. Must contain a 'wordBank' object.");
                                }
                                
                                SafeUI.showModal("Confirm Wordbank Import",
                                    `<p>This will overwrite your <strong>base wordbank</strong> with the contents of this file. This cannot be undone.</p>`,
                                    [
                                        { label: 'Cancel' },
                                        { 
                                            label: 'Overwrite',
                                            class: 'button-danger',
                                            callback: async () => {
                                                state.wordBank = importedData.wordBank;
                                                saveState();
                                                await analyzeWordBank(); 
                                                SafeUI.showToast("Wordbank updated successfully.");
                                            }
                                        }
                                    ]
                                );
                            } catch (err) {
                                showError("Import Error", err);
                            }
                        }, (errorMsg) => {
                            showError('Import Error', new Error(errorMsg));
                        });
                    }, '.json');
                };

                function setupSettingsModal() {
                    const pageDataHtml = `
                        <button id="modal-export-wordbank-btn" class="button-base">Export Wordbank (JSON)</button>
                        <button id="modal-import-wordbank-btn" class="button-base">Import Wordbank (JSON)</button>
                    `;

                    const onModalOpen = () => {
                        document.getElementById('modal-export-wordbank-btn').addEventListener('click', handleExportWordbank);
                        document.getElementById('modal-import-wordbank-btn').addEventListener('click', handleImportWordbank);
                    };

                    const onRestore = (dataToRestore) => {
                        state.wordBank = dataToRestore.wordBank || null;
                        state.phraseStructures = dataToRestore.phraseStructures || defaultPhraseStructures;
                        state.symbolRules = dataToRestore.symbolRules || defaultSymbolRules;
                        state.quickCopyItems = dataToRestore.quickCopyItems || [];
                        state.generatorPresets = dataToRestore.generatorPresets || [];
                        
                        if (dataToRestore.ui) state.ui = dataToRestore.ui;
                        else state.ui = { ...defaultState.ui };

                        saveState();
                        
                        if (!state.wordBank) { 
                            loadWordBank().then(() => {
                                analyzeWordBank();
                                initQuickActions();
                            }); 
                        } else {
                            analyzeWordBank();
                            initQuickActions();
                        }
                        
                        setConfigToUI({
                            passNumWords: state.ui.passNumWords,
                            passSeparator: state.ui.passSeparator,
                            passNumDigits: state.ui.passNumDigits,
                            passNumSymbols: state.ui.passNumSymbols,
                            minLength: state.ui.passMinLength,
                            maxLength: state.ui.passMaxLength,
                            padToMin: state.ui.passPadToMin,
                            seasonalBank: state.ui.seasonalBank
                        });
                        
                        initAccordion();
                        SafeUI.showToast('Restored previous session');
                    };

                    window.SharedSettingsModal.init({
                        buttonId: 'btn-settings',
                        appName: APP_CONFIG.NAME,
                        state: state,
                        pageSpecificDataHtml: pageDataHtml, 
                        onModalOpen: onModalOpen,           
                        onRestoreCallback: onRestore,
                        itemValidators: {
                            wordBank: [],
                            phraseStructures: [],
                            symbolRules: [],
                            quickCopyItems: ['id', 'name', 'value'],
                            generatorPresets: ['id', 'name', 'config']
                        }
                    });
                }

                function attachEventListeners() {
                    DOMElements.btnAddQuickCopy.addEventListener('click', handleAddQuickCopy);
                    DOMElements.btnAddPreset.addEventListener('click', handleAddPreset);
                    
                    DOMElements.btnQuickGenerateTemp.addEventListener('click', () => {
                        handleGenerate({
                            type: 'passphrase',
                            config: {
                                passNumWords: 1, passSeparator: "", passNumDigits: 1,
                                passNumSymbols: 0, minLength: 12, maxLength: 16,
                                padToMin: false, seasonalBank: "auto"
                            }
                        });
                    });
                    
                    DOMElements.btnGenerate.addEventListener('click', () => handleGenerate(null));
                    
                    setupSettingsModal(); 
                    
                    DOMElements.seasonalBankSelect.addEventListener('change', async () => {
                        await analyzeWordBank();
                    });

                    const generatorInputs = DOMElements.customGeneratorConfig.querySelectorAll('input, select');
                    generatorInputs.forEach(input => {
                        input.addEventListener('focus', () => {
                            const content = DOMElements.customGeneratorConfig;
                            if (content && content.classList.contains('collapsed')) {
                                toggleAccordion(null);
                            }
                        });
                    });
                    
                    // Scroll Persistence
                    if (DOMElements.resultsList) {
                        DOMElements.resultsList.addEventListener('scroll', SafeUI.debounce(() => {
                            if (state.ui) {
                                state.ui.resultsScrollTop = DOMElements.resultsList.scrollTop;
                                saveState();
                            }
                        }, 500));
                    }
                    
                    // Scroll to Top
                    const scrollToTopBtn = document.getElementById('scroll-to-top');
                    const mainContent = document.querySelector('.main-content');
                    if (scrollToTopBtn && mainContent) {
                        mainContent.addEventListener('scroll', SafeUI.debounce(() => {
                            scrollToTopBtn.classList.toggle('visible', mainContent.scrollTop > 300);
                        }, 200));
                        scrollToTopBtn.addEventListener('click', () => {
                            mainContent.scrollTo({ top: 0, behavior: 'smooth' });
                        });
                    }
                }
                
                // 5. Create the init() function that was inside AppLifecycle.run
                async function init() {
                    DOMElements.btnAddPreset.innerHTML = SafeUI.SVGIcons.plus + ' Save Preset';
                    DOMElements.btnAddQuickCopy.innerHTML = SafeUI.SVGIcons.plus + ' Add Quick Copy';
                    
                    initAccordion();
                    
                    const loaded = await loadWordBank();
                    if (!loaded) {
                        disableAllControls(); 
                        return; 
                    }
                    
                    await analyzeWordBank();

                    // PERSISTENCE: Restore inputs
                    if (state.ui) {
                        setConfigToUI({
                            passNumWords: state.ui.passNumWords,
                            passSeparator: state.ui.passSeparator,
                            passNumDigits: state.ui.passNumDigits,
                            passNumSymbols: state.ui.passNumSymbols,
                            minLength: state.ui.passMinLength,
                            maxLength: state.ui.passMaxLength,
                            padToMin: state.ui.passPadToMin,
                            seasonalBank: state.ui.seasonalBank
                        });
                        
                        if (Object.keys(state.ui).some(key => state.ui[key] !== defaultState.ui[key])) {
                            SafeUI.showToast('Restored previous session');
                        }
                    }

                    attachEventListeners();
                    initQuickActions(); 
                    renderResults(); 
                    
                    // PERSISTENCE: Restore scroll
                    if (state.ui && state.ui.resultsScrollTop && DOMElements.resultsList) {
                        setTimeout(() => {
                            DOMElements.resultsList.scrollTop = state.ui.resultsScrollTop;
                        }, 0);
                    }
                }

                // 6. Call init()
                init();
            
            // 7. Add the catch block for the new (async) wrapper
            } catch (err) {
                console.error("Unhandled exception during initialization:", err);
                const banner = document.getElementById('app-startup-error');
                if (banner) {
                    banner.innerHTML = `<strong>Application Error</strong><p style="margin:0.25rem 0 0 0;font-weight:normal;">Unexpected error: ${err.message}</p>`;
                    banner.classList.remove('hidden');
                }
            }
        })(); // End of self-invoking async function
    }
    </script>
</body>
</html>
