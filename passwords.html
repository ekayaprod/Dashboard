<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Passwords</title>
    <link rel="stylesheet" href="style.css">
    <!-- Page-specific styles for new layout -->
    <style>
        /* Use app-container from style.css for consistent padding/layout */
        .app-container {
            padding: 0; /* Let panel handle padding */
        }
        .main-content {
            padding: 0.75rem; /* Add padding inside the panel */
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        /* Tweak shortcut-item for this page */
        .shortcuts-container .shortcut-item {
            cursor: pointer;
            padding-right: 0.5rem; /* Make room for delete button */
        }
        /* Static password items (Quick Copy) */
        .shortcuts-container .shortcut-item.static-pass .drag-handle {
            content: 'ðŸ“‹'; /* Use a copy icon */
            cursor: pointer;
            color: var(--subtle-text);
            padding-right: 0.4rem;
        }
        /* Generator preset items */
        .shortcuts-container .shortcut-item.generator-preset .drag-handle {
            content: 'â–¶'; /* Use a play icon */
            cursor: pointer;
            color: var(--primary-color);
            padding-right: 0.4rem;
        }

        .shortcuts-container .shortcut-item .delete-btn {
            display: none;
            margin-left: 0.5rem;
        }
        .shortcuts-container .shortcut-item:hover .delete-btn {
            display: inline-flex;
        }
        .shortcuts-container .shortcut-item a {
            flex-grow: 1;
        }
        .shortcuts-container .shortcut-item:hover {
            background-color: var(--info-bg);
        }

        /* Section wrapper for generator, results, etc. */
        .generator-section {
            padding: 0.75rem;
            background-color: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
        }

        /* Results Section */
        .results-wrapper {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        /* Strength Meter */
        .strength-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
            color: var(--subtle-text);
        }
        .strength-label #strength-text {
            color: var(--text-color);
        }
        .strength-bar-outer {
            width: 100%;
            height: 8px;
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
        }
        .strength-bar-inner {
            height: 100%;
            width: 0%;
            border-radius: 4px;
            background-color: var(--danger-color);
            transition: width 0.3s, background-color 0.3s;
        }
        .strength-bar-inner.strength-weak { background-color: #ef4444; width: 25%; }
        .strength-bar-inner.strength-medium { background-color: #f59e0b; width: 60%; }
        .strength-bar-inner.strength-strong { background-color: #22c55e; width: 100%; }

        /* New Results List */
        .result-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 200px; /* Allow scrolling for results */
            overflow-y: auto;
        }
        .result-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: var(--info-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 0.5rem 0.5rem 0.5rem 0.75rem;
            gap: 0.5rem;
        }
        .result-item span {
            font-family: monospace;
            font-size: 0.95rem;
            word-break: break-all;
            flex-grow: 1;
        }
        /* Style for error messages */
        .result-item span.error {
            font-family: var(--font-family);
            color: var(--danger-color);
            font-weight: 500;
            font-size: 0.85rem;
        }
        .result-item .copy-btn {
            flex-shrink: 0;
            color: var(--subtle-text);
        }
        .result-item .copy-btn:hover {
            color: var(--primary-color);
            background-color: var(--primary-hover-bg-light);
        }
        
        /* --- UI Tightening Fixes START --- */
        .config-section {
            display: flex;
            flex-direction: column;
            gap: 0.5rem; /* Was 0.75rem */
            margin-bottom: 0.75rem; /* Was 1rem */
        }
        .config-section h4 {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--subtle-text);
            text-transform: uppercase;
            margin: 0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.2rem; /* Was 0.25rem */
        }
        .config-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem; /* Was 0.75rem */
        }
        .config-grid .form-group {
            margin: 0;
        }
        .config-grid .sidebar-input {
            margin: 0;
            padding: 0.35rem 0.5rem; /* Was 0.5rem 0.6rem */
        }
        
        /* New rule for compact labels */
        .config-grid .form-group label {
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: 0.1rem;
            color: var(--subtle-text);
            display: block;
        }

        .checkbox-label {
            font-size: 0.8rem; /* Was 0.85rem */
            font-weight: 500;
            margin-bottom: 0; /* Was 0.25rem */
            display: flex;
            align-items: center;
            gap: 0.35rem; /* Was 0.5rem */
            cursor: pointer;
        }
        
        /* Removed .length-options and .length-range rules */
        /* --- UI Tightening Fixes END --- */


        /* Dark mode adjustments */
        @media (prefers-color-scheme: dark) {
            .generator-section, .results-wrapper {
                background-color: var(--panel-bg);
                border-color: var(--border-color);
            }
            .strength-bar-outer {
                background-color: #4b5563;
                border: none;
            }
            .result-item {
                background-color: var(--bg-color);
                border-color: var(--border-color);
            }
            .result-item .copy-btn:hover {
                background-color: var(--primary-hover-bg-light);
            }
        }
    </style>
</head>
<body> <!-- Removed lookup-page class -->

    <div id="navbar-container"></div>

    <div class="app-container">
        <div class="panel">
            <div class="main-content">
                <!-- CHANGE 1: Added standard error banner -->
                <div id="app-startup-error" class="hidden" style="position:sticky;top:0;left:0;width:100%;padding:1rem;background-color:#fef2f2;color:#dc2626;border-bottom:2px solid #fecaca;font-family:sans-serif;font-size:1rem;font-weight:600;z-index:10000;box-sizing:border-box;"></div>

                <!-- Header -->
                <header class="section-header-wrapper" style="padding: 0 0.25rem;">
                    <h3 class="section-header">Password Generator</h3>
                    <div class="header-actions button-group">
                        <button id="btn-export-wordbank" class="button-base">Export Wordbank</button>
                        <button id="btn-import-wordbank" class="button-base">Import Wordbank</button>
                        <button id="btn-settings" class="icon-btn" title="Settings"></button>
                    </div>
                </header>

                <!-- 1. Quick Actions (Presets & Quick Copy) -->
                <div class="generator-section">
                    <div class="section-header-wrapper" style="margin-bottom: 0.75rem;">
                        <h3 class="section-header">Quick Actions</h3>
                        <div class="button-group">
                            <!-- CHANGE 5: Removed broken icon text -->
                            <button id="btn-add-preset" class="button-base button-primary" title="Save current settings as a new preset">
                                Save Preset
                            </button>
                            <button id="btn-add-quick-copy" class="button-base" title="Add static password">
                                Add Quick Copy
                            </button>
                        </div>
                    </div>
                    <div id="quick-actions-container" class="shortcuts-container">
                        <!-- Presets and Quick Copy items will be rendered here -->
                    </div>
                </div>
                
                <!-- 2. "Temporary Password" Button (Remains separate for full-width layout) -->
                <div class="generator-section">
                     <button id="btn-quick-generate-temp" class="button-base button-primary" style="width: 100%; padding: 0.75rem; font-size: 0.9rem;">
                        Generate Temporary Password
                    </button>
                </div>

                <div class="divider" style="margin: 0.25rem 0;"></div>
                
                <!-- 3. Custom Generator (Main Attraction) -->
                <div class="generator-section">
                    <h3 class="section-header" style="margin-bottom: 0.75rem;">Custom Generator</h3>
                    <!-- Passphrase Tab -->
                    <div id="tab-content-passphrase">
                        <div class="config-section">
                            <h4>Structure</h4>
                            <div class="config-grid">
                                <div class="form-group">
                                    <label for="passNumWords"># Words</label>
                                    <select id="passNumWords" class="sidebar-input">
                                        <option value="0">0 (Digits/Symbols only)</option>
                                        <option value="1">1</option>
                                        <option value="2">2</option>
                                        <option value="3" selected>3</option>
                                        <option value="4">4</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="passSeparator">Separator</label>
                                    <select id="passSeparator" class="sidebar-input"><option value="-">-</option><option value="_">_</option><option value=" ">space</option><option value="" selected>None (TitleCase)</option></select>
                                </div>
                            </div>
                            <div class="form-group">
                                <label for="seasonal-bank-select" class="config-grid .form-group label">Seasonal Theme</label>
                                <select id="seasonal-bank-select" class="sidebar-input">
                                    <option value="auto" selected>Auto (Current Season)</option>
                                    <option value="none">None</option>
                                    <option value="winter">Winter</option>
                                    <option value="spring">Spring</option>
                                    <option value="summer">Summer</option>
                                    <option value="autumn">Autumn</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <span id="wordbank-status" class="form-help" style="margin: 0; min-height: 1.2em;">Loading wordbank...</span>
                            </div>
                        </div>
                        
                        <!-- --- UI Tightening Fix: Merged Add-ons and Length --- -->
                        <div class="config-section">
                            <h4>Add-ons & Length</h4>
                            <div class="config-grid">
                                <!-- Add-ons -->
                                <div class="form-group">
                                    <label for="passNumDigits"># Digits</label>
                                    <input type="number" id="passNumDigits" value="2" min="0" max="9" class="sidebar-input">
                                </div>
                                <div class="form-group">
                                    <label for="passNumSymbols"># Symbols</label>
                                    <input type="number" id="passNumSymbols" value="1" min="0" max="4" class="sidebar-input">
                                </div>
                                <!-- Length -->
                                <div class="form-group">
                                    <label for="passMinLength">Min</label>
                                    <input type="number" id="passMinLength" value="12" min="4" max="64" class="sidebar-input">
                                </div>
                                <div class="form-group">
                                    <label for="passMaxLength">Max</label>
                                    <input type="number" id="passMaxLength" value="16" min="4" max="64" class="sidebar-input">
                                </div>
                            </div>
                            <label class="checkbox-label" style="margin-top: 0.25rem; margin-bottom: 0;">
                                <input type="checkbox" id="passPadToMin">
                                <span>Pad to minimum length</span>
                            </label>
                        </div>
                        <!-- --- End UI Tightening Fix --- -->
                    
                        <!-- Generate Button -->
                        <div class="generate-actions">
                            <button id="btn-generate" class="button-base button-primary" style="width: 100%; padding: 0.75rem;">Generate</button>
                        </div>
                    </div>
                </div>

                <div class="divider" style="margin: 0.25rem 0;"></div>

                <!-- 4. Results Container -->
                <div class="results-wrapper generator-section">
                    <!-- Strength Meter -->
                    <div class="strength-meter-container">
                        <div class="strength-label">
                            <span>Strength</span>
                            <span id="strength-text">N/A</span>
                        </div>
                        <div class="strength-bar-outer">
                            <div id="strength-bar-inner" class="strength-bar-inner"></div>
                        </div>
                    </div>
                    <!-- Results List -->
                    <ul id="results-list" class="result-list">
                        <div class="empty-state-message">
                            Click "Generate" or a button above.
                        </div>
                    </ul>
                </div>

            </div>
        </div>
    </div>

    <!-- Toast and Modal HTML -->
    <div id="toast" class="toast"></div>
    <div id="modal-overlay" class="modal-overlay">
        <div id="modal-content" class="modal-content"></div>
    </div>

    <script src="js/app-core.js"></script>
    <script src="js/app-ui.js"></script>
    <script src="js/app-data.js"></script>
    <script>
    // CHANGE 2: Replaced entire watchdog script with "gold standard" from lookup/mailto
    // Dependency Check
    (() => {
        const dependencies = ['SafeUI', 'UIPatterns', 'ListRenderer', 'SearchHelper', 'BackupRestore', 'DataValidator', 'DataConverter']; // CsvManager not used
        const missing = dependencies.filter(dep => typeof window[dep] === 'undefined');
        if (missing.length > 0) {
            const errorTitle = "Application Failed to Load";
            const errorMessage = `One or more required JavaScript files (e.g., app-core.js) failed to load, or core modules are missing. Missing: ${missing.join(', ')}`;
            
            console.error(errorMessage);
            
            // Check if AppLifecycle itself loaded to use its banner function
            if (typeof window.AppLifecycle !== 'undefined' && typeof window.AppLifecycle._showErrorBanner === 'function') {
                window.AppLifecycle._showErrorBanner(errorTitle, errorMessage);
            } else {
                // Fallback to directly manipulating the banner if AppLifecycle failed
                const banner = document.getElementById('app-startup-error');
                if(banner) {
                    banner.innerHTML = `<strong>${errorTitle}</strong><p style="margin:0.25rem 0 0 0;font-weight:normal;">${errorMessage}</p>`;
                    banner.classList.remove('hidden');
                }
            }
            throw new Error(`Critical dependencies missing: ${missing.join(', ')}`);
        }
    })();


    AppLifecycle.run(async () => {

            const APP_CONFIG = {
                NAME: 'passwords',
                VERSION: '1.4.2', // UI Tightening
                DATA_KEY: 'passwords_v1_data',
            };
            
            // ====================================================================
            // DEFAULT STATE & LOGIC
            // ====================================================================
            
            const defaultPhraseStructures = {
                "standard": {
                    "1": [["Compound"]], 
                    "2": [["Adjective","Animal"],["Adjective","Object"],["Color","Object"],["Color","Animal"],["Verb","Animal"]],
                    "3": [["Adjective","Color","Animal"],["Verb","Adjective","Object"],["Adjective","Object","Verb"]],
                    "4": [["Adjective","Animal","Color","Verb"],["Color","Adjective","Object","Verb"]]
                },
                "seasonal": {
                    "1": [["Noun"], ["Adjective"]],
                    "2": [["Adjective","Object"],["Adjective","Noun"],["Verb","Animal"],["Color","Noun"]],
                    "3": [["Adjective","Color","Concept"],["Adjective","Verb","Object"],["Verb","Adjective","Noun"]],
                    "4.": [["Adjective","Verb","Color","Noun"],["Adjective","Adjective","Object","Verb"]]
                },
                "fallback": { 
                    "0": [],
                    "1": [["Object"]], 
                    "2": [["Object"], ["Object"]],
                    "3": [["Object"], ["Object"], ["Object"]],
                    "4": [["Object"], ["Object"], ["Object"], ["Object"]]
                }
            };
            
            const defaultSymbolRules = {"beforeNum":["$","#","*"],"afterNum":["%","+"],"junction":["=","@",".","-"],"end":["!","?"]};

            const TEMP_PASSWORD_CONFIG = {
                type: 'passphrase',
                config: {
                    passNumWords: 1,
                    passSeparator: "",
                    passNumDigits: 2,
                    passNumSymbols: 1,
                    minLength: 12,
                    maxLength: 16,
                    padToMin: true,
                    seasonalBank: "none" // Keep this as 'none'
                }
            };

            const defaultState = {
                wordBank: null,       
                // CHANGE 4a: Removed tempWordList: [],
                phraseStructures: defaultPhraseStructures,
                symbolRules: defaultSymbolRules,
                // CHANGE 3: Removed "Guest WiFi"
                quickCopyItems: [],
                // CHANGE 3: Removed "Standard (3-word)" and "Long (4-word)"
                generatorPresets: [],
                settings: {}
            };

            const ctx = await AppLifecycle.initPage({
                storageKey: APP_CONFIG.DATA_KEY,
                defaultState: defaultState,
                version: APP_CONFIG.VERSION,
                requiredElements: [
                    'quick-actions-container', 'btn-add-quick-copy', 'btn-add-preset',
                    'btn-quick-generate-temp',
                    'tab-content-passphrase',
                    'passNumWords', 'passSeparator', 'seasonal-bank-select', 'wordbank-status',
                    'passNumDigits', 'passNumSymbols', 
                    'passMinLength', 'passMaxLength', 'passPadToMin',
                    'btn-generate',
                    'strength-text', 'strength-bar-inner',
                    'results-list',
                    'btn-export-wordbank', 'btn-import-wordbank', 'btn-settings',
                    'toast', 'modal-overlay', 'modal-content',
                    'navbar-container'
                ]
            });

            if (!ctx) return;

            let { elements: DOMElements, state, saveState } = ctx;
            let generatedPasswords = [];
            
            let activeWordBank = {}; 
            let availableStructures = {};

            // ====================================================================
            // GENERATION LOGIC
            // ====================================================================

            const getRand = (() => {
                let cryptoAvailable = window.crypto && window.crypto.getRandomValues;
                if (!cryptoAvailable) {
                    console.warn("Crypto API not available. Falling back to Math.random(). This is not secure for password generation.");
                }
                
                return (m) => {
                    if (cryptoAvailable) {
                        try {
                            const r = new Uint32Array(1);
                            window.crypto.getRandomValues(r);
                            return r[0] % m;
                        } catch (e) {
                            console.error("Crypto API failed, falling back to Math.random() for this call.", e);
                            cryptoAvailable = false; // Stop trying to use it
                        }
                    }
                    return Math.floor(Math.random() * m);
                };
            })();

            const R = (a) => a[getRand(a.length)];
            const Cap = (s) => s.charAt(0).toUpperCase() + s.slice(1).toLowerCase();

            const getSeason = (d) => {
                const Y=d.getFullYear();
                function getMemorialDay(y){const date=new Date(y,4,31);date.setDate(date.getDate()-(date.getDay()+6)%7);return date}
                function getLaborDay(y){const date=new Date(y,8,1);const dayOfWeek=date.getDay();const offset=(dayOfWeek<=1)?1-dayOfWeek:8-dayOfWeek;date.setDate(date.getDate()+offset);return date}
                const memorialDay=getMemorialDay(Y);const laborDay=getLaborDay(Y);const springOfficialStart=new Date(Y,2,17);const summerOfficialStart=memorialDay;const autumnOfficialStart=laborDay;const winterOfficialStart=new Date(Y,11,1);
                const springStart=new Date(springOfficialStart.getTime()-7*24*60*60*1000);const springEnd=new Date(summerOfficialStart.getTime()-60*24*60*60*1000);const summerStart=new Date(summerOfficialStart.getTime()-7*24*60*60*1000);const summerEnd=new Date(autumnOfficialStart.getTime()-60*24*60*60*1000);const autumnStart=new Date(autumnOfficialStart.getTime()-7*24*60*60*1000);const autumnEnd=new Date(winterOfficialStart.getTime()-60*24*60*60*1000);const winterStart=new Date(winterOfficialStart.getTime()-7*24*60*60*1000);const winterEnd=new Date(springOfficialStart.getTime()-60*24*60*60*1000);
                if(d>=springStart&&d<=springEnd)return'spring';if(d>=summerStart&&d<=summerEnd)return'summer';if(d>=autumnStart&&d<=autumnEnd)return'autumn';if(d>=winterStart||d<=winterEnd)return'winter';return null;
            };

            const validateConstraints = (C, P_structs, resolvedSeason) => {
                if (C.minLength > C.maxLength) {
                    return `[Min length > Max length]`;
                }
                
                let P;
                if (resolvedSeason && P_structs.seasonal) {
                    P = P_structs.seasonal;
                } else {
                    P = P_structs.standard;
                }
                
                if (!P || !P[C.passNumWords] || P[C.passNumWords].length === 0) {
                    if (!P_structs.fallback || !P_structs.fallback[C.passNumWords] || P_structs.fallback[C.passNumWords].length === 0) {
                        return `[Invalid # Words: ${C.passNumWords}]`;
                    }
                }
                
                let minAddonLength = C.passNumDigits + C.passNumSymbols;
                if (C.passNumWords > 1) {
                    minAddonLength += (C.passNumWords - 1) * C.passSeparator.length;
                }
                
                minAddonLength += C.passNumWords; 
                
                if (minAddonLength > C.maxLength) {
                    return `[Settings too long for Max Length]`;
                }
                
                return null; // All checks passed
            };

            const generatePassphrase = (config) => {
                const C = { ...config }; 
                const P_structs = availableStructures; 
                const W = activeWordBank;      
                const SYMBOL_RULES = state.symbolRules;
                const MAX_RETRIES = 500;
                let retries = 0;

                let resolvedSeason = C.seasonalBank;
                if (C.seasonalBank === 'auto') {
                    resolvedSeason = getSeason(new Date()); // This might be null
                }

                const constraintError = validateConstraints(C, P_structs, resolvedSeason);
                if (constraintError) {
                    return constraintError;
                }

                while (retries < MAX_RETRIES) {
                    retries++;
                    let words = [];
                    let struct;

                    if (resolvedSeason && P_structs.seasonal && P_structs.seasonal[C.passNumWords] && P_structs.seasonal[C.passNumWords].length > 0) {
                        struct = R(P_structs.seasonal[C.passNumWords]);
                    } else if (P_structs.standard && P_structs.standard[C.passNumWords] && P_structs.standard[C.passNumWords].length > 0) {
                        struct = R(P_structs.standard[C.passNumWords]);
                    } else {
                        if (!P_structs.fallback || !P_structs.fallback[C.passNumWords] || P_structs.fallback[C.passNumWords].length === 0) {
                             return "[No valid fallback structure found]";
                        }
                        struct = R(P_structs.fallback[C.passNumWords]);
                    }
                    
                    if (!struct) return "[No valid word structure found]"; 

                    words = struct.map(cat => {
                        if (!W[cat] || W[cat].length === 0) {
                            // This provides a fallback to 'Object' if a category is missing (e.g., 'Compound' on a bad load)
                            const fallbackCat = W['Object'] ? 'Object' : 'Word';
                            if (fallbackCat === 'Word') return 'Word';
                            return R(W[fallbackCat]); 
                        }
                        return R(W[cat]);
                    });

                    let wordStr;
                    if (C.passSeparator === '') {
                        words = words.map(Cap);
                        wordStr = words.join('');
                    } else {
                        words = words.map(w => w.toLowerCase());
                        wordStr = words.join(C.passSeparator);
                    }

                    let numberBlock = [];
                    for (let j = 0; j < C.passNumDigits; j++) { numberBlock.push(getRand(10)); }

                    let preliminaryLength = wordStr.length + numberBlock.length + C.passNumSymbols; // Estimate
                    
                    if (C.padToMin && preliminaryLength < C.minLength) {
                        const paddingNeeded = C.minLength - preliminaryLength;
                        for (let j = 0; j < paddingNeeded; j++) {
                            numberBlock.push(getRand(10)); 
                        }
                    }

                    let symbolsToUse = { beforeNum: '', afterNum: '', junction: '', end: '' };
                    let symbolLength = 0;

                    if (C.passNumSymbols > 0) {
                        let availableTypes = ['end', 'junction'];
                        if (numberBlock.length > 0) { availableTypes.push('beforeNum', 'afterNum'); }
                        
                        for (let k = availableTypes.length - 1; k > 0; k--) {
                            const l = getRand(k + 1);
                            [availableTypes[k], availableTypes[l]] = [availableTypes[l], availableTypes[k]];
                        }
                        for (let j = 0; j < C.passNumSymbols; j++) {
                            if (availableTypes.length === 0) break;
                            let type = availableTypes.shift();
                            if (type && SYMBOL_RULES[type]) {
                                const symbol = R(SYMBOL_RULES[type]);
                                symbolsToUse[type] = symbol;
                                symbolLength += symbol.length;
                            }
                        }
                    }

                    let numberPart = symbolsToUse.beforeNum + numberBlock.join('') + symbolsToUse.afterNum;
                    let finalPass = (getRand(2) === 0 && numberPart) 
                        ? (numberPart + symbolsToUse.junction + wordStr) 
                        : (wordStr + symbolsToUse.junction + numberPart);
                    finalPass += symbolsToUse.end;

                    if (finalPass.length > C.maxLength) {
                        continue; 
                    }
                    if (!C.padToMin && finalPass.length < C.minLength) {
                        continue; 
                    }

                    return finalPass; // Success!
                }

                console.warn(`Failed to generate password with constraints after ${MAX_RETRIES} retries.`);
                return "[Retry limit hit. Relax length settings.]";
            };

            const calculateStrength = (password) => {
                let score = 0;
                if (!password) return { score: 0, text: 'N/A', class: '' };
                if (password.startsWith('[')) return { score: 0, text: 'Failed', class: '' };

                if (password.length >= 16) score += 3;
                else if (password.length >= 12) score += 2;
                else if (password.length >= 8) score += 1;

                if (/[a-z]/.test(password)) score++;
                if (/[A-Z]/.test(password)) score++;
                if (/\d/.test(password)) score++;
                if (/[^a-zA-Z0-9]/.test(password)) score++;

                if (score >= 7) return { score, text: 'Strong', class: 'strength-strong' };
                if (score >= 4) return { score, text: 'Medium', class: 'strength-medium' };
                return { score, text: 'Weak', class: 'strength-weak' };
            };

            // ====================================================================
            // DATA LOADING & ANALYSIS
            // ====================================================================

            const loadWordBank = async () => {
                if (state.wordBank && state.wordBank.Adjective) {
                    return true; // Already loaded
                }

                try {
                    const response = await fetch('wordbanks/wordbank-base.json');
                    if (!response.ok) {
                        throw new Error(`Failed to fetch 'wordbanks/wordbank-base.json': ${response.statusText}`);
                    }
                    const data = await response.json();
                    
                    if (!data.wordBank) { 
                        throw new Error("Invalid base wordbank file structure.");
                    }

                    state.wordBank = data.wordBank;
                    
                    // CHANGE 4b: Removed logic that populated state.tempWordList
                    
                    saveState();
                    return true;
                } catch (err) {
                    console.error(err);
                    SafeUI.showModal("Fatal Error", `<p>Failed to load the default wordbank file from <code>wordbanks/wordbank-base.json</code>.</p><p>Please ensure the file exists and the application is run from a web server.</p>`, [{label: 'OK'}]);
                    return false;
                }
            };

            const analyzeWordBank = async () => {
                const selectedSeason = DOMElements.seasonalBankSelect.value;
                
                activeWordBank = JSON.parse(JSON.stringify(state.wordBank));
                
                // CHANGE 4c: Removed logic that used state.tempWordList
                // The activeWordBank.Compound list is now correctly populated
                // from the state.wordBank copy above.

                if (selectedSeason !== 'none' && selectedSeason !== 'auto') {
                    try {
                        const response = await fetch(`wordbanks/wordbank-${selectedSeason}.json`);
                        if (!response.ok) throw new Error(`File not found or failed to load (Status: ${response.status})`);
                        const seasonalBank = await response.json();
                        
                        for (const category in seasonalBank) {
                            if (activeWordBank[category]) {
                                activeWordBank[category] = [...activeWordBank[category], ...seasonalBank[category]];
                            } else {
                                activeWordBank[category] = seasonalBank[category];
                            }
                        }
                    } catch (err) {
                        console.error(err);
                        SafeUI.showToast(`Error loading ${selectedSeason} wordbank. Using base words only.`);
                    }
                }
                
                const availableCategories = Object.keys(activeWordBank).filter(cat => activeWordBank[cat] && activeWordBank[cat].length > 0);
                
                availableStructures = {};
                const baseStructures = state.phraseStructures;
                
                const filterStructures = (structureSet) => {
                    const filtered = {};
                    if (!structureSet) return filtered; // Add null check
                    for (const num in structureSet) {
                        filtered[num] = structureSet[num].filter(chain => 
                            chain.every(category => availableCategories.includes(category))
                        );
                    }
                    return filtered;
                };
                
                availableStructures.standard = filterStructures(baseStructures.standard);
                availableStructures.seasonal = filterStructures(baseStructures.seasonal);

                const firstCategory = availableCategories.find(c => c !== 'Compound'); 
                availableStructures.fallback = {};
                
                if (firstCategory) {
                    for (const num of ["0", "1", "2", "3", "4"]) {
                        availableStructures.fallback[num] = [
                            Array(parseInt(num, 10)).fill(firstCategory)
                        ];
                    }
                } else {
                     availableStructures.fallback = baseStructures.fallback; 
                }
                
                renderWordchainStatus(availableCategories, selectedSeason);
            };

            const renderWordchainStatus = (categories, season) => {
                let statusMsg = "";
                const standard3 = (availableStructures.standard["3"] || []).length;
                const standard1 = (availableStructures.standard["1"] || []).length;
                const seasonal3 = (availableStructures.seasonal["3"] || []).length;

                if (season === 'auto') {
                    statusMsg = `Using <strong>Auto (Current Season)</strong> wordbank.`;
                } else if (season !== 'none' && seasonal3 > 0) {
                    statusMsg = `Using <strong>Base + ${Cap(season)}</strong> wordbank.`;
                } else if (standard3 > 0) {
                    statusMsg = "Using <strong>Base</strong> wordbank.";
                } else if (standard1 > 0) {
                    statusMsg = `Using <strong>Simple List</strong> (1-word phrases only).`;
                } else if (categories.length > 0) {
                    statusMsg = `Using <strong>Custom List</strong> (random word phrases).`;
                } else {
                    statusMsg = `<span style="color: var(--danger-color);"><strong>Wordbank is empty!</strong></span>`;
                }
                DOMElements.wordbankStatus.innerHTML = statusMsg;
            };

            // ====================================================================
            // UI & EVENT HANDLERS
            // ====================================================================

            const updateStrengthMeter = (password) => {
                const { text, class: strengthClass } = calculateStrength(password);
                DOMElements.strengthText.textContent = text;
                DOMElements.strengthBarInner.className = `strength-bar-inner ${strengthClass}`;
            };

            const renderResults = () => {
                ListRenderer.renderList({
                    container: DOMElements.resultsList,
                    items: generatedPasswords,
                    emptyMessage: 'Click "Generate" or a button above.',
                    createItemElement: (pass) => {
                        const li = document.createElement('li');
                        li.className = 'result-item';
                        
                        const text = document.createElement('span');
                        text.textContent = pass;
                        
                        const isError = pass.startsWith('[');
                        if (isError) {
                            text.className = 'error';
                        }

                        const copyBtn = document.createElement('button');
                        copyBtn.className = 'copy-btn icon-btn';
                        copyBtn.title = 'Copy';
                        copyBtn.innerHTML = SafeUI.SVGIcons.copy;
                        copyBtn.disabled = isError;
                        copyBtn.onclick = async () => {
                            const success = await SafeUI.copyToClipboard(pass);
                            SafeUI.showToast(success ? "Copied!" : "Failed to copy.");
                        };
                        
                        li.appendChild(text);
                        li.appendChild(copyBtn);
                        return li;
                    }
                });
            };

            const disableAllControls = () => {
                const controlsToDisable = [
                    'btnAddQuickCopy', 'btnAddPreset', 'btnQuickGenerateTemp',
                    'passNumWords', 'passSeparator', 'seasonalBankSelect',
                    'passNumDigits', 'passNumSymbols', 'passMinLength', 'passMaxLength', 'passPadToMin',
                    'btnGenerate', 'btnExportWordbank', 'btnImportWordbank'
                ];
                
                controlsToDisable.forEach(key => {
                    const el = DOMElements[key];
                    if (el) {
                        el.disabled = true;
                        if (el.classList.contains('button-base')) {
                            el.style.opacity = '0.7';
                            el.style.cursor = 'not-allowed';
                        }
                    }
                });
                
                DOMElements.wordbankStatus.innerHTML = `<span style="color: var(--danger-color);"><strong>Fatal Error:</strong> Wordbank failed to load.</span>`;
                
                ListRenderer.renderList({
                    container: DOMElements.resultsList,
                    items: [],
                    emptyMessage: 'Password generator is disabled.',
                });
            };

            // Gets the current settings from the UI
            const getConfigFromUI = () => {
                const config = {
                    passNumWords: parseInt(DOMElements.passNumWords.value, 10),
                    passSeparator: DOMElements.passSeparator.value,
                    passNumDigits: parseInt(DOMElements.passNumDigits.value, 10),
                    passNumSymbols: parseInt(DOMElements.passNumSymbols.value, 10),
                    minLength: parseInt(DOMElements.passMinLength.value, 10),
                    maxLength: parseInt(DOMElements.passMaxLength.value, 10),
                    padToMin: DOMElements.passPadToMin.checked,
                    seasonalBank: DOMElements.seasonalBankSelect.value
                };
                return { type: 'passphrase', config: config };
            };

            // Sets the UI settings from a config object
            const setConfigToUI = (config) => {
                const C = config;
                DOMElements.passNumWords.value = C.passNumWords;
                DOMElements.passSeparator.value = C.passSeparator;
                DOMElements.passNumDigits.value = C.passNumDigits;
                DOMElements.passNumSymbols.value = C.passNumSymbols;
                DOMElements.passMinLength.value = C.minLength;
                DOMElements.passMaxLength.value = C.maxLength;
                DOMElements.passPadToMin.checked = C.padToMin;
                DOMElements.seasonalBankSelect.value = C.seasonalBank;
            };

            const handleGenerate = async (configObj) => {
                const { type, config } = configObj || getConfigFromUI();
                
                generatedPasswords = [];
                for (let i = 0; i < 5; i++) {
                    generatedPasswords.push(generatePassphrase(config));
                }
                
                if (generatedPasswords.length > 0) {
                    const firstPass = generatedPasswords[0];
                    if (firstPass && !firstPass.startsWith('[')) {
                        updateStrengthMeter(firstPass);
                    } else {
                        updateStrengthMeter(null); // Reset meter if generation failed
                    }
                }
                
                renderResults();
            };
            
            /**
             * Renders both Quick Copy and Generator Presets
             */
            const renderQuickActions = () => {
                const container = DOMElements.quickActionsContainer;
                const presets = state.generatorPresets || [];
                const quickCopy = state.quickCopyItems || [];
                
                // Combine and sort: presets first, then quick copy
                const items = [
                    ...presets.map(p => ({ ...p, type: 'preset' })),
                    ...quickCopy.map(q => ({ ...q, type: 'quickcopy' }))
                ];

                ListRenderer.renderList({
                    container: container,
                    items: items,
                    emptyMessage: "No quick actions. Save a preset or add a quick-copy password.",
                    createItemElement: (item) => {
                        const el = document.createElement('div');
                        el.className = 'shortcut-item';
                        
                        if (item.type === 'preset') {
                            // --- Render Preset ---
                            el.classList.add('generator-preset');
                            el.title = `Click to generate: ${item.name}`;
                            el.innerHTML = `
                                <span class="drag-handle" title="Generate">â–¶</span>
                                <a href="#">${SafeUI.escapeHTML(item.name)}</a>
                                <button class="delete-btn icon-btn" title="Delete">${SafeUI.SVGIcons.trash}</button>
                            `;
                            
                            el.addEventListener('click', async (e) => {
                                e.preventDefault();
                                if (e.target.closest('.delete-btn')) return;
                                setConfigToUI(item.config);
                                handleGenerate({ type: 'passphrase', config: item.config });
                            });

                            el.querySelector('.delete-btn').addEventListener('click', (e) => {
                                e.stopPropagation();
                                e.preventDefault();
                                UIPatterns.confirmDelete('Preset', item.name, () => {
                                    state.generatorPresets = state.generatorPresets.filter(p => p.id !== item.id);
                                    saveState();
                                    renderQuickActions();
                                });
                            });

                        } else {
                            // --- Render Quick Copy ---
                            el.classList.add('static-pass');
                            el.title = `Click to copy: ${item.name}`;
                            el.innerHTML = `
                                <span class="drag-handle" title="Copy">${SafeUI.SVGIcons.copy.replace('16','14')}</span>
                                <a href="#">${SafeUI.escapeHTML(item.name)}</a>
                                <button class="delete-btn icon-btn" title="Delete">${SafeUI.SVGIcons.trash}</button>
                            `;
                            
                            el.addEventListener('click', async (e) => {
                                e.preventDefault();
                                if (e.target.closest('.delete-btn')) return;
                                const success = await SafeUI.copyToClipboard(item.value);
                                SafeUI.showToast(success ? `Copied: ${item.name}` : "Failed to copy.");
                            });

                            el.querySelector('.delete-btn').addEventListener('click', (e) => {
                                e.stopPropagation();
                                e.preventDefault();
                                UIPatterns.confirmDelete('Password', item.name, () => {
                                    state.quickCopyItems = state.quickCopyItems.filter(p => p.id !== item.id);
                                    saveState();
                                    renderQuickActions();
                                });
                            });
                        }
                        return el;
                    }
                });
            };

            /**
             * Shows modal to add a new Quick Copy (static) password
             */
            const handleAddQuickCopy = () => {
                SafeUI.showModal('Add Quick Copy Password', 
                    `<div class="form-group">
                        <label for="qc-name">Name (e.g., "Guest WiFi")</label>
                        <input id="qc-name" class="sidebar-input" placeholder="Name">
                     </div>
                     <div class="form-group">
                        <label for="qc-value">Password Value</label>
                        <input id="qc-value" class="sidebar-input" placeholder="The password to copy">
                     </div>`, 
                    [
                        { label: 'Cancel' },
                        { 
                            label: 'Save', 
                            class: 'button-primary', 
                            callback: () => {
                                const name = document.getElementById('qc-name').value.trim();
                                const value = document.getElementById('qc-value').value; // Don't trim password

                                if (!SafeUI.validators.notEmpty(name) || !SafeUI.validators.maxLength(name, 50)) {
                                    SafeUI.showValidationError('Invalid Name', 'Name must be 1-50 characters.', 'qc-name');
                                    return false;
                                }
                                if (!SafeUI.validators.notEmpty(value)) {
                                    SafeUI.showValidationError('Invalid Password', 'Password value cannot be empty.', 'qc-value');
                                    return false;
                                }
                                if (DataValidator.hasDuplicate(state.quickCopyItems, 'name', name)) {
                                    SafeUI.showValidationError('Duplicate Name', 'A password with this name already exists.', 'qc-name');
                                    return false;
                                }

                                const newItem = {
                                    id: SafeUI.generateId(),
                                    name: name,
                                    value: value
                                };

                                state.quickCopyItems.push(newItem);
                                saveState();
                                renderQuickActions(); 
                                SafeUI.showToast('Password saved!');
                            }
                        }
                    ]
                );
            };

            /**
             * Shows modal to save current settings as a new Generator Preset
             */
            const handleAddPreset = () => {
                const { type, config } = getConfigFromUI();
                
                SafeUI.showModal('Save Generator Preset', '<input id="preset-name" class="sidebar-input" placeholder="e.g., 4-Word TitleCase">', [
                    { label: 'Cancel' },
                    { 
                        label: 'Save', 
                        class: 'button-primary', 
                        callback: () => {
                            const name = document.getElementById('preset-name').value.trim();
                            if (!SafeUI.validators.notEmpty(name) || !SafeUI.validators.maxLength(name, 50)) {
                                SafeUI.showValidationError('Invalid Name', 'Name must be 1-50 characters.', 'preset-name');
                                return false;
                            }
                            if (DataValidator.hasDuplicate(state.generatorPresets, 'name', name)) {
                                SafeUI.showValidationError('Duplicate Name', 'A preset with this name already exists.', 'preset-name');
                                return false;
                            }

                            const newPreset = {
                                id: SafeUI.generateId(),
                                name: name,
                                config: config
                            };

                            state.generatorPresets.push(newPreset);
                            saveState();
                            renderQuickActions(); 
                            SafeUI.showToast('Preset saved!');
                        }
                    }
                ]);
            };

            // Wordbank Import/Export
            const handleExportWordbank = () => {
                try {
                    // CHANGE 4d: Removed tempWordList from export
                    const data = {
                        wordBank: state.wordBank
                    }
                    const dataStr = JSON.stringify(data, null, 2);
                    SafeUI.downloadJSON(dataStr, 'password-wordbank-export.json', 'application/json');
                } catch (err) {
                    console.error("Export failed:", err);
                    SafeUI.showModal("Export Error", `<p>${SafeUI.escapeHTML(err.message)}</p>`, [{label: 'OK'}]);
                }
            };

            const handleImportWordbank = () => {
                SafeUI.openFilePicker(async (file) => {
                    SafeUI.readJSONFile(file, async (importedData) => {
                        try {
                            if (!importedData || (!importedData.wordBank)) {
                                throw new Error("Invalid wordbank file. Must contain a 'wordBank' object.");
                            }
                            
                            SafeUI.showModal("Confirm Wordbank Import",
                                `<p>This will overwrite your <strong>base wordbank</strong> with the contents of this file. This cannot be undone.</p>`,
                                [
                                    { label: 'Cancel' },
                                    { 
                                        label: 'Overwrite',
                                        class: 'button-danger',
                                        callback: async () => {
                                            state.wordBank = importedData.wordBank;
                                            // CHANGE 4e: Removed logic that populated state.tempWordList
                                            saveState();
                                            await analyzeWordBank(); // Re-analyze
                                            SafeUI.showToast("Wordbank updated successfully.");
                                        }
                                    }
                                ]
                            );
                        } catch (err) {
                            console.error("Import failed:", err);
                            SafeUI.showModal("Import Error", `<p>${SafeUI.escapeHTML(err.message)}</T>`, [{label: 'OK'}]);
                        }
                    }, (errorMsg) => {
                        SafeUI.showModal('Import Error', `<p>${SafeUI.escapeHTML(errorMsg)}</p>`, [{label: 'OK'}]);
                    });
                }, '.json');
            };

            // Settings Modal
            const showSettingsModal = () => {
                const modalContent = `
                    <div class="form-group">
                        <label>Advanced Data Management</label>
                        <p class="form-help">Use these tools for disaster recovery. This will backup your wordbanks, presets, and all settings for this page.</p>
                        <div class="button-group">
                            <button id="modal-backup-btn" class="button-base">Backup ALL (JSON)</button>
                            <button id="modal-restore-btn" class="button-base">Restore ALL (JSON)</button>
                        </div>
                    </div>
                `;
                
                SafeUI.showModal("Settings", modalContent, [{ label: 'Close' }]);

                BackupRestore.setupBackupRestoreHandlers({
                    state: state,
                    appName: APP_CONFIG.NAME,
                    backupBtn: document.getElementById('modal-backup-btn'),
                    restoreBtn: document.getElementById('modal-restore-btn'),
                    itemValidators: {
                        wordBank: [], 
                        phraseStructures: [],
                        symbolRules: [],
                        quickCopyItems: ['id', 'name', 'value'], 
                        generatorPresets: ['id', 'name', 'config']
                    },
                    restoreConfirmMessage: 'This will overwrite all password generator data (wordbanks, presets, etc.). This cannot be undone.',
                    onRestoreCallback: async (dataToRestore) => { 
                        state.wordBank = dataToRestore.wordBank || null; 
                        state.phraseStructures = dataToRestore.phraseStructures || defaultPhraseStructures;
                        state.symbolRules = dataToRestore.symbolRules || defaultSymbolRules;
                        // CHANGE 4f: Removed state.tempWordList
                        state.quickCopyItems = dataToRestore.quickCopyItems || []; 
                        state.generatorPresets = dataToRestore.generatorPresets || [];
                        
                        saveState();
                        
                        if (!state.wordBank) {
                            await loadWordBank(); 
                        }
                        await analyzeWordBank();
                        
                        renderQuickActions(); 
                        SafeUI.showToast('Password data restored.');
                        SafeUI.hideModal();
                    }
                });
            };


            /**
             * Attaches all primary event listeners
             */
            function attachEventListeners() {
                // Quick Copy
                DOMElements.btnAddQuickCopy.addEventListener('click', handleAddQuickCopy);
                
                // Generator Presets
                DOMElements.btnAddPreset.addEventListener('click', handleAddPreset);

                // Quick Generate
                DOMElements.btnQuickGenerateTemp.addEventListener('click', () => {
                    handleGenerate(TEMP_PASSWORD_CONFIG);
                });

                // Custom Generator
                DOMElements.btnGenerate.addEventListener('click', () => handleGenerate(null));
                
                // Header Buttons
                DOMElements.btnExportWordbank.addEventListener('click', handleExportWordbank);
                DOMElements.btnImportWordbank.addEventListener('click', handleImportWordbank);
                DOMElements.btnSettings.addEventListener('click', showSettingsModal);

                // Re-analyze when seasonal bank is changed
                DOMElements.seasonalBankSelect.addEventListener('change', async () => {
                    await analyzeWordBank();
                });
            }
            
            /**
             * Entry point
             */
            async function init() { // Made async
                DOMElements.btnSettings.innerHTML = SafeUI.SVGIcons.settings;
                
                // CHANGE 5: Added icon rendering for new buttons
                DOMElements.btnAddPreset.innerHTML = SafeUI.SVGIcons.plus + ' Save Preset';
                DOMElements.btnAddQuickCopy.innerHTML = SafeUI.SVGIcons.plus + ' Add Quick Copy';
                
                // Load base wordbank (if needed)
                const loaded = await loadWordBank();
                if (!loaded) {
                    disableAllControls(); 
                    return; // Stop if load failed
                }
                
                // Analyze the loaded bank
                await analyzeWordBank();

                attachEventListeners();
                renderQuickActions(); 
                renderResults(); // Set initial empty state for results
                updateStrengthMeter(null); // Set initial strength meter
                
                SafeUI.loadNavbar("navbar-container");
            }

            // Run the app
            init();
        });
    </script>
</body>
</html>

